
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserLibraryStory
 * 
 */
export type UserLibraryStory = $Result.DefaultSelection<Prisma.$UserLibraryStoryPayload>
/**
 * Model UserLibraryChapter
 * 
 */
export type UserLibraryChapter = $Result.DefaultSelection<Prisma.$UserLibraryChapterPayload>
/**
 * Model UserTranslatedChapter
 * 
 */
export type UserTranslatedChapter = $Result.DefaultSelection<Prisma.$UserTranslatedChapterPayload>
/**
 * Model UserTranslationVersion
 * 
 */
export type UserTranslationVersion = $Result.DefaultSelection<Prisma.$UserTranslationVersionPayload>
/**
 * Model UserApiKey
 * 
 */
export type UserApiKey = $Result.DefaultSelection<Prisma.$UserApiKeyPayload>
/**
 * Model Provider
 * 
 */
export type Provider = $Result.DefaultSelection<Prisma.$ProviderPayload>
/**
 * Model Model
 * 
 */
export type Model = $Result.DefaultSelection<Prisma.$ModelPayload>
/**
 * Model DefaultKey
 * 
 */
export type DefaultKey = $Result.DefaultSelection<Prisma.$DefaultKeyPayload>
/**
 * Model Dictionary
 * 
 */
export type Dictionary = $Result.DefaultSelection<Prisma.$DictionaryPayload>
/**
 * Model UserApiKeyToModel
 * 
 */
export type UserApiKeyToModel = $Result.DefaultSelection<Prisma.$UserApiKeyToModelPayload>
/**
 * Model DefaultKeyToModel
 * 
 */
export type DefaultKeyToModel = $Result.DefaultSelection<Prisma.$DefaultKeyToModelPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ApiKeyStatus: {
  ACTIVE: 'ACTIVE',
  COOLDOWN: 'COOLDOWN',
  EXHAUSTED: 'EXHAUSTED'
};

export type ApiKeyStatus = (typeof ApiKeyStatus)[keyof typeof ApiKeyStatus]


export const ChapterStatus: {
  DRAFT: 'DRAFT',
  TRANSLATING: 'TRANSLATING',
  TRANSLATED: 'TRANSLATED',
  REVIEWING: 'REVIEWING',
  PUBLISHED: 'PUBLISHED'
};

export type ChapterStatus = (typeof ChapterStatus)[keyof typeof ChapterStatus]

}

export type ApiKeyStatus = $Enums.ApiKeyStatus

export const ApiKeyStatus: typeof $Enums.ApiKeyStatus

export type ChapterStatus = $Enums.ChapterStatus

export const ChapterStatus: typeof $Enums.ChapterStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLibraryStory`: Exposes CRUD operations for the **UserLibraryStory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLibraryStories
    * const userLibraryStories = await prisma.userLibraryStory.findMany()
    * ```
    */
  get userLibraryStory(): Prisma.UserLibraryStoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLibraryChapter`: Exposes CRUD operations for the **UserLibraryChapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLibraryChapters
    * const userLibraryChapters = await prisma.userLibraryChapter.findMany()
    * ```
    */
  get userLibraryChapter(): Prisma.UserLibraryChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTranslatedChapter`: Exposes CRUD operations for the **UserTranslatedChapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTranslatedChapters
    * const userTranslatedChapters = await prisma.userTranslatedChapter.findMany()
    * ```
    */
  get userTranslatedChapter(): Prisma.UserTranslatedChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTranslationVersion`: Exposes CRUD operations for the **UserTranslationVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTranslationVersions
    * const userTranslationVersions = await prisma.userTranslationVersion.findMany()
    * ```
    */
  get userTranslationVersion(): Prisma.UserTranslationVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userApiKey`: Exposes CRUD operations for the **UserApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserApiKeys
    * const userApiKeys = await prisma.userApiKey.findMany()
    * ```
    */
  get userApiKey(): Prisma.UserApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.model`: Exposes CRUD operations for the **Model** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.model.findMany()
    * ```
    */
  get model(): Prisma.ModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.defaultKey`: Exposes CRUD operations for the **DefaultKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DefaultKeys
    * const defaultKeys = await prisma.defaultKey.findMany()
    * ```
    */
  get defaultKey(): Prisma.DefaultKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dictionary`: Exposes CRUD operations for the **Dictionary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dictionaries
    * const dictionaries = await prisma.dictionary.findMany()
    * ```
    */
  get dictionary(): Prisma.DictionaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userApiKeyToModel`: Exposes CRUD operations for the **UserApiKeyToModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserApiKeyToModels
    * const userApiKeyToModels = await prisma.userApiKeyToModel.findMany()
    * ```
    */
  get userApiKeyToModel(): Prisma.UserApiKeyToModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.defaultKeyToModel`: Exposes CRUD operations for the **DefaultKeyToModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DefaultKeyToModels
    * const defaultKeyToModels = await prisma.defaultKeyToModel.findMany()
    * ```
    */
  get defaultKeyToModel(): Prisma.DefaultKeyToModelDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserLibraryStory: 'UserLibraryStory',
    UserLibraryChapter: 'UserLibraryChapter',
    UserTranslatedChapter: 'UserTranslatedChapter',
    UserTranslationVersion: 'UserTranslationVersion',
    UserApiKey: 'UserApiKey',
    Provider: 'Provider',
    Model: 'Model',
    DefaultKey: 'DefaultKey',
    Dictionary: 'Dictionary',
    UserApiKeyToModel: 'UserApiKeyToModel',
    DefaultKeyToModel: 'DefaultKeyToModel'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userLibraryStory" | "userLibraryChapter" | "userTranslatedChapter" | "userTranslationVersion" | "userApiKey" | "provider" | "model" | "defaultKey" | "dictionary" | "userApiKeyToModel" | "defaultKeyToModel"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserLibraryStory: {
        payload: Prisma.$UserLibraryStoryPayload<ExtArgs>
        fields: Prisma.UserLibraryStoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLibraryStoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryStoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLibraryStoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryStoryPayload>
          }
          findFirst: {
            args: Prisma.UserLibraryStoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryStoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLibraryStoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryStoryPayload>
          }
          findMany: {
            args: Prisma.UserLibraryStoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryStoryPayload>[]
          }
          create: {
            args: Prisma.UserLibraryStoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryStoryPayload>
          }
          createMany: {
            args: Prisma.UserLibraryStoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserLibraryStoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryStoryPayload>
          }
          update: {
            args: Prisma.UserLibraryStoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryStoryPayload>
          }
          deleteMany: {
            args: Prisma.UserLibraryStoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLibraryStoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserLibraryStoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryStoryPayload>
          }
          aggregate: {
            args: Prisma.UserLibraryStoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLibraryStory>
          }
          groupBy: {
            args: Prisma.UserLibraryStoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLibraryStoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserLibraryStoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserLibraryStoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserLibraryStoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserLibraryStoryCountAggregateOutputType> | number
          }
        }
      }
      UserLibraryChapter: {
        payload: Prisma.$UserLibraryChapterPayload<ExtArgs>
        fields: Prisma.UserLibraryChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLibraryChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLibraryChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryChapterPayload>
          }
          findFirst: {
            args: Prisma.UserLibraryChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLibraryChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryChapterPayload>
          }
          findMany: {
            args: Prisma.UserLibraryChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryChapterPayload>[]
          }
          create: {
            args: Prisma.UserLibraryChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryChapterPayload>
          }
          createMany: {
            args: Prisma.UserLibraryChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserLibraryChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryChapterPayload>
          }
          update: {
            args: Prisma.UserLibraryChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryChapterPayload>
          }
          deleteMany: {
            args: Prisma.UserLibraryChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLibraryChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserLibraryChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryChapterPayload>
          }
          aggregate: {
            args: Prisma.UserLibraryChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLibraryChapter>
          }
          groupBy: {
            args: Prisma.UserLibraryChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLibraryChapterGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserLibraryChapterFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserLibraryChapterAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserLibraryChapterCountArgs<ExtArgs>
            result: $Utils.Optional<UserLibraryChapterCountAggregateOutputType> | number
          }
        }
      }
      UserTranslatedChapter: {
        payload: Prisma.$UserTranslatedChapterPayload<ExtArgs>
        fields: Prisma.UserTranslatedChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTranslatedChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslatedChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTranslatedChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslatedChapterPayload>
          }
          findFirst: {
            args: Prisma.UserTranslatedChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslatedChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTranslatedChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslatedChapterPayload>
          }
          findMany: {
            args: Prisma.UserTranslatedChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslatedChapterPayload>[]
          }
          create: {
            args: Prisma.UserTranslatedChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslatedChapterPayload>
          }
          createMany: {
            args: Prisma.UserTranslatedChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserTranslatedChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslatedChapterPayload>
          }
          update: {
            args: Prisma.UserTranslatedChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslatedChapterPayload>
          }
          deleteMany: {
            args: Prisma.UserTranslatedChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTranslatedChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTranslatedChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslatedChapterPayload>
          }
          aggregate: {
            args: Prisma.UserTranslatedChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTranslatedChapter>
          }
          groupBy: {
            args: Prisma.UserTranslatedChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTranslatedChapterGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserTranslatedChapterFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserTranslatedChapterAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserTranslatedChapterCountArgs<ExtArgs>
            result: $Utils.Optional<UserTranslatedChapterCountAggregateOutputType> | number
          }
        }
      }
      UserTranslationVersion: {
        payload: Prisma.$UserTranslationVersionPayload<ExtArgs>
        fields: Prisma.UserTranslationVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTranslationVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslationVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTranslationVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslationVersionPayload>
          }
          findFirst: {
            args: Prisma.UserTranslationVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslationVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTranslationVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslationVersionPayload>
          }
          findMany: {
            args: Prisma.UserTranslationVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslationVersionPayload>[]
          }
          create: {
            args: Prisma.UserTranslationVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslationVersionPayload>
          }
          createMany: {
            args: Prisma.UserTranslationVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserTranslationVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslationVersionPayload>
          }
          update: {
            args: Prisma.UserTranslationVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslationVersionPayload>
          }
          deleteMany: {
            args: Prisma.UserTranslationVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTranslationVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTranslationVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTranslationVersionPayload>
          }
          aggregate: {
            args: Prisma.UserTranslationVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTranslationVersion>
          }
          groupBy: {
            args: Prisma.UserTranslationVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTranslationVersionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserTranslationVersionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserTranslationVersionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserTranslationVersionCountArgs<ExtArgs>
            result: $Utils.Optional<UserTranslationVersionCountAggregateOutputType> | number
          }
        }
      }
      UserApiKey: {
        payload: Prisma.$UserApiKeyPayload<ExtArgs>
        fields: Prisma.UserApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyPayload>
          }
          findFirst: {
            args: Prisma.UserApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyPayload>
          }
          findMany: {
            args: Prisma.UserApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyPayload>[]
          }
          create: {
            args: Prisma.UserApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyPayload>
          }
          createMany: {
            args: Prisma.UserApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyPayload>
          }
          update: {
            args: Prisma.UserApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.UserApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyPayload>
          }
          aggregate: {
            args: Prisma.UserApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserApiKey>
          }
          groupBy: {
            args: Prisma.UserApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserApiKeyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserApiKeyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserApiKeyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<UserApiKeyCountAggregateOutputType> | number
          }
        }
      }
      Provider: {
        payload: Prisma.$ProviderPayload<ExtArgs>
        fields: Prisma.ProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          createMany: {
            args: Prisma.ProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProviderFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProviderAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      Model: {
        payload: Prisma.$ModelPayload<ExtArgs>
        fields: Prisma.ModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findFirst: {
            args: Prisma.ModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findMany: {
            args: Prisma.ModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          create: {
            args: Prisma.ModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          createMany: {
            args: Prisma.ModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          update: {
            args: Prisma.ModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          deleteMany: {
            args: Prisma.ModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          aggregate: {
            args: Prisma.ModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel>
          }
          groupBy: {
            args: Prisma.ModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ModelFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ModelAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ModelCountArgs<ExtArgs>
            result: $Utils.Optional<ModelCountAggregateOutputType> | number
          }
        }
      }
      DefaultKey: {
        payload: Prisma.$DefaultKeyPayload<ExtArgs>
        fields: Prisma.DefaultKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefaultKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefaultKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyPayload>
          }
          findFirst: {
            args: Prisma.DefaultKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefaultKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyPayload>
          }
          findMany: {
            args: Prisma.DefaultKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyPayload>[]
          }
          create: {
            args: Prisma.DefaultKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyPayload>
          }
          createMany: {
            args: Prisma.DefaultKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DefaultKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyPayload>
          }
          update: {
            args: Prisma.DefaultKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyPayload>
          }
          deleteMany: {
            args: Prisma.DefaultKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefaultKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DefaultKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyPayload>
          }
          aggregate: {
            args: Prisma.DefaultKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefaultKey>
          }
          groupBy: {
            args: Prisma.DefaultKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefaultKeyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DefaultKeyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DefaultKeyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DefaultKeyCountArgs<ExtArgs>
            result: $Utils.Optional<DefaultKeyCountAggregateOutputType> | number
          }
        }
      }
      Dictionary: {
        payload: Prisma.$DictionaryPayload<ExtArgs>
        fields: Prisma.DictionaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DictionaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictionaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DictionaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictionaryPayload>
          }
          findFirst: {
            args: Prisma.DictionaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictionaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DictionaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictionaryPayload>
          }
          findMany: {
            args: Prisma.DictionaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictionaryPayload>[]
          }
          create: {
            args: Prisma.DictionaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictionaryPayload>
          }
          createMany: {
            args: Prisma.DictionaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DictionaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictionaryPayload>
          }
          update: {
            args: Prisma.DictionaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictionaryPayload>
          }
          deleteMany: {
            args: Prisma.DictionaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DictionaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DictionaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictionaryPayload>
          }
          aggregate: {
            args: Prisma.DictionaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDictionary>
          }
          groupBy: {
            args: Prisma.DictionaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DictionaryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DictionaryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DictionaryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DictionaryCountArgs<ExtArgs>
            result: $Utils.Optional<DictionaryCountAggregateOutputType> | number
          }
        }
      }
      UserApiKeyToModel: {
        payload: Prisma.$UserApiKeyToModelPayload<ExtArgs>
        fields: Prisma.UserApiKeyToModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserApiKeyToModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyToModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserApiKeyToModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyToModelPayload>
          }
          findFirst: {
            args: Prisma.UserApiKeyToModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyToModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserApiKeyToModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyToModelPayload>
          }
          findMany: {
            args: Prisma.UserApiKeyToModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyToModelPayload>[]
          }
          create: {
            args: Prisma.UserApiKeyToModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyToModelPayload>
          }
          createMany: {
            args: Prisma.UserApiKeyToModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserApiKeyToModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyToModelPayload>
          }
          update: {
            args: Prisma.UserApiKeyToModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyToModelPayload>
          }
          deleteMany: {
            args: Prisma.UserApiKeyToModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserApiKeyToModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserApiKeyToModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApiKeyToModelPayload>
          }
          aggregate: {
            args: Prisma.UserApiKeyToModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserApiKeyToModel>
          }
          groupBy: {
            args: Prisma.UserApiKeyToModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserApiKeyToModelGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserApiKeyToModelFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserApiKeyToModelAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserApiKeyToModelCountArgs<ExtArgs>
            result: $Utils.Optional<UserApiKeyToModelCountAggregateOutputType> | number
          }
        }
      }
      DefaultKeyToModel: {
        payload: Prisma.$DefaultKeyToModelPayload<ExtArgs>
        fields: Prisma.DefaultKeyToModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefaultKeyToModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyToModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefaultKeyToModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyToModelPayload>
          }
          findFirst: {
            args: Prisma.DefaultKeyToModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyToModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefaultKeyToModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyToModelPayload>
          }
          findMany: {
            args: Prisma.DefaultKeyToModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyToModelPayload>[]
          }
          create: {
            args: Prisma.DefaultKeyToModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyToModelPayload>
          }
          createMany: {
            args: Prisma.DefaultKeyToModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DefaultKeyToModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyToModelPayload>
          }
          update: {
            args: Prisma.DefaultKeyToModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyToModelPayload>
          }
          deleteMany: {
            args: Prisma.DefaultKeyToModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefaultKeyToModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DefaultKeyToModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultKeyToModelPayload>
          }
          aggregate: {
            args: Prisma.DefaultKeyToModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefaultKeyToModel>
          }
          groupBy: {
            args: Prisma.DefaultKeyToModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefaultKeyToModelGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DefaultKeyToModelFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DefaultKeyToModelAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DefaultKeyToModelCountArgs<ExtArgs>
            result: $Utils.Optional<DefaultKeyToModelCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userLibraryStory?: UserLibraryStoryOmit
    userLibraryChapter?: UserLibraryChapterOmit
    userTranslatedChapter?: UserTranslatedChapterOmit
    userTranslationVersion?: UserTranslationVersionOmit
    userApiKey?: UserApiKeyOmit
    provider?: ProviderOmit
    model?: ModelOmit
    defaultKey?: DefaultKeyOmit
    dictionary?: DictionaryOmit
    userApiKeyToModel?: UserApiKeyToModelOmit
    defaultKeyToModel?: DefaultKeyToModelOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    libraryStories: number
    UserApiKey: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    libraryStories?: boolean | UserCountOutputTypeCountLibraryStoriesArgs
    UserApiKey?: boolean | UserCountOutputTypeCountUserApiKeyArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLibraryStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLibraryStoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApiKeyWhereInput
  }


  /**
   * Count Type UserLibraryStoryCountOutputType
   */

  export type UserLibraryStoryCountOutputType = {
    chapters: number
  }

  export type UserLibraryStoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | UserLibraryStoryCountOutputTypeCountChaptersArgs
  }

  // Custom InputTypes
  /**
   * UserLibraryStoryCountOutputType without action
   */
  export type UserLibraryStoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStoryCountOutputType
     */
    select?: UserLibraryStoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserLibraryStoryCountOutputType without action
   */
  export type UserLibraryStoryCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLibraryChapterWhereInput
  }


  /**
   * Count Type UserLibraryChapterCountOutputType
   */

  export type UserLibraryChapterCountOutputType = {
    versions: number
  }

  export type UserLibraryChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | UserLibraryChapterCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * UserLibraryChapterCountOutputType without action
   */
  export type UserLibraryChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapterCountOutputType
     */
    select?: UserLibraryChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserLibraryChapterCountOutputType without action
   */
  export type UserLibraryChapterCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTranslationVersionWhereInput
  }


  /**
   * Count Type UserApiKeyCountOutputType
   */

  export type UserApiKeyCountOutputType = {
    models: number
  }

  export type UserApiKeyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | UserApiKeyCountOutputTypeCountModelsArgs
  }

  // Custom InputTypes
  /**
   * UserApiKeyCountOutputType without action
   */
  export type UserApiKeyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyCountOutputType
     */
    select?: UserApiKeyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserApiKeyCountOutputType without action
   */
  export type UserApiKeyCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApiKeyToModelWhereInput
  }


  /**
   * Count Type ProviderCountOutputType
   */

  export type ProviderCountOutputType = {
    models: number
  }

  export type ProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | ProviderCountOutputTypeCountModelsArgs
  }

  // Custom InputTypes
  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
  }


  /**
   * Count Type ModelCountOutputType
   */

  export type ModelCountOutputType = {
    userApiKeys: number
    defaultKeys: number
  }

  export type ModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userApiKeys?: boolean | ModelCountOutputTypeCountUserApiKeysArgs
    defaultKeys?: boolean | ModelCountOutputTypeCountDefaultKeysArgs
  }

  // Custom InputTypes
  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCountOutputType
     */
    select?: ModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountUserApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApiKeyToModelWhereInput
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountDefaultKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultKeyToModelWhereInput
  }


  /**
   * Count Type DefaultKeyCountOutputType
   */

  export type DefaultKeyCountOutputType = {
    models: number
  }

  export type DefaultKeyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | DefaultKeyCountOutputTypeCountModelsArgs
  }

  // Custom InputTypes
  /**
   * DefaultKeyCountOutputType without action
   */
  export type DefaultKeyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyCountOutputType
     */
    select?: DefaultKeyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DefaultKeyCountOutputType without action
   */
  export type DefaultKeyCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultKeyToModelWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    avatar: string | null
    backgroundImage: string | null
    birthdate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    avatar: string | null
    backgroundImage: string | null
    birthdate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    avatar: number
    backgroundImage: number
    birthdate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    avatar?: true
    backgroundImage?: true
    birthdate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    avatar?: true
    backgroundImage?: true
    birthdate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    avatar?: true
    backgroundImage?: true
    birthdate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    password: string
    avatar: string | null
    backgroundImage: string | null
    birthdate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    avatar?: boolean
    backgroundImage?: boolean
    birthdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    libraryStories?: boolean | User$libraryStoriesArgs<ExtArgs>
    UserApiKey?: boolean | User$UserApiKeyArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    avatar?: boolean
    backgroundImage?: boolean
    birthdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "password" | "avatar" | "backgroundImage" | "birthdate" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    libraryStories?: boolean | User$libraryStoriesArgs<ExtArgs>
    UserApiKey?: boolean | User$UserApiKeyArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      libraryStories: Prisma.$UserLibraryStoryPayload<ExtArgs>[]
      UserApiKey: Prisma.$UserApiKeyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      password: string
      avatar: string | null
      backgroundImage: string | null
      birthdate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    libraryStories<T extends User$libraryStoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$libraryStoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserApiKey<T extends User$UserApiKeyArgs<ExtArgs> = {}>(args?: Subset<T, User$UserApiKeyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly backgroundImage: FieldRef<"User", 'String'>
    readonly birthdate: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.libraryStories
   */
  export type User$libraryStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
    where?: UserLibraryStoryWhereInput
    orderBy?: UserLibraryStoryOrderByWithRelationInput | UserLibraryStoryOrderByWithRelationInput[]
    cursor?: UserLibraryStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLibraryStoryScalarFieldEnum | UserLibraryStoryScalarFieldEnum[]
  }

  /**
   * User.UserApiKey
   */
  export type User$UserApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
    where?: UserApiKeyWhereInput
    orderBy?: UserApiKeyOrderByWithRelationInput | UserApiKeyOrderByWithRelationInput[]
    cursor?: UserApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserApiKeyScalarFieldEnum | UserApiKeyScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserLibraryStory
   */

  export type AggregateUserLibraryStory = {
    _count: UserLibraryStoryCountAggregateOutputType | null
    _avg: UserLibraryStoryAvgAggregateOutputType | null
    _sum: UserLibraryStorySumAggregateOutputType | null
    _min: UserLibraryStoryMinAggregateOutputType | null
    _max: UserLibraryStoryMaxAggregateOutputType | null
  }

  export type UserLibraryStoryAvgAggregateOutputType = {
    totalChapters: number | null
  }

  export type UserLibraryStorySumAggregateOutputType = {
    totalChapters: number | null
  }

  export type UserLibraryStoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    author: string | null
    storyAvatar: string | null
    userId: string | null
    totalChapters: number | null
    isHidden: boolean | null
    isComplete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserLibraryStoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    author: string | null
    storyAvatar: string | null
    userId: string | null
    totalChapters: number | null
    isHidden: boolean | null
    isComplete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserLibraryStoryCountAggregateOutputType = {
    id: number
    name: number
    author: number
    storyAvatar: number
    userId: number
    totalChapters: number
    isHidden: number
    isComplete: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserLibraryStoryAvgAggregateInputType = {
    totalChapters?: true
  }

  export type UserLibraryStorySumAggregateInputType = {
    totalChapters?: true
  }

  export type UserLibraryStoryMinAggregateInputType = {
    id?: true
    name?: true
    author?: true
    storyAvatar?: true
    userId?: true
    totalChapters?: true
    isHidden?: true
    isComplete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserLibraryStoryMaxAggregateInputType = {
    id?: true
    name?: true
    author?: true
    storyAvatar?: true
    userId?: true
    totalChapters?: true
    isHidden?: true
    isComplete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserLibraryStoryCountAggregateInputType = {
    id?: true
    name?: true
    author?: true
    storyAvatar?: true
    userId?: true
    totalChapters?: true
    isHidden?: true
    isComplete?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserLibraryStoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLibraryStory to aggregate.
     */
    where?: UserLibraryStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraryStories to fetch.
     */
    orderBy?: UserLibraryStoryOrderByWithRelationInput | UserLibraryStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLibraryStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraryStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraryStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLibraryStories
    **/
    _count?: true | UserLibraryStoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLibraryStoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLibraryStorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLibraryStoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLibraryStoryMaxAggregateInputType
  }

  export type GetUserLibraryStoryAggregateType<T extends UserLibraryStoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLibraryStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLibraryStory[P]>
      : GetScalarType<T[P], AggregateUserLibraryStory[P]>
  }




  export type UserLibraryStoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLibraryStoryWhereInput
    orderBy?: UserLibraryStoryOrderByWithAggregationInput | UserLibraryStoryOrderByWithAggregationInput[]
    by: UserLibraryStoryScalarFieldEnum[] | UserLibraryStoryScalarFieldEnum
    having?: UserLibraryStoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLibraryStoryCountAggregateInputType | true
    _avg?: UserLibraryStoryAvgAggregateInputType
    _sum?: UserLibraryStorySumAggregateInputType
    _min?: UserLibraryStoryMinAggregateInputType
    _max?: UserLibraryStoryMaxAggregateInputType
  }

  export type UserLibraryStoryGroupByOutputType = {
    id: string
    name: string
    author: string
    storyAvatar: string | null
    userId: string
    totalChapters: number
    isHidden: boolean
    isComplete: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserLibraryStoryCountAggregateOutputType | null
    _avg: UserLibraryStoryAvgAggregateOutputType | null
    _sum: UserLibraryStorySumAggregateOutputType | null
    _min: UserLibraryStoryMinAggregateOutputType | null
    _max: UserLibraryStoryMaxAggregateOutputType | null
  }

  type GetUserLibraryStoryGroupByPayload<T extends UserLibraryStoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLibraryStoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLibraryStoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLibraryStoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserLibraryStoryGroupByOutputType[P]>
        }
      >
    >


  export type UserLibraryStorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    author?: boolean
    storyAvatar?: boolean
    userId?: boolean
    totalChapters?: boolean
    isHidden?: boolean
    isComplete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapters?: boolean | UserLibraryStory$chaptersArgs<ExtArgs>
    _count?: boolean | UserLibraryStoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLibraryStory"]>



  export type UserLibraryStorySelectScalar = {
    id?: boolean
    name?: boolean
    author?: boolean
    storyAvatar?: boolean
    userId?: boolean
    totalChapters?: boolean
    isHidden?: boolean
    isComplete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserLibraryStoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "author" | "storyAvatar" | "userId" | "totalChapters" | "isHidden" | "isComplete" | "createdAt" | "updatedAt", ExtArgs["result"]["userLibraryStory"]>
  export type UserLibraryStoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapters?: boolean | UserLibraryStory$chaptersArgs<ExtArgs>
    _count?: boolean | UserLibraryStoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserLibraryStoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLibraryStory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      chapters: Prisma.$UserLibraryChapterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      author: string
      storyAvatar: string | null
      userId: string
      totalChapters: number
      isHidden: boolean
      isComplete: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userLibraryStory"]>
    composites: {}
  }

  type UserLibraryStoryGetPayload<S extends boolean | null | undefined | UserLibraryStoryDefaultArgs> = $Result.GetResult<Prisma.$UserLibraryStoryPayload, S>

  type UserLibraryStoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLibraryStoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLibraryStoryCountAggregateInputType | true
    }

  export interface UserLibraryStoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLibraryStory'], meta: { name: 'UserLibraryStory' } }
    /**
     * Find zero or one UserLibraryStory that matches the filter.
     * @param {UserLibraryStoryFindUniqueArgs} args - Arguments to find a UserLibraryStory
     * @example
     * // Get one UserLibraryStory
     * const userLibraryStory = await prisma.userLibraryStory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLibraryStoryFindUniqueArgs>(args: SelectSubset<T, UserLibraryStoryFindUniqueArgs<ExtArgs>>): Prisma__UserLibraryStoryClient<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLibraryStory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLibraryStoryFindUniqueOrThrowArgs} args - Arguments to find a UserLibraryStory
     * @example
     * // Get one UserLibraryStory
     * const userLibraryStory = await prisma.userLibraryStory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLibraryStoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLibraryStoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLibraryStoryClient<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLibraryStory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryStoryFindFirstArgs} args - Arguments to find a UserLibraryStory
     * @example
     * // Get one UserLibraryStory
     * const userLibraryStory = await prisma.userLibraryStory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLibraryStoryFindFirstArgs>(args?: SelectSubset<T, UserLibraryStoryFindFirstArgs<ExtArgs>>): Prisma__UserLibraryStoryClient<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLibraryStory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryStoryFindFirstOrThrowArgs} args - Arguments to find a UserLibraryStory
     * @example
     * // Get one UserLibraryStory
     * const userLibraryStory = await prisma.userLibraryStory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLibraryStoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLibraryStoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLibraryStoryClient<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLibraryStories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryStoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLibraryStories
     * const userLibraryStories = await prisma.userLibraryStory.findMany()
     * 
     * // Get first 10 UserLibraryStories
     * const userLibraryStories = await prisma.userLibraryStory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLibraryStoryWithIdOnly = await prisma.userLibraryStory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLibraryStoryFindManyArgs>(args?: SelectSubset<T, UserLibraryStoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLibraryStory.
     * @param {UserLibraryStoryCreateArgs} args - Arguments to create a UserLibraryStory.
     * @example
     * // Create one UserLibraryStory
     * const UserLibraryStory = await prisma.userLibraryStory.create({
     *   data: {
     *     // ... data to create a UserLibraryStory
     *   }
     * })
     * 
     */
    create<T extends UserLibraryStoryCreateArgs>(args: SelectSubset<T, UserLibraryStoryCreateArgs<ExtArgs>>): Prisma__UserLibraryStoryClient<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLibraryStories.
     * @param {UserLibraryStoryCreateManyArgs} args - Arguments to create many UserLibraryStories.
     * @example
     * // Create many UserLibraryStories
     * const userLibraryStory = await prisma.userLibraryStory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLibraryStoryCreateManyArgs>(args?: SelectSubset<T, UserLibraryStoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserLibraryStory.
     * @param {UserLibraryStoryDeleteArgs} args - Arguments to delete one UserLibraryStory.
     * @example
     * // Delete one UserLibraryStory
     * const UserLibraryStory = await prisma.userLibraryStory.delete({
     *   where: {
     *     // ... filter to delete one UserLibraryStory
     *   }
     * })
     * 
     */
    delete<T extends UserLibraryStoryDeleteArgs>(args: SelectSubset<T, UserLibraryStoryDeleteArgs<ExtArgs>>): Prisma__UserLibraryStoryClient<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLibraryStory.
     * @param {UserLibraryStoryUpdateArgs} args - Arguments to update one UserLibraryStory.
     * @example
     * // Update one UserLibraryStory
     * const userLibraryStory = await prisma.userLibraryStory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLibraryStoryUpdateArgs>(args: SelectSubset<T, UserLibraryStoryUpdateArgs<ExtArgs>>): Prisma__UserLibraryStoryClient<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLibraryStories.
     * @param {UserLibraryStoryDeleteManyArgs} args - Arguments to filter UserLibraryStories to delete.
     * @example
     * // Delete a few UserLibraryStories
     * const { count } = await prisma.userLibraryStory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLibraryStoryDeleteManyArgs>(args?: SelectSubset<T, UserLibraryStoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLibraryStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryStoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLibraryStories
     * const userLibraryStory = await prisma.userLibraryStory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLibraryStoryUpdateManyArgs>(args: SelectSubset<T, UserLibraryStoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserLibraryStory.
     * @param {UserLibraryStoryUpsertArgs} args - Arguments to update or create a UserLibraryStory.
     * @example
     * // Update or create a UserLibraryStory
     * const userLibraryStory = await prisma.userLibraryStory.upsert({
     *   create: {
     *     // ... data to create a UserLibraryStory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLibraryStory we want to update
     *   }
     * })
     */
    upsert<T extends UserLibraryStoryUpsertArgs>(args: SelectSubset<T, UserLibraryStoryUpsertArgs<ExtArgs>>): Prisma__UserLibraryStoryClient<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLibraryStories that matches the filter.
     * @param {UserLibraryStoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userLibraryStory = await prisma.userLibraryStory.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserLibraryStoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserLibraryStory.
     * @param {UserLibraryStoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userLibraryStory = await prisma.userLibraryStory.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserLibraryStoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserLibraryStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryStoryCountArgs} args - Arguments to filter UserLibraryStories to count.
     * @example
     * // Count the number of UserLibraryStories
     * const count = await prisma.userLibraryStory.count({
     *   where: {
     *     // ... the filter for the UserLibraryStories we want to count
     *   }
     * })
    **/
    count<T extends UserLibraryStoryCountArgs>(
      args?: Subset<T, UserLibraryStoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLibraryStoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLibraryStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryStoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLibraryStoryAggregateArgs>(args: Subset<T, UserLibraryStoryAggregateArgs>): Prisma.PrismaPromise<GetUserLibraryStoryAggregateType<T>>

    /**
     * Group by UserLibraryStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryStoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLibraryStoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLibraryStoryGroupByArgs['orderBy'] }
        : { orderBy?: UserLibraryStoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLibraryStoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLibraryStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLibraryStory model
   */
  readonly fields: UserLibraryStoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLibraryStory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLibraryStoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapters<T extends UserLibraryStory$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, UserLibraryStory$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLibraryStory model
   */
  interface UserLibraryStoryFieldRefs {
    readonly id: FieldRef<"UserLibraryStory", 'String'>
    readonly name: FieldRef<"UserLibraryStory", 'String'>
    readonly author: FieldRef<"UserLibraryStory", 'String'>
    readonly storyAvatar: FieldRef<"UserLibraryStory", 'String'>
    readonly userId: FieldRef<"UserLibraryStory", 'String'>
    readonly totalChapters: FieldRef<"UserLibraryStory", 'Int'>
    readonly isHidden: FieldRef<"UserLibraryStory", 'Boolean'>
    readonly isComplete: FieldRef<"UserLibraryStory", 'Boolean'>
    readonly createdAt: FieldRef<"UserLibraryStory", 'DateTime'>
    readonly updatedAt: FieldRef<"UserLibraryStory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLibraryStory findUnique
   */
  export type UserLibraryStoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraryStory to fetch.
     */
    where: UserLibraryStoryWhereUniqueInput
  }

  /**
   * UserLibraryStory findUniqueOrThrow
   */
  export type UserLibraryStoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraryStory to fetch.
     */
    where: UserLibraryStoryWhereUniqueInput
  }

  /**
   * UserLibraryStory findFirst
   */
  export type UserLibraryStoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraryStory to fetch.
     */
    where?: UserLibraryStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraryStories to fetch.
     */
    orderBy?: UserLibraryStoryOrderByWithRelationInput | UserLibraryStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLibraryStories.
     */
    cursor?: UserLibraryStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraryStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraryStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLibraryStories.
     */
    distinct?: UserLibraryStoryScalarFieldEnum | UserLibraryStoryScalarFieldEnum[]
  }

  /**
   * UserLibraryStory findFirstOrThrow
   */
  export type UserLibraryStoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraryStory to fetch.
     */
    where?: UserLibraryStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraryStories to fetch.
     */
    orderBy?: UserLibraryStoryOrderByWithRelationInput | UserLibraryStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLibraryStories.
     */
    cursor?: UserLibraryStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraryStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraryStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLibraryStories.
     */
    distinct?: UserLibraryStoryScalarFieldEnum | UserLibraryStoryScalarFieldEnum[]
  }

  /**
   * UserLibraryStory findMany
   */
  export type UserLibraryStoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraryStories to fetch.
     */
    where?: UserLibraryStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraryStories to fetch.
     */
    orderBy?: UserLibraryStoryOrderByWithRelationInput | UserLibraryStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLibraryStories.
     */
    cursor?: UserLibraryStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraryStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraryStories.
     */
    skip?: number
    distinct?: UserLibraryStoryScalarFieldEnum | UserLibraryStoryScalarFieldEnum[]
  }

  /**
   * UserLibraryStory create
   */
  export type UserLibraryStoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLibraryStory.
     */
    data: XOR<UserLibraryStoryCreateInput, UserLibraryStoryUncheckedCreateInput>
  }

  /**
   * UserLibraryStory createMany
   */
  export type UserLibraryStoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLibraryStories.
     */
    data: UserLibraryStoryCreateManyInput | UserLibraryStoryCreateManyInput[]
  }

  /**
   * UserLibraryStory update
   */
  export type UserLibraryStoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLibraryStory.
     */
    data: XOR<UserLibraryStoryUpdateInput, UserLibraryStoryUncheckedUpdateInput>
    /**
     * Choose, which UserLibraryStory to update.
     */
    where: UserLibraryStoryWhereUniqueInput
  }

  /**
   * UserLibraryStory updateMany
   */
  export type UserLibraryStoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLibraryStories.
     */
    data: XOR<UserLibraryStoryUpdateManyMutationInput, UserLibraryStoryUncheckedUpdateManyInput>
    /**
     * Filter which UserLibraryStories to update
     */
    where?: UserLibraryStoryWhereInput
    /**
     * Limit how many UserLibraryStories to update.
     */
    limit?: number
  }

  /**
   * UserLibraryStory upsert
   */
  export type UserLibraryStoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLibraryStory to update in case it exists.
     */
    where: UserLibraryStoryWhereUniqueInput
    /**
     * In case the UserLibraryStory found by the `where` argument doesn't exist, create a new UserLibraryStory with this data.
     */
    create: XOR<UserLibraryStoryCreateInput, UserLibraryStoryUncheckedCreateInput>
    /**
     * In case the UserLibraryStory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLibraryStoryUpdateInput, UserLibraryStoryUncheckedUpdateInput>
  }

  /**
   * UserLibraryStory delete
   */
  export type UserLibraryStoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
    /**
     * Filter which UserLibraryStory to delete.
     */
    where: UserLibraryStoryWhereUniqueInput
  }

  /**
   * UserLibraryStory deleteMany
   */
  export type UserLibraryStoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLibraryStories to delete
     */
    where?: UserLibraryStoryWhereInput
    /**
     * Limit how many UserLibraryStories to delete.
     */
    limit?: number
  }

  /**
   * UserLibraryStory findRaw
   */
  export type UserLibraryStoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserLibraryStory aggregateRaw
   */
  export type UserLibraryStoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserLibraryStory.chapters
   */
  export type UserLibraryStory$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
    where?: UserLibraryChapterWhereInput
    orderBy?: UserLibraryChapterOrderByWithRelationInput | UserLibraryChapterOrderByWithRelationInput[]
    cursor?: UserLibraryChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLibraryChapterScalarFieldEnum | UserLibraryChapterScalarFieldEnum[]
  }

  /**
   * UserLibraryStory without action
   */
  export type UserLibraryStoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryStory
     */
    select?: UserLibraryStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryStory
     */
    omit?: UserLibraryStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryStoryInclude<ExtArgs> | null
  }


  /**
   * Model UserLibraryChapter
   */

  export type AggregateUserLibraryChapter = {
    _count: UserLibraryChapterCountAggregateOutputType | null
    _avg: UserLibraryChapterAvgAggregateOutputType | null
    _sum: UserLibraryChapterSumAggregateOutputType | null
    _min: UserLibraryChapterMinAggregateOutputType | null
    _max: UserLibraryChapterMaxAggregateOutputType | null
  }

  export type UserLibraryChapterAvgAggregateOutputType = {
    chapterNumber: number | null
  }

  export type UserLibraryChapterSumAggregateOutputType = {
    chapterNumber: number | null
  }

  export type UserLibraryChapterMinAggregateOutputType = {
    id: string | null
    chapterName: string | null
    storyId: string | null
    isHidden: boolean | null
    chapterNumber: number | null
    rawText: string | null
    status: $Enums.ChapterStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserLibraryChapterMaxAggregateOutputType = {
    id: string | null
    chapterName: string | null
    storyId: string | null
    isHidden: boolean | null
    chapterNumber: number | null
    rawText: string | null
    status: $Enums.ChapterStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserLibraryChapterCountAggregateOutputType = {
    id: number
    chapterName: number
    storyId: number
    isHidden: number
    chapterNumber: number
    rawText: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserLibraryChapterAvgAggregateInputType = {
    chapterNumber?: true
  }

  export type UserLibraryChapterSumAggregateInputType = {
    chapterNumber?: true
  }

  export type UserLibraryChapterMinAggregateInputType = {
    id?: true
    chapterName?: true
    storyId?: true
    isHidden?: true
    chapterNumber?: true
    rawText?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserLibraryChapterMaxAggregateInputType = {
    id?: true
    chapterName?: true
    storyId?: true
    isHidden?: true
    chapterNumber?: true
    rawText?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserLibraryChapterCountAggregateInputType = {
    id?: true
    chapterName?: true
    storyId?: true
    isHidden?: true
    chapterNumber?: true
    rawText?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserLibraryChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLibraryChapter to aggregate.
     */
    where?: UserLibraryChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraryChapters to fetch.
     */
    orderBy?: UserLibraryChapterOrderByWithRelationInput | UserLibraryChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLibraryChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraryChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraryChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLibraryChapters
    **/
    _count?: true | UserLibraryChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLibraryChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLibraryChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLibraryChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLibraryChapterMaxAggregateInputType
  }

  export type GetUserLibraryChapterAggregateType<T extends UserLibraryChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLibraryChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLibraryChapter[P]>
      : GetScalarType<T[P], AggregateUserLibraryChapter[P]>
  }




  export type UserLibraryChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLibraryChapterWhereInput
    orderBy?: UserLibraryChapterOrderByWithAggregationInput | UserLibraryChapterOrderByWithAggregationInput[]
    by: UserLibraryChapterScalarFieldEnum[] | UserLibraryChapterScalarFieldEnum
    having?: UserLibraryChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLibraryChapterCountAggregateInputType | true
    _avg?: UserLibraryChapterAvgAggregateInputType
    _sum?: UserLibraryChapterSumAggregateInputType
    _min?: UserLibraryChapterMinAggregateInputType
    _max?: UserLibraryChapterMaxAggregateInputType
  }

  export type UserLibraryChapterGroupByOutputType = {
    id: string
    chapterName: string
    storyId: string
    isHidden: boolean
    chapterNumber: number
    rawText: string
    status: $Enums.ChapterStatus
    createdAt: Date
    updatedAt: Date
    _count: UserLibraryChapterCountAggregateOutputType | null
    _avg: UserLibraryChapterAvgAggregateOutputType | null
    _sum: UserLibraryChapterSumAggregateOutputType | null
    _min: UserLibraryChapterMinAggregateOutputType | null
    _max: UserLibraryChapterMaxAggregateOutputType | null
  }

  type GetUserLibraryChapterGroupByPayload<T extends UserLibraryChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLibraryChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLibraryChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLibraryChapterGroupByOutputType[P]>
            : GetScalarType<T[P], UserLibraryChapterGroupByOutputType[P]>
        }
      >
    >


  export type UserLibraryChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterName?: boolean
    storyId?: boolean
    isHidden?: boolean
    chapterNumber?: boolean
    rawText?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | UserLibraryStoryDefaultArgs<ExtArgs>
    translation?: boolean | UserLibraryChapter$translationArgs<ExtArgs>
    versions?: boolean | UserLibraryChapter$versionsArgs<ExtArgs>
    _count?: boolean | UserLibraryChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLibraryChapter"]>



  export type UserLibraryChapterSelectScalar = {
    id?: boolean
    chapterName?: boolean
    storyId?: boolean
    isHidden?: boolean
    chapterNumber?: boolean
    rawText?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserLibraryChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chapterName" | "storyId" | "isHidden" | "chapterNumber" | "rawText" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["userLibraryChapter"]>
  export type UserLibraryChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | UserLibraryStoryDefaultArgs<ExtArgs>
    translation?: boolean | UserLibraryChapter$translationArgs<ExtArgs>
    versions?: boolean | UserLibraryChapter$versionsArgs<ExtArgs>
    _count?: boolean | UserLibraryChapterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserLibraryChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLibraryChapter"
    objects: {
      story: Prisma.$UserLibraryStoryPayload<ExtArgs>
      translation: Prisma.$UserTranslatedChapterPayload<ExtArgs> | null
      versions: Prisma.$UserTranslationVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chapterName: string
      storyId: string
      isHidden: boolean
      chapterNumber: number
      rawText: string
      status: $Enums.ChapterStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userLibraryChapter"]>
    composites: {}
  }

  type UserLibraryChapterGetPayload<S extends boolean | null | undefined | UserLibraryChapterDefaultArgs> = $Result.GetResult<Prisma.$UserLibraryChapterPayload, S>

  type UserLibraryChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLibraryChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLibraryChapterCountAggregateInputType | true
    }

  export interface UserLibraryChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLibraryChapter'], meta: { name: 'UserLibraryChapter' } }
    /**
     * Find zero or one UserLibraryChapter that matches the filter.
     * @param {UserLibraryChapterFindUniqueArgs} args - Arguments to find a UserLibraryChapter
     * @example
     * // Get one UserLibraryChapter
     * const userLibraryChapter = await prisma.userLibraryChapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLibraryChapterFindUniqueArgs>(args: SelectSubset<T, UserLibraryChapterFindUniqueArgs<ExtArgs>>): Prisma__UserLibraryChapterClient<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLibraryChapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLibraryChapterFindUniqueOrThrowArgs} args - Arguments to find a UserLibraryChapter
     * @example
     * // Get one UserLibraryChapter
     * const userLibraryChapter = await prisma.userLibraryChapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLibraryChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLibraryChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLibraryChapterClient<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLibraryChapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryChapterFindFirstArgs} args - Arguments to find a UserLibraryChapter
     * @example
     * // Get one UserLibraryChapter
     * const userLibraryChapter = await prisma.userLibraryChapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLibraryChapterFindFirstArgs>(args?: SelectSubset<T, UserLibraryChapterFindFirstArgs<ExtArgs>>): Prisma__UserLibraryChapterClient<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLibraryChapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryChapterFindFirstOrThrowArgs} args - Arguments to find a UserLibraryChapter
     * @example
     * // Get one UserLibraryChapter
     * const userLibraryChapter = await prisma.userLibraryChapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLibraryChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLibraryChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLibraryChapterClient<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLibraryChapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLibraryChapters
     * const userLibraryChapters = await prisma.userLibraryChapter.findMany()
     * 
     * // Get first 10 UserLibraryChapters
     * const userLibraryChapters = await prisma.userLibraryChapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLibraryChapterWithIdOnly = await prisma.userLibraryChapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLibraryChapterFindManyArgs>(args?: SelectSubset<T, UserLibraryChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLibraryChapter.
     * @param {UserLibraryChapterCreateArgs} args - Arguments to create a UserLibraryChapter.
     * @example
     * // Create one UserLibraryChapter
     * const UserLibraryChapter = await prisma.userLibraryChapter.create({
     *   data: {
     *     // ... data to create a UserLibraryChapter
     *   }
     * })
     * 
     */
    create<T extends UserLibraryChapterCreateArgs>(args: SelectSubset<T, UserLibraryChapterCreateArgs<ExtArgs>>): Prisma__UserLibraryChapterClient<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLibraryChapters.
     * @param {UserLibraryChapterCreateManyArgs} args - Arguments to create many UserLibraryChapters.
     * @example
     * // Create many UserLibraryChapters
     * const userLibraryChapter = await prisma.userLibraryChapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLibraryChapterCreateManyArgs>(args?: SelectSubset<T, UserLibraryChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserLibraryChapter.
     * @param {UserLibraryChapterDeleteArgs} args - Arguments to delete one UserLibraryChapter.
     * @example
     * // Delete one UserLibraryChapter
     * const UserLibraryChapter = await prisma.userLibraryChapter.delete({
     *   where: {
     *     // ... filter to delete one UserLibraryChapter
     *   }
     * })
     * 
     */
    delete<T extends UserLibraryChapterDeleteArgs>(args: SelectSubset<T, UserLibraryChapterDeleteArgs<ExtArgs>>): Prisma__UserLibraryChapterClient<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLibraryChapter.
     * @param {UserLibraryChapterUpdateArgs} args - Arguments to update one UserLibraryChapter.
     * @example
     * // Update one UserLibraryChapter
     * const userLibraryChapter = await prisma.userLibraryChapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLibraryChapterUpdateArgs>(args: SelectSubset<T, UserLibraryChapterUpdateArgs<ExtArgs>>): Prisma__UserLibraryChapterClient<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLibraryChapters.
     * @param {UserLibraryChapterDeleteManyArgs} args - Arguments to filter UserLibraryChapters to delete.
     * @example
     * // Delete a few UserLibraryChapters
     * const { count } = await prisma.userLibraryChapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLibraryChapterDeleteManyArgs>(args?: SelectSubset<T, UserLibraryChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLibraryChapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLibraryChapters
     * const userLibraryChapter = await prisma.userLibraryChapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLibraryChapterUpdateManyArgs>(args: SelectSubset<T, UserLibraryChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserLibraryChapter.
     * @param {UserLibraryChapterUpsertArgs} args - Arguments to update or create a UserLibraryChapter.
     * @example
     * // Update or create a UserLibraryChapter
     * const userLibraryChapter = await prisma.userLibraryChapter.upsert({
     *   create: {
     *     // ... data to create a UserLibraryChapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLibraryChapter we want to update
     *   }
     * })
     */
    upsert<T extends UserLibraryChapterUpsertArgs>(args: SelectSubset<T, UserLibraryChapterUpsertArgs<ExtArgs>>): Prisma__UserLibraryChapterClient<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLibraryChapters that matches the filter.
     * @param {UserLibraryChapterFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userLibraryChapter = await prisma.userLibraryChapter.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserLibraryChapterFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserLibraryChapter.
     * @param {UserLibraryChapterAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userLibraryChapter = await prisma.userLibraryChapter.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserLibraryChapterAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserLibraryChapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryChapterCountArgs} args - Arguments to filter UserLibraryChapters to count.
     * @example
     * // Count the number of UserLibraryChapters
     * const count = await prisma.userLibraryChapter.count({
     *   where: {
     *     // ... the filter for the UserLibraryChapters we want to count
     *   }
     * })
    **/
    count<T extends UserLibraryChapterCountArgs>(
      args?: Subset<T, UserLibraryChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLibraryChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLibraryChapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLibraryChapterAggregateArgs>(args: Subset<T, UserLibraryChapterAggregateArgs>): Prisma.PrismaPromise<GetUserLibraryChapterAggregateType<T>>

    /**
     * Group by UserLibraryChapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLibraryChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLibraryChapterGroupByArgs['orderBy'] }
        : { orderBy?: UserLibraryChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLibraryChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLibraryChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLibraryChapter model
   */
  readonly fields: UserLibraryChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLibraryChapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLibraryChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends UserLibraryStoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserLibraryStoryDefaultArgs<ExtArgs>>): Prisma__UserLibraryStoryClient<$Result.GetResult<Prisma.$UserLibraryStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    translation<T extends UserLibraryChapter$translationArgs<ExtArgs> = {}>(args?: Subset<T, UserLibraryChapter$translationArgs<ExtArgs>>): Prisma__UserTranslatedChapterClient<$Result.GetResult<Prisma.$UserTranslatedChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    versions<T extends UserLibraryChapter$versionsArgs<ExtArgs> = {}>(args?: Subset<T, UserLibraryChapter$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTranslationVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLibraryChapter model
   */
  interface UserLibraryChapterFieldRefs {
    readonly id: FieldRef<"UserLibraryChapter", 'String'>
    readonly chapterName: FieldRef<"UserLibraryChapter", 'String'>
    readonly storyId: FieldRef<"UserLibraryChapter", 'String'>
    readonly isHidden: FieldRef<"UserLibraryChapter", 'Boolean'>
    readonly chapterNumber: FieldRef<"UserLibraryChapter", 'Int'>
    readonly rawText: FieldRef<"UserLibraryChapter", 'String'>
    readonly status: FieldRef<"UserLibraryChapter", 'ChapterStatus'>
    readonly createdAt: FieldRef<"UserLibraryChapter", 'DateTime'>
    readonly updatedAt: FieldRef<"UserLibraryChapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLibraryChapter findUnique
   */
  export type UserLibraryChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraryChapter to fetch.
     */
    where: UserLibraryChapterWhereUniqueInput
  }

  /**
   * UserLibraryChapter findUniqueOrThrow
   */
  export type UserLibraryChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraryChapter to fetch.
     */
    where: UserLibraryChapterWhereUniqueInput
  }

  /**
   * UserLibraryChapter findFirst
   */
  export type UserLibraryChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraryChapter to fetch.
     */
    where?: UserLibraryChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraryChapters to fetch.
     */
    orderBy?: UserLibraryChapterOrderByWithRelationInput | UserLibraryChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLibraryChapters.
     */
    cursor?: UserLibraryChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraryChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraryChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLibraryChapters.
     */
    distinct?: UserLibraryChapterScalarFieldEnum | UserLibraryChapterScalarFieldEnum[]
  }

  /**
   * UserLibraryChapter findFirstOrThrow
   */
  export type UserLibraryChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraryChapter to fetch.
     */
    where?: UserLibraryChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraryChapters to fetch.
     */
    orderBy?: UserLibraryChapterOrderByWithRelationInput | UserLibraryChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLibraryChapters.
     */
    cursor?: UserLibraryChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraryChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraryChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLibraryChapters.
     */
    distinct?: UserLibraryChapterScalarFieldEnum | UserLibraryChapterScalarFieldEnum[]
  }

  /**
   * UserLibraryChapter findMany
   */
  export type UserLibraryChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraryChapters to fetch.
     */
    where?: UserLibraryChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraryChapters to fetch.
     */
    orderBy?: UserLibraryChapterOrderByWithRelationInput | UserLibraryChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLibraryChapters.
     */
    cursor?: UserLibraryChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraryChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraryChapters.
     */
    skip?: number
    distinct?: UserLibraryChapterScalarFieldEnum | UserLibraryChapterScalarFieldEnum[]
  }

  /**
   * UserLibraryChapter create
   */
  export type UserLibraryChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLibraryChapter.
     */
    data: XOR<UserLibraryChapterCreateInput, UserLibraryChapterUncheckedCreateInput>
  }

  /**
   * UserLibraryChapter createMany
   */
  export type UserLibraryChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLibraryChapters.
     */
    data: UserLibraryChapterCreateManyInput | UserLibraryChapterCreateManyInput[]
  }

  /**
   * UserLibraryChapter update
   */
  export type UserLibraryChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLibraryChapter.
     */
    data: XOR<UserLibraryChapterUpdateInput, UserLibraryChapterUncheckedUpdateInput>
    /**
     * Choose, which UserLibraryChapter to update.
     */
    where: UserLibraryChapterWhereUniqueInput
  }

  /**
   * UserLibraryChapter updateMany
   */
  export type UserLibraryChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLibraryChapters.
     */
    data: XOR<UserLibraryChapterUpdateManyMutationInput, UserLibraryChapterUncheckedUpdateManyInput>
    /**
     * Filter which UserLibraryChapters to update
     */
    where?: UserLibraryChapterWhereInput
    /**
     * Limit how many UserLibraryChapters to update.
     */
    limit?: number
  }

  /**
   * UserLibraryChapter upsert
   */
  export type UserLibraryChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLibraryChapter to update in case it exists.
     */
    where: UserLibraryChapterWhereUniqueInput
    /**
     * In case the UserLibraryChapter found by the `where` argument doesn't exist, create a new UserLibraryChapter with this data.
     */
    create: XOR<UserLibraryChapterCreateInput, UserLibraryChapterUncheckedCreateInput>
    /**
     * In case the UserLibraryChapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLibraryChapterUpdateInput, UserLibraryChapterUncheckedUpdateInput>
  }

  /**
   * UserLibraryChapter delete
   */
  export type UserLibraryChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
    /**
     * Filter which UserLibraryChapter to delete.
     */
    where: UserLibraryChapterWhereUniqueInput
  }

  /**
   * UserLibraryChapter deleteMany
   */
  export type UserLibraryChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLibraryChapters to delete
     */
    where?: UserLibraryChapterWhereInput
    /**
     * Limit how many UserLibraryChapters to delete.
     */
    limit?: number
  }

  /**
   * UserLibraryChapter findRaw
   */
  export type UserLibraryChapterFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserLibraryChapter aggregateRaw
   */
  export type UserLibraryChapterAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserLibraryChapter.translation
   */
  export type UserLibraryChapter$translationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
    where?: UserTranslatedChapterWhereInput
  }

  /**
   * UserLibraryChapter.versions
   */
  export type UserLibraryChapter$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
    where?: UserTranslationVersionWhereInput
    orderBy?: UserTranslationVersionOrderByWithRelationInput | UserTranslationVersionOrderByWithRelationInput[]
    cursor?: UserTranslationVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTranslationVersionScalarFieldEnum | UserTranslationVersionScalarFieldEnum[]
  }

  /**
   * UserLibraryChapter without action
   */
  export type UserLibraryChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibraryChapter
     */
    select?: UserLibraryChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibraryChapter
     */
    omit?: UserLibraryChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryChapterInclude<ExtArgs> | null
  }


  /**
   * Model UserTranslatedChapter
   */

  export type AggregateUserTranslatedChapter = {
    _count: UserTranslatedChapterCountAggregateOutputType | null
    _min: UserTranslatedChapterMinAggregateOutputType | null
    _max: UserTranslatedChapterMaxAggregateOutputType | null
  }

  export type UserTranslatedChapterMinAggregateOutputType = {
    id: string | null
    chapterId: string | null
    translatedTitle: string | null
    translatedContent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTranslatedChapterMaxAggregateOutputType = {
    id: string | null
    chapterId: string | null
    translatedTitle: string | null
    translatedContent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTranslatedChapterCountAggregateOutputType = {
    id: number
    chapterId: number
    translatedTitle: number
    translatedContent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTranslatedChapterMinAggregateInputType = {
    id?: true
    chapterId?: true
    translatedTitle?: true
    translatedContent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTranslatedChapterMaxAggregateInputType = {
    id?: true
    chapterId?: true
    translatedTitle?: true
    translatedContent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTranslatedChapterCountAggregateInputType = {
    id?: true
    chapterId?: true
    translatedTitle?: true
    translatedContent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTranslatedChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTranslatedChapter to aggregate.
     */
    where?: UserTranslatedChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTranslatedChapters to fetch.
     */
    orderBy?: UserTranslatedChapterOrderByWithRelationInput | UserTranslatedChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTranslatedChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTranslatedChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTranslatedChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTranslatedChapters
    **/
    _count?: true | UserTranslatedChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTranslatedChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTranslatedChapterMaxAggregateInputType
  }

  export type GetUserTranslatedChapterAggregateType<T extends UserTranslatedChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTranslatedChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTranslatedChapter[P]>
      : GetScalarType<T[P], AggregateUserTranslatedChapter[P]>
  }




  export type UserTranslatedChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTranslatedChapterWhereInput
    orderBy?: UserTranslatedChapterOrderByWithAggregationInput | UserTranslatedChapterOrderByWithAggregationInput[]
    by: UserTranslatedChapterScalarFieldEnum[] | UserTranslatedChapterScalarFieldEnum
    having?: UserTranslatedChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTranslatedChapterCountAggregateInputType | true
    _min?: UserTranslatedChapterMinAggregateInputType
    _max?: UserTranslatedChapterMaxAggregateInputType
  }

  export type UserTranslatedChapterGroupByOutputType = {
    id: string
    chapterId: string
    translatedTitle: string
    translatedContent: string
    createdAt: Date
    updatedAt: Date
    _count: UserTranslatedChapterCountAggregateOutputType | null
    _min: UserTranslatedChapterMinAggregateOutputType | null
    _max: UserTranslatedChapterMaxAggregateOutputType | null
  }

  type GetUserTranslatedChapterGroupByPayload<T extends UserTranslatedChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTranslatedChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTranslatedChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTranslatedChapterGroupByOutputType[P]>
            : GetScalarType<T[P], UserTranslatedChapterGroupByOutputType[P]>
        }
      >
    >


  export type UserTranslatedChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    translatedTitle?: boolean
    translatedContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chapter?: boolean | UserLibraryChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTranslatedChapter"]>



  export type UserTranslatedChapterSelectScalar = {
    id?: boolean
    chapterId?: boolean
    translatedTitle?: boolean
    translatedContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserTranslatedChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chapterId" | "translatedTitle" | "translatedContent" | "createdAt" | "updatedAt", ExtArgs["result"]["userTranslatedChapter"]>
  export type UserTranslatedChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | UserLibraryChapterDefaultArgs<ExtArgs>
  }

  export type $UserTranslatedChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTranslatedChapter"
    objects: {
      chapter: Prisma.$UserLibraryChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chapterId: string
      translatedTitle: string
      translatedContent: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userTranslatedChapter"]>
    composites: {}
  }

  type UserTranslatedChapterGetPayload<S extends boolean | null | undefined | UserTranslatedChapterDefaultArgs> = $Result.GetResult<Prisma.$UserTranslatedChapterPayload, S>

  type UserTranslatedChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTranslatedChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTranslatedChapterCountAggregateInputType | true
    }

  export interface UserTranslatedChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTranslatedChapter'], meta: { name: 'UserTranslatedChapter' } }
    /**
     * Find zero or one UserTranslatedChapter that matches the filter.
     * @param {UserTranslatedChapterFindUniqueArgs} args - Arguments to find a UserTranslatedChapter
     * @example
     * // Get one UserTranslatedChapter
     * const userTranslatedChapter = await prisma.userTranslatedChapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTranslatedChapterFindUniqueArgs>(args: SelectSubset<T, UserTranslatedChapterFindUniqueArgs<ExtArgs>>): Prisma__UserTranslatedChapterClient<$Result.GetResult<Prisma.$UserTranslatedChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTranslatedChapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTranslatedChapterFindUniqueOrThrowArgs} args - Arguments to find a UserTranslatedChapter
     * @example
     * // Get one UserTranslatedChapter
     * const userTranslatedChapter = await prisma.userTranslatedChapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTranslatedChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTranslatedChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTranslatedChapterClient<$Result.GetResult<Prisma.$UserTranslatedChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTranslatedChapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslatedChapterFindFirstArgs} args - Arguments to find a UserTranslatedChapter
     * @example
     * // Get one UserTranslatedChapter
     * const userTranslatedChapter = await prisma.userTranslatedChapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTranslatedChapterFindFirstArgs>(args?: SelectSubset<T, UserTranslatedChapterFindFirstArgs<ExtArgs>>): Prisma__UserTranslatedChapterClient<$Result.GetResult<Prisma.$UserTranslatedChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTranslatedChapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslatedChapterFindFirstOrThrowArgs} args - Arguments to find a UserTranslatedChapter
     * @example
     * // Get one UserTranslatedChapter
     * const userTranslatedChapter = await prisma.userTranslatedChapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTranslatedChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTranslatedChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTranslatedChapterClient<$Result.GetResult<Prisma.$UserTranslatedChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTranslatedChapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslatedChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTranslatedChapters
     * const userTranslatedChapters = await prisma.userTranslatedChapter.findMany()
     * 
     * // Get first 10 UserTranslatedChapters
     * const userTranslatedChapters = await prisma.userTranslatedChapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTranslatedChapterWithIdOnly = await prisma.userTranslatedChapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTranslatedChapterFindManyArgs>(args?: SelectSubset<T, UserTranslatedChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTranslatedChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTranslatedChapter.
     * @param {UserTranslatedChapterCreateArgs} args - Arguments to create a UserTranslatedChapter.
     * @example
     * // Create one UserTranslatedChapter
     * const UserTranslatedChapter = await prisma.userTranslatedChapter.create({
     *   data: {
     *     // ... data to create a UserTranslatedChapter
     *   }
     * })
     * 
     */
    create<T extends UserTranslatedChapterCreateArgs>(args: SelectSubset<T, UserTranslatedChapterCreateArgs<ExtArgs>>): Prisma__UserTranslatedChapterClient<$Result.GetResult<Prisma.$UserTranslatedChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTranslatedChapters.
     * @param {UserTranslatedChapterCreateManyArgs} args - Arguments to create many UserTranslatedChapters.
     * @example
     * // Create many UserTranslatedChapters
     * const userTranslatedChapter = await prisma.userTranslatedChapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTranslatedChapterCreateManyArgs>(args?: SelectSubset<T, UserTranslatedChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserTranslatedChapter.
     * @param {UserTranslatedChapterDeleteArgs} args - Arguments to delete one UserTranslatedChapter.
     * @example
     * // Delete one UserTranslatedChapter
     * const UserTranslatedChapter = await prisma.userTranslatedChapter.delete({
     *   where: {
     *     // ... filter to delete one UserTranslatedChapter
     *   }
     * })
     * 
     */
    delete<T extends UserTranslatedChapterDeleteArgs>(args: SelectSubset<T, UserTranslatedChapterDeleteArgs<ExtArgs>>): Prisma__UserTranslatedChapterClient<$Result.GetResult<Prisma.$UserTranslatedChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTranslatedChapter.
     * @param {UserTranslatedChapterUpdateArgs} args - Arguments to update one UserTranslatedChapter.
     * @example
     * // Update one UserTranslatedChapter
     * const userTranslatedChapter = await prisma.userTranslatedChapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTranslatedChapterUpdateArgs>(args: SelectSubset<T, UserTranslatedChapterUpdateArgs<ExtArgs>>): Prisma__UserTranslatedChapterClient<$Result.GetResult<Prisma.$UserTranslatedChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTranslatedChapters.
     * @param {UserTranslatedChapterDeleteManyArgs} args - Arguments to filter UserTranslatedChapters to delete.
     * @example
     * // Delete a few UserTranslatedChapters
     * const { count } = await prisma.userTranslatedChapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTranslatedChapterDeleteManyArgs>(args?: SelectSubset<T, UserTranslatedChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTranslatedChapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslatedChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTranslatedChapters
     * const userTranslatedChapter = await prisma.userTranslatedChapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTranslatedChapterUpdateManyArgs>(args: SelectSubset<T, UserTranslatedChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTranslatedChapter.
     * @param {UserTranslatedChapterUpsertArgs} args - Arguments to update or create a UserTranslatedChapter.
     * @example
     * // Update or create a UserTranslatedChapter
     * const userTranslatedChapter = await prisma.userTranslatedChapter.upsert({
     *   create: {
     *     // ... data to create a UserTranslatedChapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTranslatedChapter we want to update
     *   }
     * })
     */
    upsert<T extends UserTranslatedChapterUpsertArgs>(args: SelectSubset<T, UserTranslatedChapterUpsertArgs<ExtArgs>>): Prisma__UserTranslatedChapterClient<$Result.GetResult<Prisma.$UserTranslatedChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTranslatedChapters that matches the filter.
     * @param {UserTranslatedChapterFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userTranslatedChapter = await prisma.userTranslatedChapter.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserTranslatedChapterFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserTranslatedChapter.
     * @param {UserTranslatedChapterAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userTranslatedChapter = await prisma.userTranslatedChapter.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserTranslatedChapterAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserTranslatedChapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslatedChapterCountArgs} args - Arguments to filter UserTranslatedChapters to count.
     * @example
     * // Count the number of UserTranslatedChapters
     * const count = await prisma.userTranslatedChapter.count({
     *   where: {
     *     // ... the filter for the UserTranslatedChapters we want to count
     *   }
     * })
    **/
    count<T extends UserTranslatedChapterCountArgs>(
      args?: Subset<T, UserTranslatedChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTranslatedChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTranslatedChapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslatedChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTranslatedChapterAggregateArgs>(args: Subset<T, UserTranslatedChapterAggregateArgs>): Prisma.PrismaPromise<GetUserTranslatedChapterAggregateType<T>>

    /**
     * Group by UserTranslatedChapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslatedChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTranslatedChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTranslatedChapterGroupByArgs['orderBy'] }
        : { orderBy?: UserTranslatedChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTranslatedChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTranslatedChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTranslatedChapter model
   */
  readonly fields: UserTranslatedChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTranslatedChapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTranslatedChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends UserLibraryChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserLibraryChapterDefaultArgs<ExtArgs>>): Prisma__UserLibraryChapterClient<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTranslatedChapter model
   */
  interface UserTranslatedChapterFieldRefs {
    readonly id: FieldRef<"UserTranslatedChapter", 'String'>
    readonly chapterId: FieldRef<"UserTranslatedChapter", 'String'>
    readonly translatedTitle: FieldRef<"UserTranslatedChapter", 'String'>
    readonly translatedContent: FieldRef<"UserTranslatedChapter", 'String'>
    readonly createdAt: FieldRef<"UserTranslatedChapter", 'DateTime'>
    readonly updatedAt: FieldRef<"UserTranslatedChapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTranslatedChapter findUnique
   */
  export type UserTranslatedChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
    /**
     * Filter, which UserTranslatedChapter to fetch.
     */
    where: UserTranslatedChapterWhereUniqueInput
  }

  /**
   * UserTranslatedChapter findUniqueOrThrow
   */
  export type UserTranslatedChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
    /**
     * Filter, which UserTranslatedChapter to fetch.
     */
    where: UserTranslatedChapterWhereUniqueInput
  }

  /**
   * UserTranslatedChapter findFirst
   */
  export type UserTranslatedChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
    /**
     * Filter, which UserTranslatedChapter to fetch.
     */
    where?: UserTranslatedChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTranslatedChapters to fetch.
     */
    orderBy?: UserTranslatedChapterOrderByWithRelationInput | UserTranslatedChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTranslatedChapters.
     */
    cursor?: UserTranslatedChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTranslatedChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTranslatedChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTranslatedChapters.
     */
    distinct?: UserTranslatedChapterScalarFieldEnum | UserTranslatedChapterScalarFieldEnum[]
  }

  /**
   * UserTranslatedChapter findFirstOrThrow
   */
  export type UserTranslatedChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
    /**
     * Filter, which UserTranslatedChapter to fetch.
     */
    where?: UserTranslatedChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTranslatedChapters to fetch.
     */
    orderBy?: UserTranslatedChapterOrderByWithRelationInput | UserTranslatedChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTranslatedChapters.
     */
    cursor?: UserTranslatedChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTranslatedChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTranslatedChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTranslatedChapters.
     */
    distinct?: UserTranslatedChapterScalarFieldEnum | UserTranslatedChapterScalarFieldEnum[]
  }

  /**
   * UserTranslatedChapter findMany
   */
  export type UserTranslatedChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
    /**
     * Filter, which UserTranslatedChapters to fetch.
     */
    where?: UserTranslatedChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTranslatedChapters to fetch.
     */
    orderBy?: UserTranslatedChapterOrderByWithRelationInput | UserTranslatedChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTranslatedChapters.
     */
    cursor?: UserTranslatedChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTranslatedChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTranslatedChapters.
     */
    skip?: number
    distinct?: UserTranslatedChapterScalarFieldEnum | UserTranslatedChapterScalarFieldEnum[]
  }

  /**
   * UserTranslatedChapter create
   */
  export type UserTranslatedChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTranslatedChapter.
     */
    data: XOR<UserTranslatedChapterCreateInput, UserTranslatedChapterUncheckedCreateInput>
  }

  /**
   * UserTranslatedChapter createMany
   */
  export type UserTranslatedChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTranslatedChapters.
     */
    data: UserTranslatedChapterCreateManyInput | UserTranslatedChapterCreateManyInput[]
  }

  /**
   * UserTranslatedChapter update
   */
  export type UserTranslatedChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTranslatedChapter.
     */
    data: XOR<UserTranslatedChapterUpdateInput, UserTranslatedChapterUncheckedUpdateInput>
    /**
     * Choose, which UserTranslatedChapter to update.
     */
    where: UserTranslatedChapterWhereUniqueInput
  }

  /**
   * UserTranslatedChapter updateMany
   */
  export type UserTranslatedChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTranslatedChapters.
     */
    data: XOR<UserTranslatedChapterUpdateManyMutationInput, UserTranslatedChapterUncheckedUpdateManyInput>
    /**
     * Filter which UserTranslatedChapters to update
     */
    where?: UserTranslatedChapterWhereInput
    /**
     * Limit how many UserTranslatedChapters to update.
     */
    limit?: number
  }

  /**
   * UserTranslatedChapter upsert
   */
  export type UserTranslatedChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTranslatedChapter to update in case it exists.
     */
    where: UserTranslatedChapterWhereUniqueInput
    /**
     * In case the UserTranslatedChapter found by the `where` argument doesn't exist, create a new UserTranslatedChapter with this data.
     */
    create: XOR<UserTranslatedChapterCreateInput, UserTranslatedChapterUncheckedCreateInput>
    /**
     * In case the UserTranslatedChapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTranslatedChapterUpdateInput, UserTranslatedChapterUncheckedUpdateInput>
  }

  /**
   * UserTranslatedChapter delete
   */
  export type UserTranslatedChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
    /**
     * Filter which UserTranslatedChapter to delete.
     */
    where: UserTranslatedChapterWhereUniqueInput
  }

  /**
   * UserTranslatedChapter deleteMany
   */
  export type UserTranslatedChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTranslatedChapters to delete
     */
    where?: UserTranslatedChapterWhereInput
    /**
     * Limit how many UserTranslatedChapters to delete.
     */
    limit?: number
  }

  /**
   * UserTranslatedChapter findRaw
   */
  export type UserTranslatedChapterFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserTranslatedChapter aggregateRaw
   */
  export type UserTranslatedChapterAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserTranslatedChapter without action
   */
  export type UserTranslatedChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslatedChapter
     */
    select?: UserTranslatedChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslatedChapter
     */
    omit?: UserTranslatedChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslatedChapterInclude<ExtArgs> | null
  }


  /**
   * Model UserTranslationVersion
   */

  export type AggregateUserTranslationVersion = {
    _count: UserTranslationVersionCountAggregateOutputType | null
    _min: UserTranslationVersionMinAggregateOutputType | null
    _max: UserTranslationVersionMaxAggregateOutputType | null
  }

  export type UserTranslationVersionMinAggregateOutputType = {
    id: string | null
    translatedText: string | null
    chapterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTranslationVersionMaxAggregateOutputType = {
    id: string | null
    translatedText: string | null
    chapterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTranslationVersionCountAggregateOutputType = {
    id: number
    translatedText: number
    chapterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTranslationVersionMinAggregateInputType = {
    id?: true
    translatedText?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTranslationVersionMaxAggregateInputType = {
    id?: true
    translatedText?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTranslationVersionCountAggregateInputType = {
    id?: true
    translatedText?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTranslationVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTranslationVersion to aggregate.
     */
    where?: UserTranslationVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTranslationVersions to fetch.
     */
    orderBy?: UserTranslationVersionOrderByWithRelationInput | UserTranslationVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTranslationVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTranslationVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTranslationVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTranslationVersions
    **/
    _count?: true | UserTranslationVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTranslationVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTranslationVersionMaxAggregateInputType
  }

  export type GetUserTranslationVersionAggregateType<T extends UserTranslationVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTranslationVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTranslationVersion[P]>
      : GetScalarType<T[P], AggregateUserTranslationVersion[P]>
  }




  export type UserTranslationVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTranslationVersionWhereInput
    orderBy?: UserTranslationVersionOrderByWithAggregationInput | UserTranslationVersionOrderByWithAggregationInput[]
    by: UserTranslationVersionScalarFieldEnum[] | UserTranslationVersionScalarFieldEnum
    having?: UserTranslationVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTranslationVersionCountAggregateInputType | true
    _min?: UserTranslationVersionMinAggregateInputType
    _max?: UserTranslationVersionMaxAggregateInputType
  }

  export type UserTranslationVersionGroupByOutputType = {
    id: string
    translatedText: string
    chapterId: string
    createdAt: Date
    updatedAt: Date
    _count: UserTranslationVersionCountAggregateOutputType | null
    _min: UserTranslationVersionMinAggregateOutputType | null
    _max: UserTranslationVersionMaxAggregateOutputType | null
  }

  type GetUserTranslationVersionGroupByPayload<T extends UserTranslationVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTranslationVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTranslationVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTranslationVersionGroupByOutputType[P]>
            : GetScalarType<T[P], UserTranslationVersionGroupByOutputType[P]>
        }
      >
    >


  export type UserTranslationVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    translatedText?: boolean
    chapterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chapter?: boolean | UserLibraryChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTranslationVersion"]>



  export type UserTranslationVersionSelectScalar = {
    id?: boolean
    translatedText?: boolean
    chapterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserTranslationVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "translatedText" | "chapterId" | "createdAt" | "updatedAt", ExtArgs["result"]["userTranslationVersion"]>
  export type UserTranslationVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | UserLibraryChapterDefaultArgs<ExtArgs>
  }

  export type $UserTranslationVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTranslationVersion"
    objects: {
      chapter: Prisma.$UserLibraryChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      translatedText: string
      chapterId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userTranslationVersion"]>
    composites: {}
  }

  type UserTranslationVersionGetPayload<S extends boolean | null | undefined | UserTranslationVersionDefaultArgs> = $Result.GetResult<Prisma.$UserTranslationVersionPayload, S>

  type UserTranslationVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTranslationVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTranslationVersionCountAggregateInputType | true
    }

  export interface UserTranslationVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTranslationVersion'], meta: { name: 'UserTranslationVersion' } }
    /**
     * Find zero or one UserTranslationVersion that matches the filter.
     * @param {UserTranslationVersionFindUniqueArgs} args - Arguments to find a UserTranslationVersion
     * @example
     * // Get one UserTranslationVersion
     * const userTranslationVersion = await prisma.userTranslationVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTranslationVersionFindUniqueArgs>(args: SelectSubset<T, UserTranslationVersionFindUniqueArgs<ExtArgs>>): Prisma__UserTranslationVersionClient<$Result.GetResult<Prisma.$UserTranslationVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTranslationVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTranslationVersionFindUniqueOrThrowArgs} args - Arguments to find a UserTranslationVersion
     * @example
     * // Get one UserTranslationVersion
     * const userTranslationVersion = await prisma.userTranslationVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTranslationVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTranslationVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTranslationVersionClient<$Result.GetResult<Prisma.$UserTranslationVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTranslationVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslationVersionFindFirstArgs} args - Arguments to find a UserTranslationVersion
     * @example
     * // Get one UserTranslationVersion
     * const userTranslationVersion = await prisma.userTranslationVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTranslationVersionFindFirstArgs>(args?: SelectSubset<T, UserTranslationVersionFindFirstArgs<ExtArgs>>): Prisma__UserTranslationVersionClient<$Result.GetResult<Prisma.$UserTranslationVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTranslationVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslationVersionFindFirstOrThrowArgs} args - Arguments to find a UserTranslationVersion
     * @example
     * // Get one UserTranslationVersion
     * const userTranslationVersion = await prisma.userTranslationVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTranslationVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTranslationVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTranslationVersionClient<$Result.GetResult<Prisma.$UserTranslationVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTranslationVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslationVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTranslationVersions
     * const userTranslationVersions = await prisma.userTranslationVersion.findMany()
     * 
     * // Get first 10 UserTranslationVersions
     * const userTranslationVersions = await prisma.userTranslationVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTranslationVersionWithIdOnly = await prisma.userTranslationVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTranslationVersionFindManyArgs>(args?: SelectSubset<T, UserTranslationVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTranslationVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTranslationVersion.
     * @param {UserTranslationVersionCreateArgs} args - Arguments to create a UserTranslationVersion.
     * @example
     * // Create one UserTranslationVersion
     * const UserTranslationVersion = await prisma.userTranslationVersion.create({
     *   data: {
     *     // ... data to create a UserTranslationVersion
     *   }
     * })
     * 
     */
    create<T extends UserTranslationVersionCreateArgs>(args: SelectSubset<T, UserTranslationVersionCreateArgs<ExtArgs>>): Prisma__UserTranslationVersionClient<$Result.GetResult<Prisma.$UserTranslationVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTranslationVersions.
     * @param {UserTranslationVersionCreateManyArgs} args - Arguments to create many UserTranslationVersions.
     * @example
     * // Create many UserTranslationVersions
     * const userTranslationVersion = await prisma.userTranslationVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTranslationVersionCreateManyArgs>(args?: SelectSubset<T, UserTranslationVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserTranslationVersion.
     * @param {UserTranslationVersionDeleteArgs} args - Arguments to delete one UserTranslationVersion.
     * @example
     * // Delete one UserTranslationVersion
     * const UserTranslationVersion = await prisma.userTranslationVersion.delete({
     *   where: {
     *     // ... filter to delete one UserTranslationVersion
     *   }
     * })
     * 
     */
    delete<T extends UserTranslationVersionDeleteArgs>(args: SelectSubset<T, UserTranslationVersionDeleteArgs<ExtArgs>>): Prisma__UserTranslationVersionClient<$Result.GetResult<Prisma.$UserTranslationVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTranslationVersion.
     * @param {UserTranslationVersionUpdateArgs} args - Arguments to update one UserTranslationVersion.
     * @example
     * // Update one UserTranslationVersion
     * const userTranslationVersion = await prisma.userTranslationVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTranslationVersionUpdateArgs>(args: SelectSubset<T, UserTranslationVersionUpdateArgs<ExtArgs>>): Prisma__UserTranslationVersionClient<$Result.GetResult<Prisma.$UserTranslationVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTranslationVersions.
     * @param {UserTranslationVersionDeleteManyArgs} args - Arguments to filter UserTranslationVersions to delete.
     * @example
     * // Delete a few UserTranslationVersions
     * const { count } = await prisma.userTranslationVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTranslationVersionDeleteManyArgs>(args?: SelectSubset<T, UserTranslationVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTranslationVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslationVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTranslationVersions
     * const userTranslationVersion = await prisma.userTranslationVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTranslationVersionUpdateManyArgs>(args: SelectSubset<T, UserTranslationVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTranslationVersion.
     * @param {UserTranslationVersionUpsertArgs} args - Arguments to update or create a UserTranslationVersion.
     * @example
     * // Update or create a UserTranslationVersion
     * const userTranslationVersion = await prisma.userTranslationVersion.upsert({
     *   create: {
     *     // ... data to create a UserTranslationVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTranslationVersion we want to update
     *   }
     * })
     */
    upsert<T extends UserTranslationVersionUpsertArgs>(args: SelectSubset<T, UserTranslationVersionUpsertArgs<ExtArgs>>): Prisma__UserTranslationVersionClient<$Result.GetResult<Prisma.$UserTranslationVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTranslationVersions that matches the filter.
     * @param {UserTranslationVersionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userTranslationVersion = await prisma.userTranslationVersion.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserTranslationVersionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserTranslationVersion.
     * @param {UserTranslationVersionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userTranslationVersion = await prisma.userTranslationVersion.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserTranslationVersionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserTranslationVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslationVersionCountArgs} args - Arguments to filter UserTranslationVersions to count.
     * @example
     * // Count the number of UserTranslationVersions
     * const count = await prisma.userTranslationVersion.count({
     *   where: {
     *     // ... the filter for the UserTranslationVersions we want to count
     *   }
     * })
    **/
    count<T extends UserTranslationVersionCountArgs>(
      args?: Subset<T, UserTranslationVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTranslationVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTranslationVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslationVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTranslationVersionAggregateArgs>(args: Subset<T, UserTranslationVersionAggregateArgs>): Prisma.PrismaPromise<GetUserTranslationVersionAggregateType<T>>

    /**
     * Group by UserTranslationVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTranslationVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTranslationVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTranslationVersionGroupByArgs['orderBy'] }
        : { orderBy?: UserTranslationVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTranslationVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTranslationVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTranslationVersion model
   */
  readonly fields: UserTranslationVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTranslationVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTranslationVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends UserLibraryChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserLibraryChapterDefaultArgs<ExtArgs>>): Prisma__UserLibraryChapterClient<$Result.GetResult<Prisma.$UserLibraryChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTranslationVersion model
   */
  interface UserTranslationVersionFieldRefs {
    readonly id: FieldRef<"UserTranslationVersion", 'String'>
    readonly translatedText: FieldRef<"UserTranslationVersion", 'String'>
    readonly chapterId: FieldRef<"UserTranslationVersion", 'String'>
    readonly createdAt: FieldRef<"UserTranslationVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"UserTranslationVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTranslationVersion findUnique
   */
  export type UserTranslationVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
    /**
     * Filter, which UserTranslationVersion to fetch.
     */
    where: UserTranslationVersionWhereUniqueInput
  }

  /**
   * UserTranslationVersion findUniqueOrThrow
   */
  export type UserTranslationVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
    /**
     * Filter, which UserTranslationVersion to fetch.
     */
    where: UserTranslationVersionWhereUniqueInput
  }

  /**
   * UserTranslationVersion findFirst
   */
  export type UserTranslationVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
    /**
     * Filter, which UserTranslationVersion to fetch.
     */
    where?: UserTranslationVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTranslationVersions to fetch.
     */
    orderBy?: UserTranslationVersionOrderByWithRelationInput | UserTranslationVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTranslationVersions.
     */
    cursor?: UserTranslationVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTranslationVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTranslationVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTranslationVersions.
     */
    distinct?: UserTranslationVersionScalarFieldEnum | UserTranslationVersionScalarFieldEnum[]
  }

  /**
   * UserTranslationVersion findFirstOrThrow
   */
  export type UserTranslationVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
    /**
     * Filter, which UserTranslationVersion to fetch.
     */
    where?: UserTranslationVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTranslationVersions to fetch.
     */
    orderBy?: UserTranslationVersionOrderByWithRelationInput | UserTranslationVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTranslationVersions.
     */
    cursor?: UserTranslationVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTranslationVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTranslationVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTranslationVersions.
     */
    distinct?: UserTranslationVersionScalarFieldEnum | UserTranslationVersionScalarFieldEnum[]
  }

  /**
   * UserTranslationVersion findMany
   */
  export type UserTranslationVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
    /**
     * Filter, which UserTranslationVersions to fetch.
     */
    where?: UserTranslationVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTranslationVersions to fetch.
     */
    orderBy?: UserTranslationVersionOrderByWithRelationInput | UserTranslationVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTranslationVersions.
     */
    cursor?: UserTranslationVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTranslationVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTranslationVersions.
     */
    skip?: number
    distinct?: UserTranslationVersionScalarFieldEnum | UserTranslationVersionScalarFieldEnum[]
  }

  /**
   * UserTranslationVersion create
   */
  export type UserTranslationVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTranslationVersion.
     */
    data: XOR<UserTranslationVersionCreateInput, UserTranslationVersionUncheckedCreateInput>
  }

  /**
   * UserTranslationVersion createMany
   */
  export type UserTranslationVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTranslationVersions.
     */
    data: UserTranslationVersionCreateManyInput | UserTranslationVersionCreateManyInput[]
  }

  /**
   * UserTranslationVersion update
   */
  export type UserTranslationVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTranslationVersion.
     */
    data: XOR<UserTranslationVersionUpdateInput, UserTranslationVersionUncheckedUpdateInput>
    /**
     * Choose, which UserTranslationVersion to update.
     */
    where: UserTranslationVersionWhereUniqueInput
  }

  /**
   * UserTranslationVersion updateMany
   */
  export type UserTranslationVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTranslationVersions.
     */
    data: XOR<UserTranslationVersionUpdateManyMutationInput, UserTranslationVersionUncheckedUpdateManyInput>
    /**
     * Filter which UserTranslationVersions to update
     */
    where?: UserTranslationVersionWhereInput
    /**
     * Limit how many UserTranslationVersions to update.
     */
    limit?: number
  }

  /**
   * UserTranslationVersion upsert
   */
  export type UserTranslationVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTranslationVersion to update in case it exists.
     */
    where: UserTranslationVersionWhereUniqueInput
    /**
     * In case the UserTranslationVersion found by the `where` argument doesn't exist, create a new UserTranslationVersion with this data.
     */
    create: XOR<UserTranslationVersionCreateInput, UserTranslationVersionUncheckedCreateInput>
    /**
     * In case the UserTranslationVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTranslationVersionUpdateInput, UserTranslationVersionUncheckedUpdateInput>
  }

  /**
   * UserTranslationVersion delete
   */
  export type UserTranslationVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
    /**
     * Filter which UserTranslationVersion to delete.
     */
    where: UserTranslationVersionWhereUniqueInput
  }

  /**
   * UserTranslationVersion deleteMany
   */
  export type UserTranslationVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTranslationVersions to delete
     */
    where?: UserTranslationVersionWhereInput
    /**
     * Limit how many UserTranslationVersions to delete.
     */
    limit?: number
  }

  /**
   * UserTranslationVersion findRaw
   */
  export type UserTranslationVersionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserTranslationVersion aggregateRaw
   */
  export type UserTranslationVersionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserTranslationVersion without action
   */
  export type UserTranslationVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTranslationVersion
     */
    select?: UserTranslationVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTranslationVersion
     */
    omit?: UserTranslationVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTranslationVersionInclude<ExtArgs> | null
  }


  /**
   * Model UserApiKey
   */

  export type AggregateUserApiKey = {
    _count: UserApiKeyCountAggregateOutputType | null
    _avg: UserApiKeyAvgAggregateOutputType | null
    _sum: UserApiKeySumAggregateOutputType | null
    _min: UserApiKeyMinAggregateOutputType | null
    _max: UserApiKeyMaxAggregateOutputType | null
  }

  export type UserApiKeyAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type UserApiKeySumAggregateOutputType = {
    usageCount: number | null
  }

  export type UserApiKeyMinAggregateOutputType = {
    id: string | null
    key: string | null
    userId: string | null
    label: string | null
    status: $Enums.ApiKeyStatus | null
    usageCount: number | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserApiKeyMaxAggregateOutputType = {
    id: string | null
    key: string | null
    userId: string | null
    label: string | null
    status: $Enums.ApiKeyStatus | null
    usageCount: number | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserApiKeyCountAggregateOutputType = {
    id: number
    key: number
    userId: number
    label: number
    status: number
    usageCount: number
    lastUsedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserApiKeyAvgAggregateInputType = {
    usageCount?: true
  }

  export type UserApiKeySumAggregateInputType = {
    usageCount?: true
  }

  export type UserApiKeyMinAggregateInputType = {
    id?: true
    key?: true
    userId?: true
    label?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserApiKeyMaxAggregateInputType = {
    id?: true
    key?: true
    userId?: true
    label?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserApiKeyCountAggregateInputType = {
    id?: true
    key?: true
    userId?: true
    label?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserApiKey to aggregate.
     */
    where?: UserApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApiKeys to fetch.
     */
    orderBy?: UserApiKeyOrderByWithRelationInput | UserApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserApiKeys
    **/
    _count?: true | UserApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserApiKeyMaxAggregateInputType
  }

  export type GetUserApiKeyAggregateType<T extends UserApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateUserApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserApiKey[P]>
      : GetScalarType<T[P], AggregateUserApiKey[P]>
  }




  export type UserApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApiKeyWhereInput
    orderBy?: UserApiKeyOrderByWithAggregationInput | UserApiKeyOrderByWithAggregationInput[]
    by: UserApiKeyScalarFieldEnum[] | UserApiKeyScalarFieldEnum
    having?: UserApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserApiKeyCountAggregateInputType | true
    _avg?: UserApiKeyAvgAggregateInputType
    _sum?: UserApiKeySumAggregateInputType
    _min?: UserApiKeyMinAggregateInputType
    _max?: UserApiKeyMaxAggregateInputType
  }

  export type UserApiKeyGroupByOutputType = {
    id: string
    key: string
    userId: string
    label: string | null
    status: $Enums.ApiKeyStatus
    usageCount: number
    lastUsedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserApiKeyCountAggregateOutputType | null
    _avg: UserApiKeyAvgAggregateOutputType | null
    _sum: UserApiKeySumAggregateOutputType | null
    _min: UserApiKeyMinAggregateOutputType | null
    _max: UserApiKeyMaxAggregateOutputType | null
  }

  type GetUserApiKeyGroupByPayload<T extends UserApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], UserApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type UserApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    userId?: boolean
    label?: boolean
    status?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    models?: boolean | UserApiKey$modelsArgs<ExtArgs>
    _count?: boolean | UserApiKeyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userApiKey"]>



  export type UserApiKeySelectScalar = {
    id?: boolean
    key?: boolean
    userId?: boolean
    label?: boolean
    status?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "userId" | "label" | "status" | "usageCount" | "lastUsedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userApiKey"]>
  export type UserApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    models?: boolean | UserApiKey$modelsArgs<ExtArgs>
    _count?: boolean | UserApiKeyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      models: Prisma.$UserApiKeyToModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      userId: string
      label: string | null
      status: $Enums.ApiKeyStatus
      usageCount: number
      lastUsedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userApiKey"]>
    composites: {}
  }

  type UserApiKeyGetPayload<S extends boolean | null | undefined | UserApiKeyDefaultArgs> = $Result.GetResult<Prisma.$UserApiKeyPayload, S>

  type UserApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserApiKeyCountAggregateInputType | true
    }

  export interface UserApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserApiKey'], meta: { name: 'UserApiKey' } }
    /**
     * Find zero or one UserApiKey that matches the filter.
     * @param {UserApiKeyFindUniqueArgs} args - Arguments to find a UserApiKey
     * @example
     * // Get one UserApiKey
     * const userApiKey = await prisma.userApiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserApiKeyFindUniqueArgs>(args: SelectSubset<T, UserApiKeyFindUniqueArgs<ExtArgs>>): Prisma__UserApiKeyClient<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserApiKeyFindUniqueOrThrowArgs} args - Arguments to find a UserApiKey
     * @example
     * // Get one UserApiKey
     * const userApiKey = await prisma.userApiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, UserApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserApiKeyClient<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyFindFirstArgs} args - Arguments to find a UserApiKey
     * @example
     * // Get one UserApiKey
     * const userApiKey = await prisma.userApiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserApiKeyFindFirstArgs>(args?: SelectSubset<T, UserApiKeyFindFirstArgs<ExtArgs>>): Prisma__UserApiKeyClient<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyFindFirstOrThrowArgs} args - Arguments to find a UserApiKey
     * @example
     * // Get one UserApiKey
     * const userApiKey = await prisma.userApiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, UserApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserApiKeyClient<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserApiKeys
     * const userApiKeys = await prisma.userApiKey.findMany()
     * 
     * // Get first 10 UserApiKeys
     * const userApiKeys = await prisma.userApiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userApiKeyWithIdOnly = await prisma.userApiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserApiKeyFindManyArgs>(args?: SelectSubset<T, UserApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserApiKey.
     * @param {UserApiKeyCreateArgs} args - Arguments to create a UserApiKey.
     * @example
     * // Create one UserApiKey
     * const UserApiKey = await prisma.userApiKey.create({
     *   data: {
     *     // ... data to create a UserApiKey
     *   }
     * })
     * 
     */
    create<T extends UserApiKeyCreateArgs>(args: SelectSubset<T, UserApiKeyCreateArgs<ExtArgs>>): Prisma__UserApiKeyClient<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserApiKeys.
     * @param {UserApiKeyCreateManyArgs} args - Arguments to create many UserApiKeys.
     * @example
     * // Create many UserApiKeys
     * const userApiKey = await prisma.userApiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserApiKeyCreateManyArgs>(args?: SelectSubset<T, UserApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserApiKey.
     * @param {UserApiKeyDeleteArgs} args - Arguments to delete one UserApiKey.
     * @example
     * // Delete one UserApiKey
     * const UserApiKey = await prisma.userApiKey.delete({
     *   where: {
     *     // ... filter to delete one UserApiKey
     *   }
     * })
     * 
     */
    delete<T extends UserApiKeyDeleteArgs>(args: SelectSubset<T, UserApiKeyDeleteArgs<ExtArgs>>): Prisma__UserApiKeyClient<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserApiKey.
     * @param {UserApiKeyUpdateArgs} args - Arguments to update one UserApiKey.
     * @example
     * // Update one UserApiKey
     * const userApiKey = await prisma.userApiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserApiKeyUpdateArgs>(args: SelectSubset<T, UserApiKeyUpdateArgs<ExtArgs>>): Prisma__UserApiKeyClient<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserApiKeys.
     * @param {UserApiKeyDeleteManyArgs} args - Arguments to filter UserApiKeys to delete.
     * @example
     * // Delete a few UserApiKeys
     * const { count } = await prisma.userApiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserApiKeyDeleteManyArgs>(args?: SelectSubset<T, UserApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserApiKeys
     * const userApiKey = await prisma.userApiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserApiKeyUpdateManyArgs>(args: SelectSubset<T, UserApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserApiKey.
     * @param {UserApiKeyUpsertArgs} args - Arguments to update or create a UserApiKey.
     * @example
     * // Update or create a UserApiKey
     * const userApiKey = await prisma.userApiKey.upsert({
     *   create: {
     *     // ... data to create a UserApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserApiKey we want to update
     *   }
     * })
     */
    upsert<T extends UserApiKeyUpsertArgs>(args: SelectSubset<T, UserApiKeyUpsertArgs<ExtArgs>>): Prisma__UserApiKeyClient<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserApiKeys that matches the filter.
     * @param {UserApiKeyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userApiKey = await prisma.userApiKey.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserApiKeyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserApiKey.
     * @param {UserApiKeyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userApiKey = await prisma.userApiKey.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserApiKeyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyCountArgs} args - Arguments to filter UserApiKeys to count.
     * @example
     * // Count the number of UserApiKeys
     * const count = await prisma.userApiKey.count({
     *   where: {
     *     // ... the filter for the UserApiKeys we want to count
     *   }
     * })
    **/
    count<T extends UserApiKeyCountArgs>(
      args?: Subset<T, UserApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserApiKeyAggregateArgs>(args: Subset<T, UserApiKeyAggregateArgs>): Prisma.PrismaPromise<GetUserApiKeyAggregateType<T>>

    /**
     * Group by UserApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: UserApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserApiKey model
   */
  readonly fields: UserApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    models<T extends UserApiKey$modelsArgs<ExtArgs> = {}>(args?: Subset<T, UserApiKey$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserApiKey model
   */
  interface UserApiKeyFieldRefs {
    readonly id: FieldRef<"UserApiKey", 'String'>
    readonly key: FieldRef<"UserApiKey", 'String'>
    readonly userId: FieldRef<"UserApiKey", 'String'>
    readonly label: FieldRef<"UserApiKey", 'String'>
    readonly status: FieldRef<"UserApiKey", 'ApiKeyStatus'>
    readonly usageCount: FieldRef<"UserApiKey", 'Int'>
    readonly lastUsedAt: FieldRef<"UserApiKey", 'DateTime'>
    readonly createdAt: FieldRef<"UserApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"UserApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserApiKey findUnique
   */
  export type UserApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which UserApiKey to fetch.
     */
    where: UserApiKeyWhereUniqueInput
  }

  /**
   * UserApiKey findUniqueOrThrow
   */
  export type UserApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which UserApiKey to fetch.
     */
    where: UserApiKeyWhereUniqueInput
  }

  /**
   * UserApiKey findFirst
   */
  export type UserApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which UserApiKey to fetch.
     */
    where?: UserApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApiKeys to fetch.
     */
    orderBy?: UserApiKeyOrderByWithRelationInput | UserApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserApiKeys.
     */
    cursor?: UserApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserApiKeys.
     */
    distinct?: UserApiKeyScalarFieldEnum | UserApiKeyScalarFieldEnum[]
  }

  /**
   * UserApiKey findFirstOrThrow
   */
  export type UserApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which UserApiKey to fetch.
     */
    where?: UserApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApiKeys to fetch.
     */
    orderBy?: UserApiKeyOrderByWithRelationInput | UserApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserApiKeys.
     */
    cursor?: UserApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserApiKeys.
     */
    distinct?: UserApiKeyScalarFieldEnum | UserApiKeyScalarFieldEnum[]
  }

  /**
   * UserApiKey findMany
   */
  export type UserApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which UserApiKeys to fetch.
     */
    where?: UserApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApiKeys to fetch.
     */
    orderBy?: UserApiKeyOrderByWithRelationInput | UserApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserApiKeys.
     */
    cursor?: UserApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApiKeys.
     */
    skip?: number
    distinct?: UserApiKeyScalarFieldEnum | UserApiKeyScalarFieldEnum[]
  }

  /**
   * UserApiKey create
   */
  export type UserApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a UserApiKey.
     */
    data: XOR<UserApiKeyCreateInput, UserApiKeyUncheckedCreateInput>
  }

  /**
   * UserApiKey createMany
   */
  export type UserApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserApiKeys.
     */
    data: UserApiKeyCreateManyInput | UserApiKeyCreateManyInput[]
  }

  /**
   * UserApiKey update
   */
  export type UserApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a UserApiKey.
     */
    data: XOR<UserApiKeyUpdateInput, UserApiKeyUncheckedUpdateInput>
    /**
     * Choose, which UserApiKey to update.
     */
    where: UserApiKeyWhereUniqueInput
  }

  /**
   * UserApiKey updateMany
   */
  export type UserApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserApiKeys.
     */
    data: XOR<UserApiKeyUpdateManyMutationInput, UserApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which UserApiKeys to update
     */
    where?: UserApiKeyWhereInput
    /**
     * Limit how many UserApiKeys to update.
     */
    limit?: number
  }

  /**
   * UserApiKey upsert
   */
  export type UserApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the UserApiKey to update in case it exists.
     */
    where: UserApiKeyWhereUniqueInput
    /**
     * In case the UserApiKey found by the `where` argument doesn't exist, create a new UserApiKey with this data.
     */
    create: XOR<UserApiKeyCreateInput, UserApiKeyUncheckedCreateInput>
    /**
     * In case the UserApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserApiKeyUpdateInput, UserApiKeyUncheckedUpdateInput>
  }

  /**
   * UserApiKey delete
   */
  export type UserApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
    /**
     * Filter which UserApiKey to delete.
     */
    where: UserApiKeyWhereUniqueInput
  }

  /**
   * UserApiKey deleteMany
   */
  export type UserApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserApiKeys to delete
     */
    where?: UserApiKeyWhereInput
    /**
     * Limit how many UserApiKeys to delete.
     */
    limit?: number
  }

  /**
   * UserApiKey findRaw
   */
  export type UserApiKeyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserApiKey aggregateRaw
   */
  export type UserApiKeyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserApiKey.models
   */
  export type UserApiKey$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    where?: UserApiKeyToModelWhereInput
    orderBy?: UserApiKeyToModelOrderByWithRelationInput | UserApiKeyToModelOrderByWithRelationInput[]
    cursor?: UserApiKeyToModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserApiKeyToModelScalarFieldEnum | UserApiKeyToModelScalarFieldEnum[]
  }

  /**
   * UserApiKey without action
   */
  export type UserApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKey
     */
    select?: UserApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKey
     */
    omit?: UserApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model Provider
   */

  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ProviderMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithAggregationInput | ProviderOrderByWithAggregationInput[]
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }

  export type ProviderGroupByOutputType = {
    id: string
    name: string
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    models?: boolean | Provider$modelsArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>



  export type ProviderSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type ProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["provider"]>
  export type ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | Provider$modelsArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provider"
    objects: {
      models: Prisma.$ModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["provider"]>
    composites: {}
  }

  type ProviderGetPayload<S extends boolean | null | undefined | ProviderDefaultArgs> = $Result.GetResult<Prisma.$ProviderPayload, S>

  type ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provider'], meta: { name: 'Provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderFindUniqueArgs>(args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderFindFirstArgs>(args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderFindManyArgs>(args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
     */
    create<T extends ProviderCreateArgs>(args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Providers.
     * @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderCreateManyArgs>(args?: SelectSubset<T, ProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
     */
    delete<T extends ProviderDeleteArgs>(args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderUpdateArgs>(args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderDeleteManyArgs>(args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderUpdateManyArgs>(args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
     */
    upsert<T extends ProviderUpsertArgs>(args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * @param {ProviderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const provider = await prisma.provider.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProviderFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Provider.
     * @param {ProviderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const provider = await prisma.provider.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProviderAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provider model
   */
  readonly fields: ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    models<T extends Provider$modelsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Provider model
   */
  interface ProviderFieldRefs {
    readonly id: FieldRef<"Provider", 'String'>
    readonly name: FieldRef<"Provider", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Provider findUnique
   */
  export type ProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findFirst
   */
  export type ProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider create
   */
  export type ProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }

  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
  }

  /**
   * Provider update
   */
  export type ProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }

  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to delete.
     */
    limit?: number
  }

  /**
   * Provider findRaw
   */
  export type ProviderFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Provider aggregateRaw
   */
  export type ProviderAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Provider.models
   */
  export type Provider$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    cursor?: ModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Provider without action
   */
  export type ProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
  }


  /**
   * Model Model
   */

  export type AggregateModel = {
    _count: ModelCountAggregateOutputType | null
    _avg: ModelAvgAggregateOutputType | null
    _sum: ModelSumAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  export type ModelAvgAggregateOutputType = {
    rpm: number | null
    tpm: number | null
    rpd: number | null
  }

  export type ModelSumAggregateOutputType = {
    rpm: number | null
    tpm: number | null
    rpd: number | null
  }

  export type ModelMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    value: string | null
    rpm: number | null
    tpm: number | null
    rpd: number | null
    label: string | null
    description: string | null
  }

  export type ModelMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    value: string | null
    rpm: number | null
    tpm: number | null
    rpd: number | null
    label: string | null
    description: string | null
  }

  export type ModelCountAggregateOutputType = {
    id: number
    providerId: number
    value: number
    rpm: number
    tpm: number
    rpd: number
    label: number
    description: number
    _all: number
  }


  export type ModelAvgAggregateInputType = {
    rpm?: true
    tpm?: true
    rpd?: true
  }

  export type ModelSumAggregateInputType = {
    rpm?: true
    tpm?: true
    rpd?: true
  }

  export type ModelMinAggregateInputType = {
    id?: true
    providerId?: true
    value?: true
    rpm?: true
    tpm?: true
    rpd?: true
    label?: true
    description?: true
  }

  export type ModelMaxAggregateInputType = {
    id?: true
    providerId?: true
    value?: true
    rpm?: true
    tpm?: true
    rpd?: true
    label?: true
    description?: true
  }

  export type ModelCountAggregateInputType = {
    id?: true
    providerId?: true
    value?: true
    rpm?: true
    tpm?: true
    rpd?: true
    label?: true
    description?: true
    _all?: true
  }

  export type ModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Model to aggregate.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Models
    **/
    _count?: true | ModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelMaxAggregateInputType
  }

  export type GetModelAggregateType<T extends ModelAggregateArgs> = {
        [P in keyof T & keyof AggregateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel[P]>
      : GetScalarType<T[P], AggregateModel[P]>
  }




  export type ModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithAggregationInput | ModelOrderByWithAggregationInput[]
    by: ModelScalarFieldEnum[] | ModelScalarFieldEnum
    having?: ModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelCountAggregateInputType | true
    _avg?: ModelAvgAggregateInputType
    _sum?: ModelSumAggregateInputType
    _min?: ModelMinAggregateInputType
    _max?: ModelMaxAggregateInputType
  }

  export type ModelGroupByOutputType = {
    id: string
    providerId: string
    value: string
    rpm: number | null
    tpm: number | null
    rpd: number | null
    label: string
    description: string | null
    _count: ModelCountAggregateOutputType | null
    _avg: ModelAvgAggregateOutputType | null
    _sum: ModelSumAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  type GetModelGroupByPayload<T extends ModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelGroupByOutputType[P]>
            : GetScalarType<T[P], ModelGroupByOutputType[P]>
        }
      >
    >


  export type ModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    value?: boolean
    rpm?: boolean
    tpm?: boolean
    rpd?: boolean
    label?: boolean
    description?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    userApiKeys?: boolean | Model$userApiKeysArgs<ExtArgs>
    defaultKeys?: boolean | Model$defaultKeysArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>



  export type ModelSelectScalar = {
    id?: boolean
    providerId?: boolean
    value?: boolean
    rpm?: boolean
    tpm?: boolean
    rpd?: boolean
    label?: boolean
    description?: boolean
  }

  export type ModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "value" | "rpm" | "tpm" | "rpd" | "label" | "description", ExtArgs["result"]["model"]>
  export type ModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    userApiKeys?: boolean | Model$userApiKeysArgs<ExtArgs>
    defaultKeys?: boolean | Model$defaultKeysArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Model"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
      userApiKeys: Prisma.$UserApiKeyToModelPayload<ExtArgs>[]
      defaultKeys: Prisma.$DefaultKeyToModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      value: string
      rpm: number | null
      tpm: number | null
      rpd: number | null
      label: string
      description: string | null
    }, ExtArgs["result"]["model"]>
    composites: {}
  }

  type ModelGetPayload<S extends boolean | null | undefined | ModelDefaultArgs> = $Result.GetResult<Prisma.$ModelPayload, S>

  type ModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelCountAggregateInputType | true
    }

  export interface ModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Model'], meta: { name: 'Model' } }
    /**
     * Find zero or one Model that matches the filter.
     * @param {ModelFindUniqueArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelFindUniqueArgs>(args: SelectSubset<T, ModelFindUniqueArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Model that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelFindUniqueOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelFindFirstArgs>(args?: SelectSubset<T, ModelFindFirstArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.model.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.model.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelWithIdOnly = await prisma.model.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelFindManyArgs>(args?: SelectSubset<T, ModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Model.
     * @param {ModelCreateArgs} args - Arguments to create a Model.
     * @example
     * // Create one Model
     * const Model = await prisma.model.create({
     *   data: {
     *     // ... data to create a Model
     *   }
     * })
     * 
     */
    create<T extends ModelCreateArgs>(args: SelectSubset<T, ModelCreateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Models.
     * @param {ModelCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelCreateManyArgs>(args?: SelectSubset<T, ModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Model.
     * @param {ModelDeleteArgs} args - Arguments to delete one Model.
     * @example
     * // Delete one Model
     * const Model = await prisma.model.delete({
     *   where: {
     *     // ... filter to delete one Model
     *   }
     * })
     * 
     */
    delete<T extends ModelDeleteArgs>(args: SelectSubset<T, ModelDeleteArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Model.
     * @param {ModelUpdateArgs} args - Arguments to update one Model.
     * @example
     * // Update one Model
     * const model = await prisma.model.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelUpdateArgs>(args: SelectSubset<T, ModelUpdateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Models.
     * @param {ModelDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.model.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelDeleteManyArgs>(args?: SelectSubset<T, ModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelUpdateManyArgs>(args: SelectSubset<T, ModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Model.
     * @param {ModelUpsertArgs} args - Arguments to update or create a Model.
     * @example
     * // Update or create a Model
     * const model = await prisma.model.upsert({
     *   create: {
     *     // ... data to create a Model
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model we want to update
     *   }
     * })
     */
    upsert<T extends ModelUpsertArgs>(args: SelectSubset<T, ModelUpsertArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Models that matches the filter.
     * @param {ModelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const model = await prisma.model.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ModelFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Model.
     * @param {ModelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const model = await prisma.model.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ModelAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.model.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends ModelCountArgs>(
      args?: Subset<T, ModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelAggregateArgs>(args: Subset<T, ModelAggregateArgs>): Prisma.PrismaPromise<GetModelAggregateType<T>>

    /**
     * Group by Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelGroupByArgs['orderBy'] }
        : { orderBy?: ModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Model model
   */
  readonly fields: ModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Model.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userApiKeys<T extends Model$userApiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Model$userApiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    defaultKeys<T extends Model$defaultKeysArgs<ExtArgs> = {}>(args?: Subset<T, Model$defaultKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Model model
   */
  interface ModelFieldRefs {
    readonly id: FieldRef<"Model", 'String'>
    readonly providerId: FieldRef<"Model", 'String'>
    readonly value: FieldRef<"Model", 'String'>
    readonly rpm: FieldRef<"Model", 'Int'>
    readonly tpm: FieldRef<"Model", 'Int'>
    readonly rpd: FieldRef<"Model", 'Int'>
    readonly label: FieldRef<"Model", 'String'>
    readonly description: FieldRef<"Model", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Model findUnique
   */
  export type ModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findUniqueOrThrow
   */
  export type ModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findFirst
   */
  export type ModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findFirstOrThrow
   */
  export type ModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findMany
   */
  export type ModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model create
   */
  export type ModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to create a Model.
     */
    data: XOR<ModelCreateInput, ModelUncheckedCreateInput>
  }

  /**
   * Model createMany
   */
  export type ModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
  }

  /**
   * Model update
   */
  export type ModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to update a Model.
     */
    data: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
    /**
     * Choose, which Model to update.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model updateMany
   */
  export type ModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to update.
     */
    limit?: number
  }

  /**
   * Model upsert
   */
  export type ModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The filter to search for the Model to update in case it exists.
     */
    where: ModelWhereUniqueInput
    /**
     * In case the Model found by the `where` argument doesn't exist, create a new Model with this data.
     */
    create: XOR<ModelCreateInput, ModelUncheckedCreateInput>
    /**
     * In case the Model was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
  }

  /**
   * Model delete
   */
  export type ModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter which Model to delete.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model deleteMany
   */
  export type ModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Models to delete
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to delete.
     */
    limit?: number
  }

  /**
   * Model findRaw
   */
  export type ModelFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Model aggregateRaw
   */
  export type ModelAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Model.userApiKeys
   */
  export type Model$userApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    where?: UserApiKeyToModelWhereInput
    orderBy?: UserApiKeyToModelOrderByWithRelationInput | UserApiKeyToModelOrderByWithRelationInput[]
    cursor?: UserApiKeyToModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserApiKeyToModelScalarFieldEnum | UserApiKeyToModelScalarFieldEnum[]
  }

  /**
   * Model.defaultKeys
   */
  export type Model$defaultKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    where?: DefaultKeyToModelWhereInput
    orderBy?: DefaultKeyToModelOrderByWithRelationInput | DefaultKeyToModelOrderByWithRelationInput[]
    cursor?: DefaultKeyToModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefaultKeyToModelScalarFieldEnum | DefaultKeyToModelScalarFieldEnum[]
  }

  /**
   * Model without action
   */
  export type ModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
  }


  /**
   * Model DefaultKey
   */

  export type AggregateDefaultKey = {
    _count: DefaultKeyCountAggregateOutputType | null
    _avg: DefaultKeyAvgAggregateOutputType | null
    _sum: DefaultKeySumAggregateOutputType | null
    _min: DefaultKeyMinAggregateOutputType | null
    _max: DefaultKeyMaxAggregateOutputType | null
  }

  export type DefaultKeyAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type DefaultKeySumAggregateOutputType = {
    usageCount: number | null
  }

  export type DefaultKeyMinAggregateOutputType = {
    id: string | null
    key: string | null
    status: $Enums.ApiKeyStatus | null
    usageCount: number | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefaultKeyMaxAggregateOutputType = {
    id: string | null
    key: string | null
    status: $Enums.ApiKeyStatus | null
    usageCount: number | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefaultKeyCountAggregateOutputType = {
    id: number
    key: number
    status: number
    usageCount: number
    lastUsedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DefaultKeyAvgAggregateInputType = {
    usageCount?: true
  }

  export type DefaultKeySumAggregateInputType = {
    usageCount?: true
  }

  export type DefaultKeyMinAggregateInputType = {
    id?: true
    key?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefaultKeyMaxAggregateInputType = {
    id?: true
    key?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefaultKeyCountAggregateInputType = {
    id?: true
    key?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DefaultKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultKey to aggregate.
     */
    where?: DefaultKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultKeys to fetch.
     */
    orderBy?: DefaultKeyOrderByWithRelationInput | DefaultKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefaultKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DefaultKeys
    **/
    _count?: true | DefaultKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DefaultKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DefaultKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefaultKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefaultKeyMaxAggregateInputType
  }

  export type GetDefaultKeyAggregateType<T extends DefaultKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateDefaultKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefaultKey[P]>
      : GetScalarType<T[P], AggregateDefaultKey[P]>
  }




  export type DefaultKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultKeyWhereInput
    orderBy?: DefaultKeyOrderByWithAggregationInput | DefaultKeyOrderByWithAggregationInput[]
    by: DefaultKeyScalarFieldEnum[] | DefaultKeyScalarFieldEnum
    having?: DefaultKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefaultKeyCountAggregateInputType | true
    _avg?: DefaultKeyAvgAggregateInputType
    _sum?: DefaultKeySumAggregateInputType
    _min?: DefaultKeyMinAggregateInputType
    _max?: DefaultKeyMaxAggregateInputType
  }

  export type DefaultKeyGroupByOutputType = {
    id: string
    key: string
    status: $Enums.ApiKeyStatus
    usageCount: number
    lastUsedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DefaultKeyCountAggregateOutputType | null
    _avg: DefaultKeyAvgAggregateOutputType | null
    _sum: DefaultKeySumAggregateOutputType | null
    _min: DefaultKeyMinAggregateOutputType | null
    _max: DefaultKeyMaxAggregateOutputType | null
  }

  type GetDefaultKeyGroupByPayload<T extends DefaultKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefaultKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefaultKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefaultKeyGroupByOutputType[P]>
            : GetScalarType<T[P], DefaultKeyGroupByOutputType[P]>
        }
      >
    >


  export type DefaultKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    status?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    models?: boolean | DefaultKey$modelsArgs<ExtArgs>
    _count?: boolean | DefaultKeyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defaultKey"]>



  export type DefaultKeySelectScalar = {
    id?: boolean
    key?: boolean
    status?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DefaultKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "status" | "usageCount" | "lastUsedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["defaultKey"]>
  export type DefaultKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | DefaultKey$modelsArgs<ExtArgs>
    _count?: boolean | DefaultKeyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DefaultKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DefaultKey"
    objects: {
      models: Prisma.$DefaultKeyToModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      status: $Enums.ApiKeyStatus
      usageCount: number
      lastUsedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["defaultKey"]>
    composites: {}
  }

  type DefaultKeyGetPayload<S extends boolean | null | undefined | DefaultKeyDefaultArgs> = $Result.GetResult<Prisma.$DefaultKeyPayload, S>

  type DefaultKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DefaultKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DefaultKeyCountAggregateInputType | true
    }

  export interface DefaultKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DefaultKey'], meta: { name: 'DefaultKey' } }
    /**
     * Find zero or one DefaultKey that matches the filter.
     * @param {DefaultKeyFindUniqueArgs} args - Arguments to find a DefaultKey
     * @example
     * // Get one DefaultKey
     * const defaultKey = await prisma.defaultKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefaultKeyFindUniqueArgs>(args: SelectSubset<T, DefaultKeyFindUniqueArgs<ExtArgs>>): Prisma__DefaultKeyClient<$Result.GetResult<Prisma.$DefaultKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DefaultKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DefaultKeyFindUniqueOrThrowArgs} args - Arguments to find a DefaultKey
     * @example
     * // Get one DefaultKey
     * const defaultKey = await prisma.defaultKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefaultKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, DefaultKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefaultKeyClient<$Result.GetResult<Prisma.$DefaultKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefaultKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyFindFirstArgs} args - Arguments to find a DefaultKey
     * @example
     * // Get one DefaultKey
     * const defaultKey = await prisma.defaultKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefaultKeyFindFirstArgs>(args?: SelectSubset<T, DefaultKeyFindFirstArgs<ExtArgs>>): Prisma__DefaultKeyClient<$Result.GetResult<Prisma.$DefaultKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefaultKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyFindFirstOrThrowArgs} args - Arguments to find a DefaultKey
     * @example
     * // Get one DefaultKey
     * const defaultKey = await prisma.defaultKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefaultKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, DefaultKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefaultKeyClient<$Result.GetResult<Prisma.$DefaultKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DefaultKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DefaultKeys
     * const defaultKeys = await prisma.defaultKey.findMany()
     * 
     * // Get first 10 DefaultKeys
     * const defaultKeys = await prisma.defaultKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defaultKeyWithIdOnly = await prisma.defaultKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefaultKeyFindManyArgs>(args?: SelectSubset<T, DefaultKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DefaultKey.
     * @param {DefaultKeyCreateArgs} args - Arguments to create a DefaultKey.
     * @example
     * // Create one DefaultKey
     * const DefaultKey = await prisma.defaultKey.create({
     *   data: {
     *     // ... data to create a DefaultKey
     *   }
     * })
     * 
     */
    create<T extends DefaultKeyCreateArgs>(args: SelectSubset<T, DefaultKeyCreateArgs<ExtArgs>>): Prisma__DefaultKeyClient<$Result.GetResult<Prisma.$DefaultKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DefaultKeys.
     * @param {DefaultKeyCreateManyArgs} args - Arguments to create many DefaultKeys.
     * @example
     * // Create many DefaultKeys
     * const defaultKey = await prisma.defaultKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefaultKeyCreateManyArgs>(args?: SelectSubset<T, DefaultKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DefaultKey.
     * @param {DefaultKeyDeleteArgs} args - Arguments to delete one DefaultKey.
     * @example
     * // Delete one DefaultKey
     * const DefaultKey = await prisma.defaultKey.delete({
     *   where: {
     *     // ... filter to delete one DefaultKey
     *   }
     * })
     * 
     */
    delete<T extends DefaultKeyDeleteArgs>(args: SelectSubset<T, DefaultKeyDeleteArgs<ExtArgs>>): Prisma__DefaultKeyClient<$Result.GetResult<Prisma.$DefaultKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DefaultKey.
     * @param {DefaultKeyUpdateArgs} args - Arguments to update one DefaultKey.
     * @example
     * // Update one DefaultKey
     * const defaultKey = await prisma.defaultKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefaultKeyUpdateArgs>(args: SelectSubset<T, DefaultKeyUpdateArgs<ExtArgs>>): Prisma__DefaultKeyClient<$Result.GetResult<Prisma.$DefaultKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DefaultKeys.
     * @param {DefaultKeyDeleteManyArgs} args - Arguments to filter DefaultKeys to delete.
     * @example
     * // Delete a few DefaultKeys
     * const { count } = await prisma.defaultKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefaultKeyDeleteManyArgs>(args?: SelectSubset<T, DefaultKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefaultKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DefaultKeys
     * const defaultKey = await prisma.defaultKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefaultKeyUpdateManyArgs>(args: SelectSubset<T, DefaultKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DefaultKey.
     * @param {DefaultKeyUpsertArgs} args - Arguments to update or create a DefaultKey.
     * @example
     * // Update or create a DefaultKey
     * const defaultKey = await prisma.defaultKey.upsert({
     *   create: {
     *     // ... data to create a DefaultKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DefaultKey we want to update
     *   }
     * })
     */
    upsert<T extends DefaultKeyUpsertArgs>(args: SelectSubset<T, DefaultKeyUpsertArgs<ExtArgs>>): Prisma__DefaultKeyClient<$Result.GetResult<Prisma.$DefaultKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DefaultKeys that matches the filter.
     * @param {DefaultKeyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const defaultKey = await prisma.defaultKey.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DefaultKeyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DefaultKey.
     * @param {DefaultKeyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const defaultKey = await prisma.defaultKey.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DefaultKeyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DefaultKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyCountArgs} args - Arguments to filter DefaultKeys to count.
     * @example
     * // Count the number of DefaultKeys
     * const count = await prisma.defaultKey.count({
     *   where: {
     *     // ... the filter for the DefaultKeys we want to count
     *   }
     * })
    **/
    count<T extends DefaultKeyCountArgs>(
      args?: Subset<T, DefaultKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefaultKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DefaultKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefaultKeyAggregateArgs>(args: Subset<T, DefaultKeyAggregateArgs>): Prisma.PrismaPromise<GetDefaultKeyAggregateType<T>>

    /**
     * Group by DefaultKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefaultKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefaultKeyGroupByArgs['orderBy'] }
        : { orderBy?: DefaultKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefaultKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefaultKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DefaultKey model
   */
  readonly fields: DefaultKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DefaultKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefaultKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    models<T extends DefaultKey$modelsArgs<ExtArgs> = {}>(args?: Subset<T, DefaultKey$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DefaultKey model
   */
  interface DefaultKeyFieldRefs {
    readonly id: FieldRef<"DefaultKey", 'String'>
    readonly key: FieldRef<"DefaultKey", 'String'>
    readonly status: FieldRef<"DefaultKey", 'ApiKeyStatus'>
    readonly usageCount: FieldRef<"DefaultKey", 'Int'>
    readonly lastUsedAt: FieldRef<"DefaultKey", 'DateTime'>
    readonly createdAt: FieldRef<"DefaultKey", 'DateTime'>
    readonly updatedAt: FieldRef<"DefaultKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DefaultKey findUnique
   */
  export type DefaultKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKey
     */
    select?: DefaultKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKey
     */
    omit?: DefaultKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyInclude<ExtArgs> | null
    /**
     * Filter, which DefaultKey to fetch.
     */
    where: DefaultKeyWhereUniqueInput
  }

  /**
   * DefaultKey findUniqueOrThrow
   */
  export type DefaultKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKey
     */
    select?: DefaultKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKey
     */
    omit?: DefaultKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyInclude<ExtArgs> | null
    /**
     * Filter, which DefaultKey to fetch.
     */
    where: DefaultKeyWhereUniqueInput
  }

  /**
   * DefaultKey findFirst
   */
  export type DefaultKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKey
     */
    select?: DefaultKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKey
     */
    omit?: DefaultKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyInclude<ExtArgs> | null
    /**
     * Filter, which DefaultKey to fetch.
     */
    where?: DefaultKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultKeys to fetch.
     */
    orderBy?: DefaultKeyOrderByWithRelationInput | DefaultKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultKeys.
     */
    cursor?: DefaultKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultKeys.
     */
    distinct?: DefaultKeyScalarFieldEnum | DefaultKeyScalarFieldEnum[]
  }

  /**
   * DefaultKey findFirstOrThrow
   */
  export type DefaultKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKey
     */
    select?: DefaultKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKey
     */
    omit?: DefaultKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyInclude<ExtArgs> | null
    /**
     * Filter, which DefaultKey to fetch.
     */
    where?: DefaultKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultKeys to fetch.
     */
    orderBy?: DefaultKeyOrderByWithRelationInput | DefaultKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultKeys.
     */
    cursor?: DefaultKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultKeys.
     */
    distinct?: DefaultKeyScalarFieldEnum | DefaultKeyScalarFieldEnum[]
  }

  /**
   * DefaultKey findMany
   */
  export type DefaultKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKey
     */
    select?: DefaultKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKey
     */
    omit?: DefaultKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyInclude<ExtArgs> | null
    /**
     * Filter, which DefaultKeys to fetch.
     */
    where?: DefaultKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultKeys to fetch.
     */
    orderBy?: DefaultKeyOrderByWithRelationInput | DefaultKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DefaultKeys.
     */
    cursor?: DefaultKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultKeys.
     */
    skip?: number
    distinct?: DefaultKeyScalarFieldEnum | DefaultKeyScalarFieldEnum[]
  }

  /**
   * DefaultKey create
   */
  export type DefaultKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKey
     */
    select?: DefaultKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKey
     */
    omit?: DefaultKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a DefaultKey.
     */
    data: XOR<DefaultKeyCreateInput, DefaultKeyUncheckedCreateInput>
  }

  /**
   * DefaultKey createMany
   */
  export type DefaultKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DefaultKeys.
     */
    data: DefaultKeyCreateManyInput | DefaultKeyCreateManyInput[]
  }

  /**
   * DefaultKey update
   */
  export type DefaultKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKey
     */
    select?: DefaultKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKey
     */
    omit?: DefaultKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a DefaultKey.
     */
    data: XOR<DefaultKeyUpdateInput, DefaultKeyUncheckedUpdateInput>
    /**
     * Choose, which DefaultKey to update.
     */
    where: DefaultKeyWhereUniqueInput
  }

  /**
   * DefaultKey updateMany
   */
  export type DefaultKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DefaultKeys.
     */
    data: XOR<DefaultKeyUpdateManyMutationInput, DefaultKeyUncheckedUpdateManyInput>
    /**
     * Filter which DefaultKeys to update
     */
    where?: DefaultKeyWhereInput
    /**
     * Limit how many DefaultKeys to update.
     */
    limit?: number
  }

  /**
   * DefaultKey upsert
   */
  export type DefaultKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKey
     */
    select?: DefaultKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKey
     */
    omit?: DefaultKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the DefaultKey to update in case it exists.
     */
    where: DefaultKeyWhereUniqueInput
    /**
     * In case the DefaultKey found by the `where` argument doesn't exist, create a new DefaultKey with this data.
     */
    create: XOR<DefaultKeyCreateInput, DefaultKeyUncheckedCreateInput>
    /**
     * In case the DefaultKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefaultKeyUpdateInput, DefaultKeyUncheckedUpdateInput>
  }

  /**
   * DefaultKey delete
   */
  export type DefaultKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKey
     */
    select?: DefaultKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKey
     */
    omit?: DefaultKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyInclude<ExtArgs> | null
    /**
     * Filter which DefaultKey to delete.
     */
    where: DefaultKeyWhereUniqueInput
  }

  /**
   * DefaultKey deleteMany
   */
  export type DefaultKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultKeys to delete
     */
    where?: DefaultKeyWhereInput
    /**
     * Limit how many DefaultKeys to delete.
     */
    limit?: number
  }

  /**
   * DefaultKey findRaw
   */
  export type DefaultKeyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DefaultKey aggregateRaw
   */
  export type DefaultKeyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DefaultKey.models
   */
  export type DefaultKey$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    where?: DefaultKeyToModelWhereInput
    orderBy?: DefaultKeyToModelOrderByWithRelationInput | DefaultKeyToModelOrderByWithRelationInput[]
    cursor?: DefaultKeyToModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefaultKeyToModelScalarFieldEnum | DefaultKeyToModelScalarFieldEnum[]
  }

  /**
   * DefaultKey without action
   */
  export type DefaultKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKey
     */
    select?: DefaultKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKey
     */
    omit?: DefaultKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyInclude<ExtArgs> | null
  }


  /**
   * Model Dictionary
   */

  export type AggregateDictionary = {
    _count: DictionaryCountAggregateOutputType | null
    _min: DictionaryMinAggregateOutputType | null
    _max: DictionaryMaxAggregateOutputType | null
  }

  export type DictionaryMinAggregateOutputType = {
    id: string | null
    hanTu: string | null
    pinyin: string | null
    nghiaViet: string | null
  }

  export type DictionaryMaxAggregateOutputType = {
    id: string | null
    hanTu: string | null
    pinyin: string | null
    nghiaViet: string | null
  }

  export type DictionaryCountAggregateOutputType = {
    id: number
    hanTu: number
    pinyin: number
    nghiaViet: number
    _all: number
  }


  export type DictionaryMinAggregateInputType = {
    id?: true
    hanTu?: true
    pinyin?: true
    nghiaViet?: true
  }

  export type DictionaryMaxAggregateInputType = {
    id?: true
    hanTu?: true
    pinyin?: true
    nghiaViet?: true
  }

  export type DictionaryCountAggregateInputType = {
    id?: true
    hanTu?: true
    pinyin?: true
    nghiaViet?: true
    _all?: true
  }

  export type DictionaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dictionary to aggregate.
     */
    where?: DictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dictionaries to fetch.
     */
    orderBy?: DictionaryOrderByWithRelationInput | DictionaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dictionaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dictionaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dictionaries
    **/
    _count?: true | DictionaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DictionaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DictionaryMaxAggregateInputType
  }

  export type GetDictionaryAggregateType<T extends DictionaryAggregateArgs> = {
        [P in keyof T & keyof AggregateDictionary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDictionary[P]>
      : GetScalarType<T[P], AggregateDictionary[P]>
  }




  export type DictionaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DictionaryWhereInput
    orderBy?: DictionaryOrderByWithAggregationInput | DictionaryOrderByWithAggregationInput[]
    by: DictionaryScalarFieldEnum[] | DictionaryScalarFieldEnum
    having?: DictionaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DictionaryCountAggregateInputType | true
    _min?: DictionaryMinAggregateInputType
    _max?: DictionaryMaxAggregateInputType
  }

  export type DictionaryGroupByOutputType = {
    id: string
    hanTu: string
    pinyin: string | null
    nghiaViet: string
    _count: DictionaryCountAggregateOutputType | null
    _min: DictionaryMinAggregateOutputType | null
    _max: DictionaryMaxAggregateOutputType | null
  }

  type GetDictionaryGroupByPayload<T extends DictionaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DictionaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DictionaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DictionaryGroupByOutputType[P]>
            : GetScalarType<T[P], DictionaryGroupByOutputType[P]>
        }
      >
    >


  export type DictionarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hanTu?: boolean
    pinyin?: boolean
    nghiaViet?: boolean
  }, ExtArgs["result"]["dictionary"]>



  export type DictionarySelectScalar = {
    id?: boolean
    hanTu?: boolean
    pinyin?: boolean
    nghiaViet?: boolean
  }

  export type DictionaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hanTu" | "pinyin" | "nghiaViet", ExtArgs["result"]["dictionary"]>

  export type $DictionaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dictionary"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hanTu: string
      pinyin: string | null
      nghiaViet: string
    }, ExtArgs["result"]["dictionary"]>
    composites: {}
  }

  type DictionaryGetPayload<S extends boolean | null | undefined | DictionaryDefaultArgs> = $Result.GetResult<Prisma.$DictionaryPayload, S>

  type DictionaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DictionaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DictionaryCountAggregateInputType | true
    }

  export interface DictionaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dictionary'], meta: { name: 'Dictionary' } }
    /**
     * Find zero or one Dictionary that matches the filter.
     * @param {DictionaryFindUniqueArgs} args - Arguments to find a Dictionary
     * @example
     * // Get one Dictionary
     * const dictionary = await prisma.dictionary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DictionaryFindUniqueArgs>(args: SelectSubset<T, DictionaryFindUniqueArgs<ExtArgs>>): Prisma__DictionaryClient<$Result.GetResult<Prisma.$DictionaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dictionary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DictionaryFindUniqueOrThrowArgs} args - Arguments to find a Dictionary
     * @example
     * // Get one Dictionary
     * const dictionary = await prisma.dictionary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DictionaryFindUniqueOrThrowArgs>(args: SelectSubset<T, DictionaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DictionaryClient<$Result.GetResult<Prisma.$DictionaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dictionary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryFindFirstArgs} args - Arguments to find a Dictionary
     * @example
     * // Get one Dictionary
     * const dictionary = await prisma.dictionary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DictionaryFindFirstArgs>(args?: SelectSubset<T, DictionaryFindFirstArgs<ExtArgs>>): Prisma__DictionaryClient<$Result.GetResult<Prisma.$DictionaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dictionary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryFindFirstOrThrowArgs} args - Arguments to find a Dictionary
     * @example
     * // Get one Dictionary
     * const dictionary = await prisma.dictionary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DictionaryFindFirstOrThrowArgs>(args?: SelectSubset<T, DictionaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DictionaryClient<$Result.GetResult<Prisma.$DictionaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dictionaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dictionaries
     * const dictionaries = await prisma.dictionary.findMany()
     * 
     * // Get first 10 Dictionaries
     * const dictionaries = await prisma.dictionary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dictionaryWithIdOnly = await prisma.dictionary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DictionaryFindManyArgs>(args?: SelectSubset<T, DictionaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictionaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dictionary.
     * @param {DictionaryCreateArgs} args - Arguments to create a Dictionary.
     * @example
     * // Create one Dictionary
     * const Dictionary = await prisma.dictionary.create({
     *   data: {
     *     // ... data to create a Dictionary
     *   }
     * })
     * 
     */
    create<T extends DictionaryCreateArgs>(args: SelectSubset<T, DictionaryCreateArgs<ExtArgs>>): Prisma__DictionaryClient<$Result.GetResult<Prisma.$DictionaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dictionaries.
     * @param {DictionaryCreateManyArgs} args - Arguments to create many Dictionaries.
     * @example
     * // Create many Dictionaries
     * const dictionary = await prisma.dictionary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DictionaryCreateManyArgs>(args?: SelectSubset<T, DictionaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dictionary.
     * @param {DictionaryDeleteArgs} args - Arguments to delete one Dictionary.
     * @example
     * // Delete one Dictionary
     * const Dictionary = await prisma.dictionary.delete({
     *   where: {
     *     // ... filter to delete one Dictionary
     *   }
     * })
     * 
     */
    delete<T extends DictionaryDeleteArgs>(args: SelectSubset<T, DictionaryDeleteArgs<ExtArgs>>): Prisma__DictionaryClient<$Result.GetResult<Prisma.$DictionaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dictionary.
     * @param {DictionaryUpdateArgs} args - Arguments to update one Dictionary.
     * @example
     * // Update one Dictionary
     * const dictionary = await prisma.dictionary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DictionaryUpdateArgs>(args: SelectSubset<T, DictionaryUpdateArgs<ExtArgs>>): Prisma__DictionaryClient<$Result.GetResult<Prisma.$DictionaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dictionaries.
     * @param {DictionaryDeleteManyArgs} args - Arguments to filter Dictionaries to delete.
     * @example
     * // Delete a few Dictionaries
     * const { count } = await prisma.dictionary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DictionaryDeleteManyArgs>(args?: SelectSubset<T, DictionaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dictionaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dictionaries
     * const dictionary = await prisma.dictionary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DictionaryUpdateManyArgs>(args: SelectSubset<T, DictionaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dictionary.
     * @param {DictionaryUpsertArgs} args - Arguments to update or create a Dictionary.
     * @example
     * // Update or create a Dictionary
     * const dictionary = await prisma.dictionary.upsert({
     *   create: {
     *     // ... data to create a Dictionary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dictionary we want to update
     *   }
     * })
     */
    upsert<T extends DictionaryUpsertArgs>(args: SelectSubset<T, DictionaryUpsertArgs<ExtArgs>>): Prisma__DictionaryClient<$Result.GetResult<Prisma.$DictionaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dictionaries that matches the filter.
     * @param {DictionaryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dictionary = await prisma.dictionary.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DictionaryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Dictionary.
     * @param {DictionaryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dictionary = await prisma.dictionary.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DictionaryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Dictionaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryCountArgs} args - Arguments to filter Dictionaries to count.
     * @example
     * // Count the number of Dictionaries
     * const count = await prisma.dictionary.count({
     *   where: {
     *     // ... the filter for the Dictionaries we want to count
     *   }
     * })
    **/
    count<T extends DictionaryCountArgs>(
      args?: Subset<T, DictionaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DictionaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dictionary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DictionaryAggregateArgs>(args: Subset<T, DictionaryAggregateArgs>): Prisma.PrismaPromise<GetDictionaryAggregateType<T>>

    /**
     * Group by Dictionary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictionaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DictionaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DictionaryGroupByArgs['orderBy'] }
        : { orderBy?: DictionaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DictionaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDictionaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dictionary model
   */
  readonly fields: DictionaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dictionary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DictionaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dictionary model
   */
  interface DictionaryFieldRefs {
    readonly id: FieldRef<"Dictionary", 'String'>
    readonly hanTu: FieldRef<"Dictionary", 'String'>
    readonly pinyin: FieldRef<"Dictionary", 'String'>
    readonly nghiaViet: FieldRef<"Dictionary", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Dictionary findUnique
   */
  export type DictionaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dictionary
     */
    select?: DictionarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dictionary
     */
    omit?: DictionaryOmit<ExtArgs> | null
    /**
     * Filter, which Dictionary to fetch.
     */
    where: DictionaryWhereUniqueInput
  }

  /**
   * Dictionary findUniqueOrThrow
   */
  export type DictionaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dictionary
     */
    select?: DictionarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dictionary
     */
    omit?: DictionaryOmit<ExtArgs> | null
    /**
     * Filter, which Dictionary to fetch.
     */
    where: DictionaryWhereUniqueInput
  }

  /**
   * Dictionary findFirst
   */
  export type DictionaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dictionary
     */
    select?: DictionarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dictionary
     */
    omit?: DictionaryOmit<ExtArgs> | null
    /**
     * Filter, which Dictionary to fetch.
     */
    where?: DictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dictionaries to fetch.
     */
    orderBy?: DictionaryOrderByWithRelationInput | DictionaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dictionaries.
     */
    cursor?: DictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dictionaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dictionaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dictionaries.
     */
    distinct?: DictionaryScalarFieldEnum | DictionaryScalarFieldEnum[]
  }

  /**
   * Dictionary findFirstOrThrow
   */
  export type DictionaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dictionary
     */
    select?: DictionarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dictionary
     */
    omit?: DictionaryOmit<ExtArgs> | null
    /**
     * Filter, which Dictionary to fetch.
     */
    where?: DictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dictionaries to fetch.
     */
    orderBy?: DictionaryOrderByWithRelationInput | DictionaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dictionaries.
     */
    cursor?: DictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dictionaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dictionaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dictionaries.
     */
    distinct?: DictionaryScalarFieldEnum | DictionaryScalarFieldEnum[]
  }

  /**
   * Dictionary findMany
   */
  export type DictionaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dictionary
     */
    select?: DictionarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dictionary
     */
    omit?: DictionaryOmit<ExtArgs> | null
    /**
     * Filter, which Dictionaries to fetch.
     */
    where?: DictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dictionaries to fetch.
     */
    orderBy?: DictionaryOrderByWithRelationInput | DictionaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dictionaries.
     */
    cursor?: DictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dictionaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dictionaries.
     */
    skip?: number
    distinct?: DictionaryScalarFieldEnum | DictionaryScalarFieldEnum[]
  }

  /**
   * Dictionary create
   */
  export type DictionaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dictionary
     */
    select?: DictionarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dictionary
     */
    omit?: DictionaryOmit<ExtArgs> | null
    /**
     * The data needed to create a Dictionary.
     */
    data: XOR<DictionaryCreateInput, DictionaryUncheckedCreateInput>
  }

  /**
   * Dictionary createMany
   */
  export type DictionaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dictionaries.
     */
    data: DictionaryCreateManyInput | DictionaryCreateManyInput[]
  }

  /**
   * Dictionary update
   */
  export type DictionaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dictionary
     */
    select?: DictionarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dictionary
     */
    omit?: DictionaryOmit<ExtArgs> | null
    /**
     * The data needed to update a Dictionary.
     */
    data: XOR<DictionaryUpdateInput, DictionaryUncheckedUpdateInput>
    /**
     * Choose, which Dictionary to update.
     */
    where: DictionaryWhereUniqueInput
  }

  /**
   * Dictionary updateMany
   */
  export type DictionaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dictionaries.
     */
    data: XOR<DictionaryUpdateManyMutationInput, DictionaryUncheckedUpdateManyInput>
    /**
     * Filter which Dictionaries to update
     */
    where?: DictionaryWhereInput
    /**
     * Limit how many Dictionaries to update.
     */
    limit?: number
  }

  /**
   * Dictionary upsert
   */
  export type DictionaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dictionary
     */
    select?: DictionarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dictionary
     */
    omit?: DictionaryOmit<ExtArgs> | null
    /**
     * The filter to search for the Dictionary to update in case it exists.
     */
    where: DictionaryWhereUniqueInput
    /**
     * In case the Dictionary found by the `where` argument doesn't exist, create a new Dictionary with this data.
     */
    create: XOR<DictionaryCreateInput, DictionaryUncheckedCreateInput>
    /**
     * In case the Dictionary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DictionaryUpdateInput, DictionaryUncheckedUpdateInput>
  }

  /**
   * Dictionary delete
   */
  export type DictionaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dictionary
     */
    select?: DictionarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dictionary
     */
    omit?: DictionaryOmit<ExtArgs> | null
    /**
     * Filter which Dictionary to delete.
     */
    where: DictionaryWhereUniqueInput
  }

  /**
   * Dictionary deleteMany
   */
  export type DictionaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dictionaries to delete
     */
    where?: DictionaryWhereInput
    /**
     * Limit how many Dictionaries to delete.
     */
    limit?: number
  }

  /**
   * Dictionary findRaw
   */
  export type DictionaryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Dictionary aggregateRaw
   */
  export type DictionaryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Dictionary without action
   */
  export type DictionaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dictionary
     */
    select?: DictionarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dictionary
     */
    omit?: DictionaryOmit<ExtArgs> | null
  }


  /**
   * Model UserApiKeyToModel
   */

  export type AggregateUserApiKeyToModel = {
    _count: UserApiKeyToModelCountAggregateOutputType | null
    _avg: UserApiKeyToModelAvgAggregateOutputType | null
    _sum: UserApiKeyToModelSumAggregateOutputType | null
    _min: UserApiKeyToModelMinAggregateOutputType | null
    _max: UserApiKeyToModelMaxAggregateOutputType | null
  }

  export type UserApiKeyToModelAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type UserApiKeyToModelSumAggregateOutputType = {
    usageCount: number | null
  }

  export type UserApiKeyToModelMinAggregateOutputType = {
    id: string | null
    userApiKeyId: string | null
    modelId: string | null
    status: $Enums.ApiKeyStatus | null
    usageCount: number | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserApiKeyToModelMaxAggregateOutputType = {
    id: string | null
    userApiKeyId: string | null
    modelId: string | null
    status: $Enums.ApiKeyStatus | null
    usageCount: number | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserApiKeyToModelCountAggregateOutputType = {
    id: number
    userApiKeyId: number
    modelId: number
    status: number
    usageCount: number
    lastUsedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserApiKeyToModelAvgAggregateInputType = {
    usageCount?: true
  }

  export type UserApiKeyToModelSumAggregateInputType = {
    usageCount?: true
  }

  export type UserApiKeyToModelMinAggregateInputType = {
    id?: true
    userApiKeyId?: true
    modelId?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserApiKeyToModelMaxAggregateInputType = {
    id?: true
    userApiKeyId?: true
    modelId?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserApiKeyToModelCountAggregateInputType = {
    id?: true
    userApiKeyId?: true
    modelId?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserApiKeyToModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserApiKeyToModel to aggregate.
     */
    where?: UserApiKeyToModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApiKeyToModels to fetch.
     */
    orderBy?: UserApiKeyToModelOrderByWithRelationInput | UserApiKeyToModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserApiKeyToModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApiKeyToModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApiKeyToModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserApiKeyToModels
    **/
    _count?: true | UserApiKeyToModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserApiKeyToModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserApiKeyToModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserApiKeyToModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserApiKeyToModelMaxAggregateInputType
  }

  export type GetUserApiKeyToModelAggregateType<T extends UserApiKeyToModelAggregateArgs> = {
        [P in keyof T & keyof AggregateUserApiKeyToModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserApiKeyToModel[P]>
      : GetScalarType<T[P], AggregateUserApiKeyToModel[P]>
  }




  export type UserApiKeyToModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApiKeyToModelWhereInput
    orderBy?: UserApiKeyToModelOrderByWithAggregationInput | UserApiKeyToModelOrderByWithAggregationInput[]
    by: UserApiKeyToModelScalarFieldEnum[] | UserApiKeyToModelScalarFieldEnum
    having?: UserApiKeyToModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserApiKeyToModelCountAggregateInputType | true
    _avg?: UserApiKeyToModelAvgAggregateInputType
    _sum?: UserApiKeyToModelSumAggregateInputType
    _min?: UserApiKeyToModelMinAggregateInputType
    _max?: UserApiKeyToModelMaxAggregateInputType
  }

  export type UserApiKeyToModelGroupByOutputType = {
    id: string
    userApiKeyId: string
    modelId: string
    status: $Enums.ApiKeyStatus
    usageCount: number
    lastUsedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserApiKeyToModelCountAggregateOutputType | null
    _avg: UserApiKeyToModelAvgAggregateOutputType | null
    _sum: UserApiKeyToModelSumAggregateOutputType | null
    _min: UserApiKeyToModelMinAggregateOutputType | null
    _max: UserApiKeyToModelMaxAggregateOutputType | null
  }

  type GetUserApiKeyToModelGroupByPayload<T extends UserApiKeyToModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserApiKeyToModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserApiKeyToModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserApiKeyToModelGroupByOutputType[P]>
            : GetScalarType<T[P], UserApiKeyToModelGroupByOutputType[P]>
        }
      >
    >


  export type UserApiKeyToModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userApiKeyId?: boolean
    modelId?: boolean
    status?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userApiKey?: boolean | UserApiKeyDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userApiKeyToModel"]>



  export type UserApiKeyToModelSelectScalar = {
    id?: boolean
    userApiKeyId?: boolean
    modelId?: boolean
    status?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserApiKeyToModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userApiKeyId" | "modelId" | "status" | "usageCount" | "lastUsedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userApiKeyToModel"]>
  export type UserApiKeyToModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userApiKey?: boolean | UserApiKeyDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
  }

  export type $UserApiKeyToModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserApiKeyToModel"
    objects: {
      userApiKey: Prisma.$UserApiKeyPayload<ExtArgs>
      model: Prisma.$ModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userApiKeyId: string
      modelId: string
      status: $Enums.ApiKeyStatus
      usageCount: number
      lastUsedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userApiKeyToModel"]>
    composites: {}
  }

  type UserApiKeyToModelGetPayload<S extends boolean | null | undefined | UserApiKeyToModelDefaultArgs> = $Result.GetResult<Prisma.$UserApiKeyToModelPayload, S>

  type UserApiKeyToModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserApiKeyToModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserApiKeyToModelCountAggregateInputType | true
    }

  export interface UserApiKeyToModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserApiKeyToModel'], meta: { name: 'UserApiKeyToModel' } }
    /**
     * Find zero or one UserApiKeyToModel that matches the filter.
     * @param {UserApiKeyToModelFindUniqueArgs} args - Arguments to find a UserApiKeyToModel
     * @example
     * // Get one UserApiKeyToModel
     * const userApiKeyToModel = await prisma.userApiKeyToModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserApiKeyToModelFindUniqueArgs>(args: SelectSubset<T, UserApiKeyToModelFindUniqueArgs<ExtArgs>>): Prisma__UserApiKeyToModelClient<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserApiKeyToModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserApiKeyToModelFindUniqueOrThrowArgs} args - Arguments to find a UserApiKeyToModel
     * @example
     * // Get one UserApiKeyToModel
     * const userApiKeyToModel = await prisma.userApiKeyToModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserApiKeyToModelFindUniqueOrThrowArgs>(args: SelectSubset<T, UserApiKeyToModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserApiKeyToModelClient<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserApiKeyToModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyToModelFindFirstArgs} args - Arguments to find a UserApiKeyToModel
     * @example
     * // Get one UserApiKeyToModel
     * const userApiKeyToModel = await prisma.userApiKeyToModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserApiKeyToModelFindFirstArgs>(args?: SelectSubset<T, UserApiKeyToModelFindFirstArgs<ExtArgs>>): Prisma__UserApiKeyToModelClient<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserApiKeyToModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyToModelFindFirstOrThrowArgs} args - Arguments to find a UserApiKeyToModel
     * @example
     * // Get one UserApiKeyToModel
     * const userApiKeyToModel = await prisma.userApiKeyToModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserApiKeyToModelFindFirstOrThrowArgs>(args?: SelectSubset<T, UserApiKeyToModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserApiKeyToModelClient<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserApiKeyToModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyToModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserApiKeyToModels
     * const userApiKeyToModels = await prisma.userApiKeyToModel.findMany()
     * 
     * // Get first 10 UserApiKeyToModels
     * const userApiKeyToModels = await prisma.userApiKeyToModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userApiKeyToModelWithIdOnly = await prisma.userApiKeyToModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserApiKeyToModelFindManyArgs>(args?: SelectSubset<T, UserApiKeyToModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserApiKeyToModel.
     * @param {UserApiKeyToModelCreateArgs} args - Arguments to create a UserApiKeyToModel.
     * @example
     * // Create one UserApiKeyToModel
     * const UserApiKeyToModel = await prisma.userApiKeyToModel.create({
     *   data: {
     *     // ... data to create a UserApiKeyToModel
     *   }
     * })
     * 
     */
    create<T extends UserApiKeyToModelCreateArgs>(args: SelectSubset<T, UserApiKeyToModelCreateArgs<ExtArgs>>): Prisma__UserApiKeyToModelClient<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserApiKeyToModels.
     * @param {UserApiKeyToModelCreateManyArgs} args - Arguments to create many UserApiKeyToModels.
     * @example
     * // Create many UserApiKeyToModels
     * const userApiKeyToModel = await prisma.userApiKeyToModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserApiKeyToModelCreateManyArgs>(args?: SelectSubset<T, UserApiKeyToModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserApiKeyToModel.
     * @param {UserApiKeyToModelDeleteArgs} args - Arguments to delete one UserApiKeyToModel.
     * @example
     * // Delete one UserApiKeyToModel
     * const UserApiKeyToModel = await prisma.userApiKeyToModel.delete({
     *   where: {
     *     // ... filter to delete one UserApiKeyToModel
     *   }
     * })
     * 
     */
    delete<T extends UserApiKeyToModelDeleteArgs>(args: SelectSubset<T, UserApiKeyToModelDeleteArgs<ExtArgs>>): Prisma__UserApiKeyToModelClient<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserApiKeyToModel.
     * @param {UserApiKeyToModelUpdateArgs} args - Arguments to update one UserApiKeyToModel.
     * @example
     * // Update one UserApiKeyToModel
     * const userApiKeyToModel = await prisma.userApiKeyToModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserApiKeyToModelUpdateArgs>(args: SelectSubset<T, UserApiKeyToModelUpdateArgs<ExtArgs>>): Prisma__UserApiKeyToModelClient<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserApiKeyToModels.
     * @param {UserApiKeyToModelDeleteManyArgs} args - Arguments to filter UserApiKeyToModels to delete.
     * @example
     * // Delete a few UserApiKeyToModels
     * const { count } = await prisma.userApiKeyToModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserApiKeyToModelDeleteManyArgs>(args?: SelectSubset<T, UserApiKeyToModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserApiKeyToModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyToModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserApiKeyToModels
     * const userApiKeyToModel = await prisma.userApiKeyToModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserApiKeyToModelUpdateManyArgs>(args: SelectSubset<T, UserApiKeyToModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserApiKeyToModel.
     * @param {UserApiKeyToModelUpsertArgs} args - Arguments to update or create a UserApiKeyToModel.
     * @example
     * // Update or create a UserApiKeyToModel
     * const userApiKeyToModel = await prisma.userApiKeyToModel.upsert({
     *   create: {
     *     // ... data to create a UserApiKeyToModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserApiKeyToModel we want to update
     *   }
     * })
     */
    upsert<T extends UserApiKeyToModelUpsertArgs>(args: SelectSubset<T, UserApiKeyToModelUpsertArgs<ExtArgs>>): Prisma__UserApiKeyToModelClient<$Result.GetResult<Prisma.$UserApiKeyToModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserApiKeyToModels that matches the filter.
     * @param {UserApiKeyToModelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userApiKeyToModel = await prisma.userApiKeyToModel.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserApiKeyToModelFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserApiKeyToModel.
     * @param {UserApiKeyToModelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userApiKeyToModel = await prisma.userApiKeyToModel.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserApiKeyToModelAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserApiKeyToModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyToModelCountArgs} args - Arguments to filter UserApiKeyToModels to count.
     * @example
     * // Count the number of UserApiKeyToModels
     * const count = await prisma.userApiKeyToModel.count({
     *   where: {
     *     // ... the filter for the UserApiKeyToModels we want to count
     *   }
     * })
    **/
    count<T extends UserApiKeyToModelCountArgs>(
      args?: Subset<T, UserApiKeyToModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserApiKeyToModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserApiKeyToModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyToModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserApiKeyToModelAggregateArgs>(args: Subset<T, UserApiKeyToModelAggregateArgs>): Prisma.PrismaPromise<GetUserApiKeyToModelAggregateType<T>>

    /**
     * Group by UserApiKeyToModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApiKeyToModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserApiKeyToModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserApiKeyToModelGroupByArgs['orderBy'] }
        : { orderBy?: UserApiKeyToModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserApiKeyToModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserApiKeyToModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserApiKeyToModel model
   */
  readonly fields: UserApiKeyToModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserApiKeyToModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserApiKeyToModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userApiKey<T extends UserApiKeyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserApiKeyDefaultArgs<ExtArgs>>): Prisma__UserApiKeyClient<$Result.GetResult<Prisma.$UserApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserApiKeyToModel model
   */
  interface UserApiKeyToModelFieldRefs {
    readonly id: FieldRef<"UserApiKeyToModel", 'String'>
    readonly userApiKeyId: FieldRef<"UserApiKeyToModel", 'String'>
    readonly modelId: FieldRef<"UserApiKeyToModel", 'String'>
    readonly status: FieldRef<"UserApiKeyToModel", 'ApiKeyStatus'>
    readonly usageCount: FieldRef<"UserApiKeyToModel", 'Int'>
    readonly lastUsedAt: FieldRef<"UserApiKeyToModel", 'DateTime'>
    readonly createdAt: FieldRef<"UserApiKeyToModel", 'DateTime'>
    readonly updatedAt: FieldRef<"UserApiKeyToModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserApiKeyToModel findUnique
   */
  export type UserApiKeyToModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    /**
     * Filter, which UserApiKeyToModel to fetch.
     */
    where: UserApiKeyToModelWhereUniqueInput
  }

  /**
   * UserApiKeyToModel findUniqueOrThrow
   */
  export type UserApiKeyToModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    /**
     * Filter, which UserApiKeyToModel to fetch.
     */
    where: UserApiKeyToModelWhereUniqueInput
  }

  /**
   * UserApiKeyToModel findFirst
   */
  export type UserApiKeyToModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    /**
     * Filter, which UserApiKeyToModel to fetch.
     */
    where?: UserApiKeyToModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApiKeyToModels to fetch.
     */
    orderBy?: UserApiKeyToModelOrderByWithRelationInput | UserApiKeyToModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserApiKeyToModels.
     */
    cursor?: UserApiKeyToModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApiKeyToModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApiKeyToModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserApiKeyToModels.
     */
    distinct?: UserApiKeyToModelScalarFieldEnum | UserApiKeyToModelScalarFieldEnum[]
  }

  /**
   * UserApiKeyToModel findFirstOrThrow
   */
  export type UserApiKeyToModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    /**
     * Filter, which UserApiKeyToModel to fetch.
     */
    where?: UserApiKeyToModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApiKeyToModels to fetch.
     */
    orderBy?: UserApiKeyToModelOrderByWithRelationInput | UserApiKeyToModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserApiKeyToModels.
     */
    cursor?: UserApiKeyToModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApiKeyToModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApiKeyToModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserApiKeyToModels.
     */
    distinct?: UserApiKeyToModelScalarFieldEnum | UserApiKeyToModelScalarFieldEnum[]
  }

  /**
   * UserApiKeyToModel findMany
   */
  export type UserApiKeyToModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    /**
     * Filter, which UserApiKeyToModels to fetch.
     */
    where?: UserApiKeyToModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApiKeyToModels to fetch.
     */
    orderBy?: UserApiKeyToModelOrderByWithRelationInput | UserApiKeyToModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserApiKeyToModels.
     */
    cursor?: UserApiKeyToModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApiKeyToModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApiKeyToModels.
     */
    skip?: number
    distinct?: UserApiKeyToModelScalarFieldEnum | UserApiKeyToModelScalarFieldEnum[]
  }

  /**
   * UserApiKeyToModel create
   */
  export type UserApiKeyToModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    /**
     * The data needed to create a UserApiKeyToModel.
     */
    data: XOR<UserApiKeyToModelCreateInput, UserApiKeyToModelUncheckedCreateInput>
  }

  /**
   * UserApiKeyToModel createMany
   */
  export type UserApiKeyToModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserApiKeyToModels.
     */
    data: UserApiKeyToModelCreateManyInput | UserApiKeyToModelCreateManyInput[]
  }

  /**
   * UserApiKeyToModel update
   */
  export type UserApiKeyToModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    /**
     * The data needed to update a UserApiKeyToModel.
     */
    data: XOR<UserApiKeyToModelUpdateInput, UserApiKeyToModelUncheckedUpdateInput>
    /**
     * Choose, which UserApiKeyToModel to update.
     */
    where: UserApiKeyToModelWhereUniqueInput
  }

  /**
   * UserApiKeyToModel updateMany
   */
  export type UserApiKeyToModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserApiKeyToModels.
     */
    data: XOR<UserApiKeyToModelUpdateManyMutationInput, UserApiKeyToModelUncheckedUpdateManyInput>
    /**
     * Filter which UserApiKeyToModels to update
     */
    where?: UserApiKeyToModelWhereInput
    /**
     * Limit how many UserApiKeyToModels to update.
     */
    limit?: number
  }

  /**
   * UserApiKeyToModel upsert
   */
  export type UserApiKeyToModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    /**
     * The filter to search for the UserApiKeyToModel to update in case it exists.
     */
    where: UserApiKeyToModelWhereUniqueInput
    /**
     * In case the UserApiKeyToModel found by the `where` argument doesn't exist, create a new UserApiKeyToModel with this data.
     */
    create: XOR<UserApiKeyToModelCreateInput, UserApiKeyToModelUncheckedCreateInput>
    /**
     * In case the UserApiKeyToModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserApiKeyToModelUpdateInput, UserApiKeyToModelUncheckedUpdateInput>
  }

  /**
   * UserApiKeyToModel delete
   */
  export type UserApiKeyToModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
    /**
     * Filter which UserApiKeyToModel to delete.
     */
    where: UserApiKeyToModelWhereUniqueInput
  }

  /**
   * UserApiKeyToModel deleteMany
   */
  export type UserApiKeyToModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserApiKeyToModels to delete
     */
    where?: UserApiKeyToModelWhereInput
    /**
     * Limit how many UserApiKeyToModels to delete.
     */
    limit?: number
  }

  /**
   * UserApiKeyToModel findRaw
   */
  export type UserApiKeyToModelFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserApiKeyToModel aggregateRaw
   */
  export type UserApiKeyToModelAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserApiKeyToModel without action
   */
  export type UserApiKeyToModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApiKeyToModel
     */
    select?: UserApiKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserApiKeyToModel
     */
    omit?: UserApiKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApiKeyToModelInclude<ExtArgs> | null
  }


  /**
   * Model DefaultKeyToModel
   */

  export type AggregateDefaultKeyToModel = {
    _count: DefaultKeyToModelCountAggregateOutputType | null
    _avg: DefaultKeyToModelAvgAggregateOutputType | null
    _sum: DefaultKeyToModelSumAggregateOutputType | null
    _min: DefaultKeyToModelMinAggregateOutputType | null
    _max: DefaultKeyToModelMaxAggregateOutputType | null
  }

  export type DefaultKeyToModelAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type DefaultKeyToModelSumAggregateOutputType = {
    usageCount: number | null
  }

  export type DefaultKeyToModelMinAggregateOutputType = {
    id: string | null
    defaultKeyId: string | null
    modelId: string | null
    status: $Enums.ApiKeyStatus | null
    usageCount: number | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefaultKeyToModelMaxAggregateOutputType = {
    id: string | null
    defaultKeyId: string | null
    modelId: string | null
    status: $Enums.ApiKeyStatus | null
    usageCount: number | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefaultKeyToModelCountAggregateOutputType = {
    id: number
    defaultKeyId: number
    modelId: number
    status: number
    usageCount: number
    lastUsedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DefaultKeyToModelAvgAggregateInputType = {
    usageCount?: true
  }

  export type DefaultKeyToModelSumAggregateInputType = {
    usageCount?: true
  }

  export type DefaultKeyToModelMinAggregateInputType = {
    id?: true
    defaultKeyId?: true
    modelId?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefaultKeyToModelMaxAggregateInputType = {
    id?: true
    defaultKeyId?: true
    modelId?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefaultKeyToModelCountAggregateInputType = {
    id?: true
    defaultKeyId?: true
    modelId?: true
    status?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DefaultKeyToModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultKeyToModel to aggregate.
     */
    where?: DefaultKeyToModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultKeyToModels to fetch.
     */
    orderBy?: DefaultKeyToModelOrderByWithRelationInput | DefaultKeyToModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefaultKeyToModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultKeyToModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultKeyToModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DefaultKeyToModels
    **/
    _count?: true | DefaultKeyToModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DefaultKeyToModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DefaultKeyToModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefaultKeyToModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefaultKeyToModelMaxAggregateInputType
  }

  export type GetDefaultKeyToModelAggregateType<T extends DefaultKeyToModelAggregateArgs> = {
        [P in keyof T & keyof AggregateDefaultKeyToModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefaultKeyToModel[P]>
      : GetScalarType<T[P], AggregateDefaultKeyToModel[P]>
  }




  export type DefaultKeyToModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultKeyToModelWhereInput
    orderBy?: DefaultKeyToModelOrderByWithAggregationInput | DefaultKeyToModelOrderByWithAggregationInput[]
    by: DefaultKeyToModelScalarFieldEnum[] | DefaultKeyToModelScalarFieldEnum
    having?: DefaultKeyToModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefaultKeyToModelCountAggregateInputType | true
    _avg?: DefaultKeyToModelAvgAggregateInputType
    _sum?: DefaultKeyToModelSumAggregateInputType
    _min?: DefaultKeyToModelMinAggregateInputType
    _max?: DefaultKeyToModelMaxAggregateInputType
  }

  export type DefaultKeyToModelGroupByOutputType = {
    id: string
    defaultKeyId: string
    modelId: string
    status: $Enums.ApiKeyStatus
    usageCount: number
    lastUsedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DefaultKeyToModelCountAggregateOutputType | null
    _avg: DefaultKeyToModelAvgAggregateOutputType | null
    _sum: DefaultKeyToModelSumAggregateOutputType | null
    _min: DefaultKeyToModelMinAggregateOutputType | null
    _max: DefaultKeyToModelMaxAggregateOutputType | null
  }

  type GetDefaultKeyToModelGroupByPayload<T extends DefaultKeyToModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefaultKeyToModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefaultKeyToModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefaultKeyToModelGroupByOutputType[P]>
            : GetScalarType<T[P], DefaultKeyToModelGroupByOutputType[P]>
        }
      >
    >


  export type DefaultKeyToModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defaultKeyId?: boolean
    modelId?: boolean
    status?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultKey?: boolean | DefaultKeyDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defaultKeyToModel"]>



  export type DefaultKeyToModelSelectScalar = {
    id?: boolean
    defaultKeyId?: boolean
    modelId?: boolean
    status?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DefaultKeyToModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "defaultKeyId" | "modelId" | "status" | "usageCount" | "lastUsedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["defaultKeyToModel"]>
  export type DefaultKeyToModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultKey?: boolean | DefaultKeyDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
  }

  export type $DefaultKeyToModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DefaultKeyToModel"
    objects: {
      defaultKey: Prisma.$DefaultKeyPayload<ExtArgs>
      model: Prisma.$ModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      defaultKeyId: string
      modelId: string
      status: $Enums.ApiKeyStatus
      usageCount: number
      lastUsedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["defaultKeyToModel"]>
    composites: {}
  }

  type DefaultKeyToModelGetPayload<S extends boolean | null | undefined | DefaultKeyToModelDefaultArgs> = $Result.GetResult<Prisma.$DefaultKeyToModelPayload, S>

  type DefaultKeyToModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DefaultKeyToModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DefaultKeyToModelCountAggregateInputType | true
    }

  export interface DefaultKeyToModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DefaultKeyToModel'], meta: { name: 'DefaultKeyToModel' } }
    /**
     * Find zero or one DefaultKeyToModel that matches the filter.
     * @param {DefaultKeyToModelFindUniqueArgs} args - Arguments to find a DefaultKeyToModel
     * @example
     * // Get one DefaultKeyToModel
     * const defaultKeyToModel = await prisma.defaultKeyToModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefaultKeyToModelFindUniqueArgs>(args: SelectSubset<T, DefaultKeyToModelFindUniqueArgs<ExtArgs>>): Prisma__DefaultKeyToModelClient<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DefaultKeyToModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DefaultKeyToModelFindUniqueOrThrowArgs} args - Arguments to find a DefaultKeyToModel
     * @example
     * // Get one DefaultKeyToModel
     * const defaultKeyToModel = await prisma.defaultKeyToModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefaultKeyToModelFindUniqueOrThrowArgs>(args: SelectSubset<T, DefaultKeyToModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefaultKeyToModelClient<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefaultKeyToModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyToModelFindFirstArgs} args - Arguments to find a DefaultKeyToModel
     * @example
     * // Get one DefaultKeyToModel
     * const defaultKeyToModel = await prisma.defaultKeyToModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefaultKeyToModelFindFirstArgs>(args?: SelectSubset<T, DefaultKeyToModelFindFirstArgs<ExtArgs>>): Prisma__DefaultKeyToModelClient<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefaultKeyToModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyToModelFindFirstOrThrowArgs} args - Arguments to find a DefaultKeyToModel
     * @example
     * // Get one DefaultKeyToModel
     * const defaultKeyToModel = await prisma.defaultKeyToModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefaultKeyToModelFindFirstOrThrowArgs>(args?: SelectSubset<T, DefaultKeyToModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefaultKeyToModelClient<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DefaultKeyToModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyToModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DefaultKeyToModels
     * const defaultKeyToModels = await prisma.defaultKeyToModel.findMany()
     * 
     * // Get first 10 DefaultKeyToModels
     * const defaultKeyToModels = await prisma.defaultKeyToModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defaultKeyToModelWithIdOnly = await prisma.defaultKeyToModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefaultKeyToModelFindManyArgs>(args?: SelectSubset<T, DefaultKeyToModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DefaultKeyToModel.
     * @param {DefaultKeyToModelCreateArgs} args - Arguments to create a DefaultKeyToModel.
     * @example
     * // Create one DefaultKeyToModel
     * const DefaultKeyToModel = await prisma.defaultKeyToModel.create({
     *   data: {
     *     // ... data to create a DefaultKeyToModel
     *   }
     * })
     * 
     */
    create<T extends DefaultKeyToModelCreateArgs>(args: SelectSubset<T, DefaultKeyToModelCreateArgs<ExtArgs>>): Prisma__DefaultKeyToModelClient<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DefaultKeyToModels.
     * @param {DefaultKeyToModelCreateManyArgs} args - Arguments to create many DefaultKeyToModels.
     * @example
     * // Create many DefaultKeyToModels
     * const defaultKeyToModel = await prisma.defaultKeyToModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefaultKeyToModelCreateManyArgs>(args?: SelectSubset<T, DefaultKeyToModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DefaultKeyToModel.
     * @param {DefaultKeyToModelDeleteArgs} args - Arguments to delete one DefaultKeyToModel.
     * @example
     * // Delete one DefaultKeyToModel
     * const DefaultKeyToModel = await prisma.defaultKeyToModel.delete({
     *   where: {
     *     // ... filter to delete one DefaultKeyToModel
     *   }
     * })
     * 
     */
    delete<T extends DefaultKeyToModelDeleteArgs>(args: SelectSubset<T, DefaultKeyToModelDeleteArgs<ExtArgs>>): Prisma__DefaultKeyToModelClient<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DefaultKeyToModel.
     * @param {DefaultKeyToModelUpdateArgs} args - Arguments to update one DefaultKeyToModel.
     * @example
     * // Update one DefaultKeyToModel
     * const defaultKeyToModel = await prisma.defaultKeyToModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefaultKeyToModelUpdateArgs>(args: SelectSubset<T, DefaultKeyToModelUpdateArgs<ExtArgs>>): Prisma__DefaultKeyToModelClient<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DefaultKeyToModels.
     * @param {DefaultKeyToModelDeleteManyArgs} args - Arguments to filter DefaultKeyToModels to delete.
     * @example
     * // Delete a few DefaultKeyToModels
     * const { count } = await prisma.defaultKeyToModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefaultKeyToModelDeleteManyArgs>(args?: SelectSubset<T, DefaultKeyToModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefaultKeyToModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyToModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DefaultKeyToModels
     * const defaultKeyToModel = await prisma.defaultKeyToModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefaultKeyToModelUpdateManyArgs>(args: SelectSubset<T, DefaultKeyToModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DefaultKeyToModel.
     * @param {DefaultKeyToModelUpsertArgs} args - Arguments to update or create a DefaultKeyToModel.
     * @example
     * // Update or create a DefaultKeyToModel
     * const defaultKeyToModel = await prisma.defaultKeyToModel.upsert({
     *   create: {
     *     // ... data to create a DefaultKeyToModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DefaultKeyToModel we want to update
     *   }
     * })
     */
    upsert<T extends DefaultKeyToModelUpsertArgs>(args: SelectSubset<T, DefaultKeyToModelUpsertArgs<ExtArgs>>): Prisma__DefaultKeyToModelClient<$Result.GetResult<Prisma.$DefaultKeyToModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DefaultKeyToModels that matches the filter.
     * @param {DefaultKeyToModelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const defaultKeyToModel = await prisma.defaultKeyToModel.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DefaultKeyToModelFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DefaultKeyToModel.
     * @param {DefaultKeyToModelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const defaultKeyToModel = await prisma.defaultKeyToModel.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DefaultKeyToModelAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DefaultKeyToModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyToModelCountArgs} args - Arguments to filter DefaultKeyToModels to count.
     * @example
     * // Count the number of DefaultKeyToModels
     * const count = await prisma.defaultKeyToModel.count({
     *   where: {
     *     // ... the filter for the DefaultKeyToModels we want to count
     *   }
     * })
    **/
    count<T extends DefaultKeyToModelCountArgs>(
      args?: Subset<T, DefaultKeyToModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefaultKeyToModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DefaultKeyToModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyToModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefaultKeyToModelAggregateArgs>(args: Subset<T, DefaultKeyToModelAggregateArgs>): Prisma.PrismaPromise<GetDefaultKeyToModelAggregateType<T>>

    /**
     * Group by DefaultKeyToModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultKeyToModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefaultKeyToModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefaultKeyToModelGroupByArgs['orderBy'] }
        : { orderBy?: DefaultKeyToModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefaultKeyToModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefaultKeyToModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DefaultKeyToModel model
   */
  readonly fields: DefaultKeyToModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DefaultKeyToModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefaultKeyToModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defaultKey<T extends DefaultKeyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DefaultKeyDefaultArgs<ExtArgs>>): Prisma__DefaultKeyClient<$Result.GetResult<Prisma.$DefaultKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DefaultKeyToModel model
   */
  interface DefaultKeyToModelFieldRefs {
    readonly id: FieldRef<"DefaultKeyToModel", 'String'>
    readonly defaultKeyId: FieldRef<"DefaultKeyToModel", 'String'>
    readonly modelId: FieldRef<"DefaultKeyToModel", 'String'>
    readonly status: FieldRef<"DefaultKeyToModel", 'ApiKeyStatus'>
    readonly usageCount: FieldRef<"DefaultKeyToModel", 'Int'>
    readonly lastUsedAt: FieldRef<"DefaultKeyToModel", 'DateTime'>
    readonly createdAt: FieldRef<"DefaultKeyToModel", 'DateTime'>
    readonly updatedAt: FieldRef<"DefaultKeyToModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DefaultKeyToModel findUnique
   */
  export type DefaultKeyToModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    /**
     * Filter, which DefaultKeyToModel to fetch.
     */
    where: DefaultKeyToModelWhereUniqueInput
  }

  /**
   * DefaultKeyToModel findUniqueOrThrow
   */
  export type DefaultKeyToModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    /**
     * Filter, which DefaultKeyToModel to fetch.
     */
    where: DefaultKeyToModelWhereUniqueInput
  }

  /**
   * DefaultKeyToModel findFirst
   */
  export type DefaultKeyToModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    /**
     * Filter, which DefaultKeyToModel to fetch.
     */
    where?: DefaultKeyToModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultKeyToModels to fetch.
     */
    orderBy?: DefaultKeyToModelOrderByWithRelationInput | DefaultKeyToModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultKeyToModels.
     */
    cursor?: DefaultKeyToModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultKeyToModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultKeyToModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultKeyToModels.
     */
    distinct?: DefaultKeyToModelScalarFieldEnum | DefaultKeyToModelScalarFieldEnum[]
  }

  /**
   * DefaultKeyToModel findFirstOrThrow
   */
  export type DefaultKeyToModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    /**
     * Filter, which DefaultKeyToModel to fetch.
     */
    where?: DefaultKeyToModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultKeyToModels to fetch.
     */
    orderBy?: DefaultKeyToModelOrderByWithRelationInput | DefaultKeyToModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultKeyToModels.
     */
    cursor?: DefaultKeyToModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultKeyToModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultKeyToModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultKeyToModels.
     */
    distinct?: DefaultKeyToModelScalarFieldEnum | DefaultKeyToModelScalarFieldEnum[]
  }

  /**
   * DefaultKeyToModel findMany
   */
  export type DefaultKeyToModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    /**
     * Filter, which DefaultKeyToModels to fetch.
     */
    where?: DefaultKeyToModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultKeyToModels to fetch.
     */
    orderBy?: DefaultKeyToModelOrderByWithRelationInput | DefaultKeyToModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DefaultKeyToModels.
     */
    cursor?: DefaultKeyToModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultKeyToModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultKeyToModels.
     */
    skip?: number
    distinct?: DefaultKeyToModelScalarFieldEnum | DefaultKeyToModelScalarFieldEnum[]
  }

  /**
   * DefaultKeyToModel create
   */
  export type DefaultKeyToModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    /**
     * The data needed to create a DefaultKeyToModel.
     */
    data: XOR<DefaultKeyToModelCreateInput, DefaultKeyToModelUncheckedCreateInput>
  }

  /**
   * DefaultKeyToModel createMany
   */
  export type DefaultKeyToModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DefaultKeyToModels.
     */
    data: DefaultKeyToModelCreateManyInput | DefaultKeyToModelCreateManyInput[]
  }

  /**
   * DefaultKeyToModel update
   */
  export type DefaultKeyToModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    /**
     * The data needed to update a DefaultKeyToModel.
     */
    data: XOR<DefaultKeyToModelUpdateInput, DefaultKeyToModelUncheckedUpdateInput>
    /**
     * Choose, which DefaultKeyToModel to update.
     */
    where: DefaultKeyToModelWhereUniqueInput
  }

  /**
   * DefaultKeyToModel updateMany
   */
  export type DefaultKeyToModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DefaultKeyToModels.
     */
    data: XOR<DefaultKeyToModelUpdateManyMutationInput, DefaultKeyToModelUncheckedUpdateManyInput>
    /**
     * Filter which DefaultKeyToModels to update
     */
    where?: DefaultKeyToModelWhereInput
    /**
     * Limit how many DefaultKeyToModels to update.
     */
    limit?: number
  }

  /**
   * DefaultKeyToModel upsert
   */
  export type DefaultKeyToModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    /**
     * The filter to search for the DefaultKeyToModel to update in case it exists.
     */
    where: DefaultKeyToModelWhereUniqueInput
    /**
     * In case the DefaultKeyToModel found by the `where` argument doesn't exist, create a new DefaultKeyToModel with this data.
     */
    create: XOR<DefaultKeyToModelCreateInput, DefaultKeyToModelUncheckedCreateInput>
    /**
     * In case the DefaultKeyToModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefaultKeyToModelUpdateInput, DefaultKeyToModelUncheckedUpdateInput>
  }

  /**
   * DefaultKeyToModel delete
   */
  export type DefaultKeyToModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
    /**
     * Filter which DefaultKeyToModel to delete.
     */
    where: DefaultKeyToModelWhereUniqueInput
  }

  /**
   * DefaultKeyToModel deleteMany
   */
  export type DefaultKeyToModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultKeyToModels to delete
     */
    where?: DefaultKeyToModelWhereInput
    /**
     * Limit how many DefaultKeyToModels to delete.
     */
    limit?: number
  }

  /**
   * DefaultKeyToModel findRaw
   */
  export type DefaultKeyToModelFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DefaultKeyToModel aggregateRaw
   */
  export type DefaultKeyToModelAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DefaultKeyToModel without action
   */
  export type DefaultKeyToModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultKeyToModel
     */
    select?: DefaultKeyToModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultKeyToModel
     */
    omit?: DefaultKeyToModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultKeyToModelInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    avatar: 'avatar',
    backgroundImage: 'backgroundImage',
    birthdate: 'birthdate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserLibraryStoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    author: 'author',
    storyAvatar: 'storyAvatar',
    userId: 'userId',
    totalChapters: 'totalChapters',
    isHidden: 'isHidden',
    isComplete: 'isComplete',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserLibraryStoryScalarFieldEnum = (typeof UserLibraryStoryScalarFieldEnum)[keyof typeof UserLibraryStoryScalarFieldEnum]


  export const UserLibraryChapterScalarFieldEnum: {
    id: 'id',
    chapterName: 'chapterName',
    storyId: 'storyId',
    isHidden: 'isHidden',
    chapterNumber: 'chapterNumber',
    rawText: 'rawText',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserLibraryChapterScalarFieldEnum = (typeof UserLibraryChapterScalarFieldEnum)[keyof typeof UserLibraryChapterScalarFieldEnum]


  export const UserTranslatedChapterScalarFieldEnum: {
    id: 'id',
    chapterId: 'chapterId',
    translatedTitle: 'translatedTitle',
    translatedContent: 'translatedContent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTranslatedChapterScalarFieldEnum = (typeof UserTranslatedChapterScalarFieldEnum)[keyof typeof UserTranslatedChapterScalarFieldEnum]


  export const UserTranslationVersionScalarFieldEnum: {
    id: 'id',
    translatedText: 'translatedText',
    chapterId: 'chapterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTranslationVersionScalarFieldEnum = (typeof UserTranslationVersionScalarFieldEnum)[keyof typeof UserTranslationVersionScalarFieldEnum]


  export const UserApiKeyScalarFieldEnum: {
    id: 'id',
    key: 'key',
    userId: 'userId',
    label: 'label',
    status: 'status',
    usageCount: 'usageCount',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserApiKeyScalarFieldEnum = (typeof UserApiKeyScalarFieldEnum)[keyof typeof UserApiKeyScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const ModelScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    value: 'value',
    rpm: 'rpm',
    tpm: 'tpm',
    rpd: 'rpd',
    label: 'label',
    description: 'description'
  };

  export type ModelScalarFieldEnum = (typeof ModelScalarFieldEnum)[keyof typeof ModelScalarFieldEnum]


  export const DefaultKeyScalarFieldEnum: {
    id: 'id',
    key: 'key',
    status: 'status',
    usageCount: 'usageCount',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DefaultKeyScalarFieldEnum = (typeof DefaultKeyScalarFieldEnum)[keyof typeof DefaultKeyScalarFieldEnum]


  export const DictionaryScalarFieldEnum: {
    id: 'id',
    hanTu: 'hanTu',
    pinyin: 'pinyin',
    nghiaViet: 'nghiaViet'
  };

  export type DictionaryScalarFieldEnum = (typeof DictionaryScalarFieldEnum)[keyof typeof DictionaryScalarFieldEnum]


  export const UserApiKeyToModelScalarFieldEnum: {
    id: 'id',
    userApiKeyId: 'userApiKeyId',
    modelId: 'modelId',
    status: 'status',
    usageCount: 'usageCount',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserApiKeyToModelScalarFieldEnum = (typeof UserApiKeyToModelScalarFieldEnum)[keyof typeof UserApiKeyToModelScalarFieldEnum]


  export const DefaultKeyToModelScalarFieldEnum: {
    id: 'id',
    defaultKeyId: 'defaultKeyId',
    modelId: 'modelId',
    status: 'status',
    usageCount: 'usageCount',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DefaultKeyToModelScalarFieldEnum = (typeof DefaultKeyToModelScalarFieldEnum)[keyof typeof DefaultKeyToModelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ChapterStatus'
   */
  export type EnumChapterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChapterStatus'>
    


  /**
   * Reference to a field of type 'ChapterStatus[]'
   */
  export type ListEnumChapterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChapterStatus[]'>
    


  /**
   * Reference to a field of type 'ApiKeyStatus'
   */
  export type EnumApiKeyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiKeyStatus'>
    


  /**
   * Reference to a field of type 'ApiKeyStatus[]'
   */
  export type ListEnumApiKeyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiKeyStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    backgroundImage?: StringNullableFilter<"User"> | string | null
    birthdate?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    libraryStories?: UserLibraryStoryListRelationFilter
    UserApiKey?: UserApiKeyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    backgroundImage?: SortOrder
    birthdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStories?: UserLibraryStoryOrderByRelationAggregateInput
    UserApiKey?: UserApiKeyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    backgroundImage?: StringNullableFilter<"User"> | string | null
    birthdate?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    libraryStories?: UserLibraryStoryListRelationFilter
    UserApiKey?: UserApiKeyListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    backgroundImage?: SortOrder
    birthdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    backgroundImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthdate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserLibraryStoryWhereInput = {
    AND?: UserLibraryStoryWhereInput | UserLibraryStoryWhereInput[]
    OR?: UserLibraryStoryWhereInput[]
    NOT?: UserLibraryStoryWhereInput | UserLibraryStoryWhereInput[]
    id?: StringFilter<"UserLibraryStory"> | string
    name?: StringFilter<"UserLibraryStory"> | string
    author?: StringFilter<"UserLibraryStory"> | string
    storyAvatar?: StringNullableFilter<"UserLibraryStory"> | string | null
    userId?: StringFilter<"UserLibraryStory"> | string
    totalChapters?: IntFilter<"UserLibraryStory"> | number
    isHidden?: BoolFilter<"UserLibraryStory"> | boolean
    isComplete?: BoolFilter<"UserLibraryStory"> | boolean
    createdAt?: DateTimeFilter<"UserLibraryStory"> | Date | string
    updatedAt?: DateTimeFilter<"UserLibraryStory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    chapters?: UserLibraryChapterListRelationFilter
  }

  export type UserLibraryStoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    storyAvatar?: SortOrder
    userId?: SortOrder
    totalChapters?: SortOrder
    isHidden?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    chapters?: UserLibraryChapterOrderByRelationAggregateInput
  }

  export type UserLibraryStoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserLibraryStoryWhereInput | UserLibraryStoryWhereInput[]
    OR?: UserLibraryStoryWhereInput[]
    NOT?: UserLibraryStoryWhereInput | UserLibraryStoryWhereInput[]
    name?: StringFilter<"UserLibraryStory"> | string
    author?: StringFilter<"UserLibraryStory"> | string
    storyAvatar?: StringNullableFilter<"UserLibraryStory"> | string | null
    userId?: StringFilter<"UserLibraryStory"> | string
    totalChapters?: IntFilter<"UserLibraryStory"> | number
    isHidden?: BoolFilter<"UserLibraryStory"> | boolean
    isComplete?: BoolFilter<"UserLibraryStory"> | boolean
    createdAt?: DateTimeFilter<"UserLibraryStory"> | Date | string
    updatedAt?: DateTimeFilter<"UserLibraryStory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    chapters?: UserLibraryChapterListRelationFilter
  }, "id">

  export type UserLibraryStoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    storyAvatar?: SortOrder
    userId?: SortOrder
    totalChapters?: SortOrder
    isHidden?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserLibraryStoryCountOrderByAggregateInput
    _avg?: UserLibraryStoryAvgOrderByAggregateInput
    _max?: UserLibraryStoryMaxOrderByAggregateInput
    _min?: UserLibraryStoryMinOrderByAggregateInput
    _sum?: UserLibraryStorySumOrderByAggregateInput
  }

  export type UserLibraryStoryScalarWhereWithAggregatesInput = {
    AND?: UserLibraryStoryScalarWhereWithAggregatesInput | UserLibraryStoryScalarWhereWithAggregatesInput[]
    OR?: UserLibraryStoryScalarWhereWithAggregatesInput[]
    NOT?: UserLibraryStoryScalarWhereWithAggregatesInput | UserLibraryStoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLibraryStory"> | string
    name?: StringWithAggregatesFilter<"UserLibraryStory"> | string
    author?: StringWithAggregatesFilter<"UserLibraryStory"> | string
    storyAvatar?: StringNullableWithAggregatesFilter<"UserLibraryStory"> | string | null
    userId?: StringWithAggregatesFilter<"UserLibraryStory"> | string
    totalChapters?: IntWithAggregatesFilter<"UserLibraryStory"> | number
    isHidden?: BoolWithAggregatesFilter<"UserLibraryStory"> | boolean
    isComplete?: BoolWithAggregatesFilter<"UserLibraryStory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserLibraryStory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserLibraryStory"> | Date | string
  }

  export type UserLibraryChapterWhereInput = {
    AND?: UserLibraryChapterWhereInput | UserLibraryChapterWhereInput[]
    OR?: UserLibraryChapterWhereInput[]
    NOT?: UserLibraryChapterWhereInput | UserLibraryChapterWhereInput[]
    id?: StringFilter<"UserLibraryChapter"> | string
    chapterName?: StringFilter<"UserLibraryChapter"> | string
    storyId?: StringFilter<"UserLibraryChapter"> | string
    isHidden?: BoolFilter<"UserLibraryChapter"> | boolean
    chapterNumber?: IntFilter<"UserLibraryChapter"> | number
    rawText?: StringFilter<"UserLibraryChapter"> | string
    status?: EnumChapterStatusFilter<"UserLibraryChapter"> | $Enums.ChapterStatus
    createdAt?: DateTimeFilter<"UserLibraryChapter"> | Date | string
    updatedAt?: DateTimeFilter<"UserLibraryChapter"> | Date | string
    story?: XOR<UserLibraryStoryScalarRelationFilter, UserLibraryStoryWhereInput>
    translation?: XOR<UserTranslatedChapterNullableScalarRelationFilter, UserTranslatedChapterWhereInput> | null
    versions?: UserTranslationVersionListRelationFilter
  }

  export type UserLibraryChapterOrderByWithRelationInput = {
    id?: SortOrder
    chapterName?: SortOrder
    storyId?: SortOrder
    isHidden?: SortOrder
    chapterNumber?: SortOrder
    rawText?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    story?: UserLibraryStoryOrderByWithRelationInput
    translation?: UserTranslatedChapterOrderByWithRelationInput
    versions?: UserTranslationVersionOrderByRelationAggregateInput
  }

  export type UserLibraryChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storyId_chapterNumber?: UserLibraryChapterStoryIdChapterNumberCompoundUniqueInput
    AND?: UserLibraryChapterWhereInput | UserLibraryChapterWhereInput[]
    OR?: UserLibraryChapterWhereInput[]
    NOT?: UserLibraryChapterWhereInput | UserLibraryChapterWhereInput[]
    chapterName?: StringFilter<"UserLibraryChapter"> | string
    storyId?: StringFilter<"UserLibraryChapter"> | string
    isHidden?: BoolFilter<"UserLibraryChapter"> | boolean
    chapterNumber?: IntFilter<"UserLibraryChapter"> | number
    rawText?: StringFilter<"UserLibraryChapter"> | string
    status?: EnumChapterStatusFilter<"UserLibraryChapter"> | $Enums.ChapterStatus
    createdAt?: DateTimeFilter<"UserLibraryChapter"> | Date | string
    updatedAt?: DateTimeFilter<"UserLibraryChapter"> | Date | string
    story?: XOR<UserLibraryStoryScalarRelationFilter, UserLibraryStoryWhereInput>
    translation?: XOR<UserTranslatedChapterNullableScalarRelationFilter, UserTranslatedChapterWhereInput> | null
    versions?: UserTranslationVersionListRelationFilter
  }, "id" | "storyId_chapterNumber">

  export type UserLibraryChapterOrderByWithAggregationInput = {
    id?: SortOrder
    chapterName?: SortOrder
    storyId?: SortOrder
    isHidden?: SortOrder
    chapterNumber?: SortOrder
    rawText?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserLibraryChapterCountOrderByAggregateInput
    _avg?: UserLibraryChapterAvgOrderByAggregateInput
    _max?: UserLibraryChapterMaxOrderByAggregateInput
    _min?: UserLibraryChapterMinOrderByAggregateInput
    _sum?: UserLibraryChapterSumOrderByAggregateInput
  }

  export type UserLibraryChapterScalarWhereWithAggregatesInput = {
    AND?: UserLibraryChapterScalarWhereWithAggregatesInput | UserLibraryChapterScalarWhereWithAggregatesInput[]
    OR?: UserLibraryChapterScalarWhereWithAggregatesInput[]
    NOT?: UserLibraryChapterScalarWhereWithAggregatesInput | UserLibraryChapterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLibraryChapter"> | string
    chapterName?: StringWithAggregatesFilter<"UserLibraryChapter"> | string
    storyId?: StringWithAggregatesFilter<"UserLibraryChapter"> | string
    isHidden?: BoolWithAggregatesFilter<"UserLibraryChapter"> | boolean
    chapterNumber?: IntWithAggregatesFilter<"UserLibraryChapter"> | number
    rawText?: StringWithAggregatesFilter<"UserLibraryChapter"> | string
    status?: EnumChapterStatusWithAggregatesFilter<"UserLibraryChapter"> | $Enums.ChapterStatus
    createdAt?: DateTimeWithAggregatesFilter<"UserLibraryChapter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserLibraryChapter"> | Date | string
  }

  export type UserTranslatedChapterWhereInput = {
    AND?: UserTranslatedChapterWhereInput | UserTranslatedChapterWhereInput[]
    OR?: UserTranslatedChapterWhereInput[]
    NOT?: UserTranslatedChapterWhereInput | UserTranslatedChapterWhereInput[]
    id?: StringFilter<"UserTranslatedChapter"> | string
    chapterId?: StringFilter<"UserTranslatedChapter"> | string
    translatedTitle?: StringFilter<"UserTranslatedChapter"> | string
    translatedContent?: StringFilter<"UserTranslatedChapter"> | string
    createdAt?: DateTimeFilter<"UserTranslatedChapter"> | Date | string
    updatedAt?: DateTimeFilter<"UserTranslatedChapter"> | Date | string
    chapter?: XOR<UserLibraryChapterScalarRelationFilter, UserLibraryChapterWhereInput>
  }

  export type UserTranslatedChapterOrderByWithRelationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    translatedTitle?: SortOrder
    translatedContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chapter?: UserLibraryChapterOrderByWithRelationInput
  }

  export type UserTranslatedChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chapterId?: string
    AND?: UserTranslatedChapterWhereInput | UserTranslatedChapterWhereInput[]
    OR?: UserTranslatedChapterWhereInput[]
    NOT?: UserTranslatedChapterWhereInput | UserTranslatedChapterWhereInput[]
    translatedTitle?: StringFilter<"UserTranslatedChapter"> | string
    translatedContent?: StringFilter<"UserTranslatedChapter"> | string
    createdAt?: DateTimeFilter<"UserTranslatedChapter"> | Date | string
    updatedAt?: DateTimeFilter<"UserTranslatedChapter"> | Date | string
    chapter?: XOR<UserLibraryChapterScalarRelationFilter, UserLibraryChapterWhereInput>
  }, "id" | "chapterId">

  export type UserTranslatedChapterOrderByWithAggregationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    translatedTitle?: SortOrder
    translatedContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserTranslatedChapterCountOrderByAggregateInput
    _max?: UserTranslatedChapterMaxOrderByAggregateInput
    _min?: UserTranslatedChapterMinOrderByAggregateInput
  }

  export type UserTranslatedChapterScalarWhereWithAggregatesInput = {
    AND?: UserTranslatedChapterScalarWhereWithAggregatesInput | UserTranslatedChapterScalarWhereWithAggregatesInput[]
    OR?: UserTranslatedChapterScalarWhereWithAggregatesInput[]
    NOT?: UserTranslatedChapterScalarWhereWithAggregatesInput | UserTranslatedChapterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTranslatedChapter"> | string
    chapterId?: StringWithAggregatesFilter<"UserTranslatedChapter"> | string
    translatedTitle?: StringWithAggregatesFilter<"UserTranslatedChapter"> | string
    translatedContent?: StringWithAggregatesFilter<"UserTranslatedChapter"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserTranslatedChapter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserTranslatedChapter"> | Date | string
  }

  export type UserTranslationVersionWhereInput = {
    AND?: UserTranslationVersionWhereInput | UserTranslationVersionWhereInput[]
    OR?: UserTranslationVersionWhereInput[]
    NOT?: UserTranslationVersionWhereInput | UserTranslationVersionWhereInput[]
    id?: StringFilter<"UserTranslationVersion"> | string
    translatedText?: StringFilter<"UserTranslationVersion"> | string
    chapterId?: StringFilter<"UserTranslationVersion"> | string
    createdAt?: DateTimeFilter<"UserTranslationVersion"> | Date | string
    updatedAt?: DateTimeFilter<"UserTranslationVersion"> | Date | string
    chapter?: XOR<UserLibraryChapterScalarRelationFilter, UserLibraryChapterWhereInput>
  }

  export type UserTranslationVersionOrderByWithRelationInput = {
    id?: SortOrder
    translatedText?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chapter?: UserLibraryChapterOrderByWithRelationInput
  }

  export type UserTranslationVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserTranslationVersionWhereInput | UserTranslationVersionWhereInput[]
    OR?: UserTranslationVersionWhereInput[]
    NOT?: UserTranslationVersionWhereInput | UserTranslationVersionWhereInput[]
    translatedText?: StringFilter<"UserTranslationVersion"> | string
    chapterId?: StringFilter<"UserTranslationVersion"> | string
    createdAt?: DateTimeFilter<"UserTranslationVersion"> | Date | string
    updatedAt?: DateTimeFilter<"UserTranslationVersion"> | Date | string
    chapter?: XOR<UserLibraryChapterScalarRelationFilter, UserLibraryChapterWhereInput>
  }, "id">

  export type UserTranslationVersionOrderByWithAggregationInput = {
    id?: SortOrder
    translatedText?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserTranslationVersionCountOrderByAggregateInput
    _max?: UserTranslationVersionMaxOrderByAggregateInput
    _min?: UserTranslationVersionMinOrderByAggregateInput
  }

  export type UserTranslationVersionScalarWhereWithAggregatesInput = {
    AND?: UserTranslationVersionScalarWhereWithAggregatesInput | UserTranslationVersionScalarWhereWithAggregatesInput[]
    OR?: UserTranslationVersionScalarWhereWithAggregatesInput[]
    NOT?: UserTranslationVersionScalarWhereWithAggregatesInput | UserTranslationVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTranslationVersion"> | string
    translatedText?: StringWithAggregatesFilter<"UserTranslationVersion"> | string
    chapterId?: StringWithAggregatesFilter<"UserTranslationVersion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserTranslationVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserTranslationVersion"> | Date | string
  }

  export type UserApiKeyWhereInput = {
    AND?: UserApiKeyWhereInput | UserApiKeyWhereInput[]
    OR?: UserApiKeyWhereInput[]
    NOT?: UserApiKeyWhereInput | UserApiKeyWhereInput[]
    id?: StringFilter<"UserApiKey"> | string
    key?: StringFilter<"UserApiKey"> | string
    userId?: StringFilter<"UserApiKey"> | string
    label?: StringNullableFilter<"UserApiKey"> | string | null
    status?: EnumApiKeyStatusFilter<"UserApiKey"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"UserApiKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"UserApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"UserApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"UserApiKey"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    models?: UserApiKeyToModelListRelationFilter
  }

  export type UserApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    models?: UserApiKeyToModelOrderByRelationAggregateInput
  }

  export type UserApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_key?: UserApiKeyUserIdKeyCompoundUniqueInput
    AND?: UserApiKeyWhereInput | UserApiKeyWhereInput[]
    OR?: UserApiKeyWhereInput[]
    NOT?: UserApiKeyWhereInput | UserApiKeyWhereInput[]
    key?: StringFilter<"UserApiKey"> | string
    userId?: StringFilter<"UserApiKey"> | string
    label?: StringNullableFilter<"UserApiKey"> | string | null
    status?: EnumApiKeyStatusFilter<"UserApiKey"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"UserApiKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"UserApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"UserApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"UserApiKey"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    models?: UserApiKeyToModelListRelationFilter
  }, "id" | "userId_key">

  export type UserApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserApiKeyCountOrderByAggregateInput
    _avg?: UserApiKeyAvgOrderByAggregateInput
    _max?: UserApiKeyMaxOrderByAggregateInput
    _min?: UserApiKeyMinOrderByAggregateInput
    _sum?: UserApiKeySumOrderByAggregateInput
  }

  export type UserApiKeyScalarWhereWithAggregatesInput = {
    AND?: UserApiKeyScalarWhereWithAggregatesInput | UserApiKeyScalarWhereWithAggregatesInput[]
    OR?: UserApiKeyScalarWhereWithAggregatesInput[]
    NOT?: UserApiKeyScalarWhereWithAggregatesInput | UserApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserApiKey"> | string
    key?: StringWithAggregatesFilter<"UserApiKey"> | string
    userId?: StringWithAggregatesFilter<"UserApiKey"> | string
    label?: StringNullableWithAggregatesFilter<"UserApiKey"> | string | null
    status?: EnumApiKeyStatusWithAggregatesFilter<"UserApiKey"> | $Enums.ApiKeyStatus
    usageCount?: IntWithAggregatesFilter<"UserApiKey"> | number
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"UserApiKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserApiKey"> | Date | string
  }

  export type ProviderWhereInput = {
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    id?: StringFilter<"Provider"> | string
    name?: StringFilter<"Provider"> | string
    models?: ModelListRelationFilter
  }

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    models?: ModelOrderByRelationAggregateInput
  }

  export type ProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    models?: ModelListRelationFilter
  }, "id" | "name">

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    OR?: ProviderScalarWhereWithAggregatesInput[]
    NOT?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Provider"> | string
    name?: StringWithAggregatesFilter<"Provider"> | string
  }

  export type ModelWhereInput = {
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    id?: StringFilter<"Model"> | string
    providerId?: StringFilter<"Model"> | string
    value?: StringFilter<"Model"> | string
    rpm?: IntNullableFilter<"Model"> | number | null
    tpm?: IntNullableFilter<"Model"> | number | null
    rpd?: IntNullableFilter<"Model"> | number | null
    label?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    userApiKeys?: UserApiKeyToModelListRelationFilter
    defaultKeys?: DefaultKeyToModelListRelationFilter
  }

  export type ModelOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    value?: SortOrder
    rpm?: SortOrder
    tpm?: SortOrder
    rpd?: SortOrder
    label?: SortOrder
    description?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    userApiKeys?: UserApiKeyToModelOrderByRelationAggregateInput
    defaultKeys?: DefaultKeyToModelOrderByRelationAggregateInput
  }

  export type ModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_value?: ModelProviderIdValueCompoundUniqueInput
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    providerId?: StringFilter<"Model"> | string
    value?: StringFilter<"Model"> | string
    rpm?: IntNullableFilter<"Model"> | number | null
    tpm?: IntNullableFilter<"Model"> | number | null
    rpd?: IntNullableFilter<"Model"> | number | null
    label?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    userApiKeys?: UserApiKeyToModelListRelationFilter
    defaultKeys?: DefaultKeyToModelListRelationFilter
  }, "id" | "providerId_value">

  export type ModelOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    value?: SortOrder
    rpm?: SortOrder
    tpm?: SortOrder
    rpd?: SortOrder
    label?: SortOrder
    description?: SortOrder
    _count?: ModelCountOrderByAggregateInput
    _avg?: ModelAvgOrderByAggregateInput
    _max?: ModelMaxOrderByAggregateInput
    _min?: ModelMinOrderByAggregateInput
    _sum?: ModelSumOrderByAggregateInput
  }

  export type ModelScalarWhereWithAggregatesInput = {
    AND?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    OR?: ModelScalarWhereWithAggregatesInput[]
    NOT?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Model"> | string
    providerId?: StringWithAggregatesFilter<"Model"> | string
    value?: StringWithAggregatesFilter<"Model"> | string
    rpm?: IntNullableWithAggregatesFilter<"Model"> | number | null
    tpm?: IntNullableWithAggregatesFilter<"Model"> | number | null
    rpd?: IntNullableWithAggregatesFilter<"Model"> | number | null
    label?: StringWithAggregatesFilter<"Model"> | string
    description?: StringNullableWithAggregatesFilter<"Model"> | string | null
  }

  export type DefaultKeyWhereInput = {
    AND?: DefaultKeyWhereInput | DefaultKeyWhereInput[]
    OR?: DefaultKeyWhereInput[]
    NOT?: DefaultKeyWhereInput | DefaultKeyWhereInput[]
    id?: StringFilter<"DefaultKey"> | string
    key?: StringFilter<"DefaultKey"> | string
    status?: EnumApiKeyStatusFilter<"DefaultKey"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"DefaultKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"DefaultKey"> | Date | string | null
    createdAt?: DateTimeFilter<"DefaultKey"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultKey"> | Date | string
    models?: DefaultKeyToModelListRelationFilter
  }

  export type DefaultKeyOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    models?: DefaultKeyToModelOrderByRelationAggregateInput
  }

  export type DefaultKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: DefaultKeyWhereInput | DefaultKeyWhereInput[]
    OR?: DefaultKeyWhereInput[]
    NOT?: DefaultKeyWhereInput | DefaultKeyWhereInput[]
    status?: EnumApiKeyStatusFilter<"DefaultKey"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"DefaultKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"DefaultKey"> | Date | string | null
    createdAt?: DateTimeFilter<"DefaultKey"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultKey"> | Date | string
    models?: DefaultKeyToModelListRelationFilter
  }, "id" | "key">

  export type DefaultKeyOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DefaultKeyCountOrderByAggregateInput
    _avg?: DefaultKeyAvgOrderByAggregateInput
    _max?: DefaultKeyMaxOrderByAggregateInput
    _min?: DefaultKeyMinOrderByAggregateInput
    _sum?: DefaultKeySumOrderByAggregateInput
  }

  export type DefaultKeyScalarWhereWithAggregatesInput = {
    AND?: DefaultKeyScalarWhereWithAggregatesInput | DefaultKeyScalarWhereWithAggregatesInput[]
    OR?: DefaultKeyScalarWhereWithAggregatesInput[]
    NOT?: DefaultKeyScalarWhereWithAggregatesInput | DefaultKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DefaultKey"> | string
    key?: StringWithAggregatesFilter<"DefaultKey"> | string
    status?: EnumApiKeyStatusWithAggregatesFilter<"DefaultKey"> | $Enums.ApiKeyStatus
    usageCount?: IntWithAggregatesFilter<"DefaultKey"> | number
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"DefaultKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DefaultKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DefaultKey"> | Date | string
  }

  export type DictionaryWhereInput = {
    AND?: DictionaryWhereInput | DictionaryWhereInput[]
    OR?: DictionaryWhereInput[]
    NOT?: DictionaryWhereInput | DictionaryWhereInput[]
    id?: StringFilter<"Dictionary"> | string
    hanTu?: StringFilter<"Dictionary"> | string
    pinyin?: StringNullableFilter<"Dictionary"> | string | null
    nghiaViet?: StringFilter<"Dictionary"> | string
  }

  export type DictionaryOrderByWithRelationInput = {
    id?: SortOrder
    hanTu?: SortOrder
    pinyin?: SortOrder
    nghiaViet?: SortOrder
  }

  export type DictionaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hanTu?: string
    AND?: DictionaryWhereInput | DictionaryWhereInput[]
    OR?: DictionaryWhereInput[]
    NOT?: DictionaryWhereInput | DictionaryWhereInput[]
    pinyin?: StringNullableFilter<"Dictionary"> | string | null
    nghiaViet?: StringFilter<"Dictionary"> | string
  }, "id" | "hanTu">

  export type DictionaryOrderByWithAggregationInput = {
    id?: SortOrder
    hanTu?: SortOrder
    pinyin?: SortOrder
    nghiaViet?: SortOrder
    _count?: DictionaryCountOrderByAggregateInput
    _max?: DictionaryMaxOrderByAggregateInput
    _min?: DictionaryMinOrderByAggregateInput
  }

  export type DictionaryScalarWhereWithAggregatesInput = {
    AND?: DictionaryScalarWhereWithAggregatesInput | DictionaryScalarWhereWithAggregatesInput[]
    OR?: DictionaryScalarWhereWithAggregatesInput[]
    NOT?: DictionaryScalarWhereWithAggregatesInput | DictionaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dictionary"> | string
    hanTu?: StringWithAggregatesFilter<"Dictionary"> | string
    pinyin?: StringNullableWithAggregatesFilter<"Dictionary"> | string | null
    nghiaViet?: StringWithAggregatesFilter<"Dictionary"> | string
  }

  export type UserApiKeyToModelWhereInput = {
    AND?: UserApiKeyToModelWhereInput | UserApiKeyToModelWhereInput[]
    OR?: UserApiKeyToModelWhereInput[]
    NOT?: UserApiKeyToModelWhereInput | UserApiKeyToModelWhereInput[]
    id?: StringFilter<"UserApiKeyToModel"> | string
    userApiKeyId?: StringFilter<"UserApiKeyToModel"> | string
    modelId?: StringFilter<"UserApiKeyToModel"> | string
    status?: EnumApiKeyStatusFilter<"UserApiKeyToModel"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"UserApiKeyToModel"> | number
    lastUsedAt?: DateTimeNullableFilter<"UserApiKeyToModel"> | Date | string | null
    createdAt?: DateTimeFilter<"UserApiKeyToModel"> | Date | string
    updatedAt?: DateTimeFilter<"UserApiKeyToModel"> | Date | string
    userApiKey?: XOR<UserApiKeyScalarRelationFilter, UserApiKeyWhereInput>
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
  }

  export type UserApiKeyToModelOrderByWithRelationInput = {
    id?: SortOrder
    userApiKeyId?: SortOrder
    modelId?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userApiKey?: UserApiKeyOrderByWithRelationInput
    model?: ModelOrderByWithRelationInput
  }

  export type UserApiKeyToModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userApiKeyId_modelId?: UserApiKeyToModelUserApiKeyIdModelIdCompoundUniqueInput
    AND?: UserApiKeyToModelWhereInput | UserApiKeyToModelWhereInput[]
    OR?: UserApiKeyToModelWhereInput[]
    NOT?: UserApiKeyToModelWhereInput | UserApiKeyToModelWhereInput[]
    userApiKeyId?: StringFilter<"UserApiKeyToModel"> | string
    modelId?: StringFilter<"UserApiKeyToModel"> | string
    status?: EnumApiKeyStatusFilter<"UserApiKeyToModel"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"UserApiKeyToModel"> | number
    lastUsedAt?: DateTimeNullableFilter<"UserApiKeyToModel"> | Date | string | null
    createdAt?: DateTimeFilter<"UserApiKeyToModel"> | Date | string
    updatedAt?: DateTimeFilter<"UserApiKeyToModel"> | Date | string
    userApiKey?: XOR<UserApiKeyScalarRelationFilter, UserApiKeyWhereInput>
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
  }, "id" | "userApiKeyId_modelId">

  export type UserApiKeyToModelOrderByWithAggregationInput = {
    id?: SortOrder
    userApiKeyId?: SortOrder
    modelId?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserApiKeyToModelCountOrderByAggregateInput
    _avg?: UserApiKeyToModelAvgOrderByAggregateInput
    _max?: UserApiKeyToModelMaxOrderByAggregateInput
    _min?: UserApiKeyToModelMinOrderByAggregateInput
    _sum?: UserApiKeyToModelSumOrderByAggregateInput
  }

  export type UserApiKeyToModelScalarWhereWithAggregatesInput = {
    AND?: UserApiKeyToModelScalarWhereWithAggregatesInput | UserApiKeyToModelScalarWhereWithAggregatesInput[]
    OR?: UserApiKeyToModelScalarWhereWithAggregatesInput[]
    NOT?: UserApiKeyToModelScalarWhereWithAggregatesInput | UserApiKeyToModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserApiKeyToModel"> | string
    userApiKeyId?: StringWithAggregatesFilter<"UserApiKeyToModel"> | string
    modelId?: StringWithAggregatesFilter<"UserApiKeyToModel"> | string
    status?: EnumApiKeyStatusWithAggregatesFilter<"UserApiKeyToModel"> | $Enums.ApiKeyStatus
    usageCount?: IntWithAggregatesFilter<"UserApiKeyToModel"> | number
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"UserApiKeyToModel"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserApiKeyToModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserApiKeyToModel"> | Date | string
  }

  export type DefaultKeyToModelWhereInput = {
    AND?: DefaultKeyToModelWhereInput | DefaultKeyToModelWhereInput[]
    OR?: DefaultKeyToModelWhereInput[]
    NOT?: DefaultKeyToModelWhereInput | DefaultKeyToModelWhereInput[]
    id?: StringFilter<"DefaultKeyToModel"> | string
    defaultKeyId?: StringFilter<"DefaultKeyToModel"> | string
    modelId?: StringFilter<"DefaultKeyToModel"> | string
    status?: EnumApiKeyStatusFilter<"DefaultKeyToModel"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"DefaultKeyToModel"> | number
    lastUsedAt?: DateTimeNullableFilter<"DefaultKeyToModel"> | Date | string | null
    createdAt?: DateTimeFilter<"DefaultKeyToModel"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultKeyToModel"> | Date | string
    defaultKey?: XOR<DefaultKeyScalarRelationFilter, DefaultKeyWhereInput>
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
  }

  export type DefaultKeyToModelOrderByWithRelationInput = {
    id?: SortOrder
    defaultKeyId?: SortOrder
    modelId?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaultKey?: DefaultKeyOrderByWithRelationInput
    model?: ModelOrderByWithRelationInput
  }

  export type DefaultKeyToModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    defaultKeyId_modelId?: DefaultKeyToModelDefaultKeyIdModelIdCompoundUniqueInput
    AND?: DefaultKeyToModelWhereInput | DefaultKeyToModelWhereInput[]
    OR?: DefaultKeyToModelWhereInput[]
    NOT?: DefaultKeyToModelWhereInput | DefaultKeyToModelWhereInput[]
    defaultKeyId?: StringFilter<"DefaultKeyToModel"> | string
    modelId?: StringFilter<"DefaultKeyToModel"> | string
    status?: EnumApiKeyStatusFilter<"DefaultKeyToModel"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"DefaultKeyToModel"> | number
    lastUsedAt?: DateTimeNullableFilter<"DefaultKeyToModel"> | Date | string | null
    createdAt?: DateTimeFilter<"DefaultKeyToModel"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultKeyToModel"> | Date | string
    defaultKey?: XOR<DefaultKeyScalarRelationFilter, DefaultKeyWhereInput>
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
  }, "id" | "defaultKeyId_modelId">

  export type DefaultKeyToModelOrderByWithAggregationInput = {
    id?: SortOrder
    defaultKeyId?: SortOrder
    modelId?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DefaultKeyToModelCountOrderByAggregateInput
    _avg?: DefaultKeyToModelAvgOrderByAggregateInput
    _max?: DefaultKeyToModelMaxOrderByAggregateInput
    _min?: DefaultKeyToModelMinOrderByAggregateInput
    _sum?: DefaultKeyToModelSumOrderByAggregateInput
  }

  export type DefaultKeyToModelScalarWhereWithAggregatesInput = {
    AND?: DefaultKeyToModelScalarWhereWithAggregatesInput | DefaultKeyToModelScalarWhereWithAggregatesInput[]
    OR?: DefaultKeyToModelScalarWhereWithAggregatesInput[]
    NOT?: DefaultKeyToModelScalarWhereWithAggregatesInput | DefaultKeyToModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DefaultKeyToModel"> | string
    defaultKeyId?: StringWithAggregatesFilter<"DefaultKeyToModel"> | string
    modelId?: StringWithAggregatesFilter<"DefaultKeyToModel"> | string
    status?: EnumApiKeyStatusWithAggregatesFilter<"DefaultKeyToModel"> | $Enums.ApiKeyStatus
    usageCount?: IntWithAggregatesFilter<"DefaultKeyToModel"> | number
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"DefaultKeyToModel"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DefaultKeyToModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DefaultKeyToModel"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    backgroundImage?: string | null
    birthdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStories?: UserLibraryStoryCreateNestedManyWithoutUserInput
    UserApiKey?: UserApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    backgroundImage?: string | null
    birthdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStories?: UserLibraryStoryUncheckedCreateNestedManyWithoutUserInput
    UserApiKey?: UserApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStories?: UserLibraryStoryUpdateManyWithoutUserNestedInput
    UserApiKey?: UserApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStories?: UserLibraryStoryUncheckedUpdateManyWithoutUserNestedInput
    UserApiKey?: UserApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    backgroundImage?: string | null
    birthdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryStoryCreateInput = {
    id?: string
    name: string
    author: string
    storyAvatar?: string | null
    totalChapters?: number
    isHidden?: boolean
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLibraryStoriesInput
    chapters?: UserLibraryChapterCreateNestedManyWithoutStoryInput
  }

  export type UserLibraryStoryUncheckedCreateInput = {
    id?: string
    name: string
    author: string
    storyAvatar?: string | null
    userId: string
    totalChapters?: number
    isHidden?: boolean
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: UserLibraryChapterUncheckedCreateNestedManyWithoutStoryInput
  }

  export type UserLibraryStoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    storyAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLibraryStoriesNestedInput
    chapters?: UserLibraryChapterUpdateManyWithoutStoryNestedInput
  }

  export type UserLibraryStoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    storyAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    totalChapters?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: UserLibraryChapterUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UserLibraryStoryCreateManyInput = {
    id?: string
    name: string
    author: string
    storyAvatar?: string | null
    userId: string
    totalChapters?: number
    isHidden?: boolean
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLibraryStoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    storyAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryStoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    storyAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    totalChapters?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryChapterCreateInput = {
    id?: string
    chapterName: string
    isHidden?: boolean
    chapterNumber: number
    rawText: string
    status?: $Enums.ChapterStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    story: UserLibraryStoryCreateNestedOneWithoutChaptersInput
    translation?: UserTranslatedChapterCreateNestedOneWithoutChapterInput
    versions?: UserTranslationVersionCreateNestedManyWithoutChapterInput
  }

  export type UserLibraryChapterUncheckedCreateInput = {
    id?: string
    chapterName: string
    storyId: string
    isHidden?: boolean
    chapterNumber: number
    rawText: string
    status?: $Enums.ChapterStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    translation?: UserTranslatedChapterUncheckedCreateNestedOneWithoutChapterInput
    versions?: UserTranslationVersionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type UserLibraryChapterUpdateInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: UserLibraryStoryUpdateOneRequiredWithoutChaptersNestedInput
    translation?: UserTranslatedChapterUpdateOneWithoutChapterNestedInput
    versions?: UserTranslationVersionUpdateManyWithoutChapterNestedInput
  }

  export type UserLibraryChapterUncheckedUpdateInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: UserTranslatedChapterUncheckedUpdateOneWithoutChapterNestedInput
    versions?: UserTranslationVersionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UserLibraryChapterCreateManyInput = {
    id?: string
    chapterName: string
    storyId: string
    isHidden?: boolean
    chapterNumber: number
    rawText: string
    status?: $Enums.ChapterStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLibraryChapterUpdateManyMutationInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryChapterUncheckedUpdateManyInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslatedChapterCreateInput = {
    id?: string
    translatedTitle: string
    translatedContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: UserLibraryChapterCreateNestedOneWithoutTranslationInput
  }

  export type UserTranslatedChapterUncheckedCreateInput = {
    id?: string
    chapterId: string
    translatedTitle: string
    translatedContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTranslatedChapterUpdateInput = {
    translatedTitle?: StringFieldUpdateOperationsInput | string
    translatedContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: UserLibraryChapterUpdateOneRequiredWithoutTranslationNestedInput
  }

  export type UserTranslatedChapterUncheckedUpdateInput = {
    chapterId?: StringFieldUpdateOperationsInput | string
    translatedTitle?: StringFieldUpdateOperationsInput | string
    translatedContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslatedChapterCreateManyInput = {
    id?: string
    chapterId: string
    translatedTitle: string
    translatedContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTranslatedChapterUpdateManyMutationInput = {
    translatedTitle?: StringFieldUpdateOperationsInput | string
    translatedContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslatedChapterUncheckedUpdateManyInput = {
    chapterId?: StringFieldUpdateOperationsInput | string
    translatedTitle?: StringFieldUpdateOperationsInput | string
    translatedContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslationVersionCreateInput = {
    id?: string
    translatedText: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: UserLibraryChapterCreateNestedOneWithoutVersionsInput
  }

  export type UserTranslationVersionUncheckedCreateInput = {
    id?: string
    translatedText: string
    chapterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTranslationVersionUpdateInput = {
    translatedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: UserLibraryChapterUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type UserTranslationVersionUncheckedUpdateInput = {
    translatedText?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslationVersionCreateManyInput = {
    id?: string
    translatedText: string
    chapterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTranslationVersionUpdateManyMutationInput = {
    translatedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslationVersionUncheckedUpdateManyInput = {
    translatedText?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserApiKeyCreateInput = {
    id?: string
    key: string
    label?: string | null
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserApiKeyInput
    models?: UserApiKeyToModelCreateNestedManyWithoutUserApiKeyInput
  }

  export type UserApiKeyUncheckedCreateInput = {
    id?: string
    key: string
    userId: string
    label?: string | null
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: UserApiKeyToModelUncheckedCreateNestedManyWithoutUserApiKeyInput
  }

  export type UserApiKeyUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserApiKeyNestedInput
    models?: UserApiKeyToModelUpdateManyWithoutUserApiKeyNestedInput
  }

  export type UserApiKeyUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: UserApiKeyToModelUncheckedUpdateManyWithoutUserApiKeyNestedInput
  }

  export type UserApiKeyCreateManyInput = {
    id?: string
    key: string
    userId: string
    label?: string | null
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserApiKeyUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserApiKeyUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderCreateInput = {
    id?: string
    name: string
    models?: ModelCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateInput = {
    id?: string
    name: string
    models?: ModelUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    models?: ModelUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    models?: ModelUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateManyInput = {
    id?: string
    name: string
  }

  export type ProviderUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ModelCreateInput = {
    id?: string
    value: string
    rpm?: number | null
    tpm?: number | null
    rpd?: number | null
    label: string
    description?: string | null
    provider: ProviderCreateNestedOneWithoutModelsInput
    userApiKeys?: UserApiKeyToModelCreateNestedManyWithoutModelInput
    defaultKeys?: DefaultKeyToModelCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateInput = {
    id?: string
    providerId: string
    value: string
    rpm?: number | null
    tpm?: number | null
    rpd?: number | null
    label: string
    description?: string | null
    userApiKeys?: UserApiKeyToModelUncheckedCreateNestedManyWithoutModelInput
    defaultKeys?: DefaultKeyToModelUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: ProviderUpdateOneRequiredWithoutModelsNestedInput
    userApiKeys?: UserApiKeyToModelUpdateManyWithoutModelNestedInput
    defaultKeys?: DefaultKeyToModelUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userApiKeys?: UserApiKeyToModelUncheckedUpdateManyWithoutModelNestedInput
    defaultKeys?: DefaultKeyToModelUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelCreateManyInput = {
    id?: string
    providerId: string
    value: string
    rpm?: number | null
    tpm?: number | null
    rpd?: number | null
    label: string
    description?: string | null
  }

  export type ModelUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModelUncheckedUpdateManyInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DefaultKeyCreateInput = {
    id?: string
    key: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: DefaultKeyToModelCreateNestedManyWithoutDefaultKeyInput
  }

  export type DefaultKeyUncheckedCreateInput = {
    id?: string
    key: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: DefaultKeyToModelUncheckedCreateNestedManyWithoutDefaultKeyInput
  }

  export type DefaultKeyUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: DefaultKeyToModelUpdateManyWithoutDefaultKeyNestedInput
  }

  export type DefaultKeyUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: DefaultKeyToModelUncheckedUpdateManyWithoutDefaultKeyNestedInput
  }

  export type DefaultKeyCreateManyInput = {
    id?: string
    key: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultKeyUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultKeyUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DictionaryCreateInput = {
    id?: string
    hanTu: string
    pinyin?: string | null
    nghiaViet: string
  }

  export type DictionaryUncheckedCreateInput = {
    id?: string
    hanTu: string
    pinyin?: string | null
    nghiaViet: string
  }

  export type DictionaryUpdateInput = {
    hanTu?: StringFieldUpdateOperationsInput | string
    pinyin?: NullableStringFieldUpdateOperationsInput | string | null
    nghiaViet?: StringFieldUpdateOperationsInput | string
  }

  export type DictionaryUncheckedUpdateInput = {
    hanTu?: StringFieldUpdateOperationsInput | string
    pinyin?: NullableStringFieldUpdateOperationsInput | string | null
    nghiaViet?: StringFieldUpdateOperationsInput | string
  }

  export type DictionaryCreateManyInput = {
    id?: string
    hanTu: string
    pinyin?: string | null
    nghiaViet: string
  }

  export type DictionaryUpdateManyMutationInput = {
    hanTu?: StringFieldUpdateOperationsInput | string
    pinyin?: NullableStringFieldUpdateOperationsInput | string | null
    nghiaViet?: StringFieldUpdateOperationsInput | string
  }

  export type DictionaryUncheckedUpdateManyInput = {
    hanTu?: StringFieldUpdateOperationsInput | string
    pinyin?: NullableStringFieldUpdateOperationsInput | string | null
    nghiaViet?: StringFieldUpdateOperationsInput | string
  }

  export type UserApiKeyToModelCreateInput = {
    id?: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userApiKey: UserApiKeyCreateNestedOneWithoutModelsInput
    model: ModelCreateNestedOneWithoutUserApiKeysInput
  }

  export type UserApiKeyToModelUncheckedCreateInput = {
    id?: string
    userApiKeyId: string
    modelId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserApiKeyToModelUpdateInput = {
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userApiKey?: UserApiKeyUpdateOneRequiredWithoutModelsNestedInput
    model?: ModelUpdateOneRequiredWithoutUserApiKeysNestedInput
  }

  export type UserApiKeyToModelUncheckedUpdateInput = {
    userApiKeyId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserApiKeyToModelCreateManyInput = {
    id?: string
    userApiKeyId: string
    modelId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserApiKeyToModelUpdateManyMutationInput = {
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserApiKeyToModelUncheckedUpdateManyInput = {
    userApiKeyId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultKeyToModelCreateInput = {
    id?: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultKey: DefaultKeyCreateNestedOneWithoutModelsInput
    model: ModelCreateNestedOneWithoutDefaultKeysInput
  }

  export type DefaultKeyToModelUncheckedCreateInput = {
    id?: string
    defaultKeyId: string
    modelId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultKeyToModelUpdateInput = {
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultKey?: DefaultKeyUpdateOneRequiredWithoutModelsNestedInput
    model?: ModelUpdateOneRequiredWithoutDefaultKeysNestedInput
  }

  export type DefaultKeyToModelUncheckedUpdateInput = {
    defaultKeyId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultKeyToModelCreateManyInput = {
    id?: string
    defaultKeyId: string
    modelId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultKeyToModelUpdateManyMutationInput = {
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultKeyToModelUncheckedUpdateManyInput = {
    defaultKeyId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserLibraryStoryListRelationFilter = {
    every?: UserLibraryStoryWhereInput
    some?: UserLibraryStoryWhereInput
    none?: UserLibraryStoryWhereInput
  }

  export type UserApiKeyListRelationFilter = {
    every?: UserApiKeyWhereInput
    some?: UserApiKeyWhereInput
    none?: UserApiKeyWhereInput
  }

  export type UserLibraryStoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    backgroundImage?: SortOrder
    birthdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    backgroundImage?: SortOrder
    birthdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    backgroundImage?: SortOrder
    birthdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserLibraryChapterListRelationFilter = {
    every?: UserLibraryChapterWhereInput
    some?: UserLibraryChapterWhereInput
    none?: UserLibraryChapterWhereInput
  }

  export type UserLibraryChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLibraryStoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    storyAvatar?: SortOrder
    userId?: SortOrder
    totalChapters?: SortOrder
    isHidden?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLibraryStoryAvgOrderByAggregateInput = {
    totalChapters?: SortOrder
  }

  export type UserLibraryStoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    storyAvatar?: SortOrder
    userId?: SortOrder
    totalChapters?: SortOrder
    isHidden?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLibraryStoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    storyAvatar?: SortOrder
    userId?: SortOrder
    totalChapters?: SortOrder
    isHidden?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLibraryStorySumOrderByAggregateInput = {
    totalChapters?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumChapterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusFilter<$PrismaModel> | $Enums.ChapterStatus
  }

  export type UserLibraryStoryScalarRelationFilter = {
    is?: UserLibraryStoryWhereInput
    isNot?: UserLibraryStoryWhereInput
  }

  export type UserTranslatedChapterNullableScalarRelationFilter = {
    is?: UserTranslatedChapterWhereInput | null
    isNot?: UserTranslatedChapterWhereInput | null
  }

  export type UserTranslationVersionListRelationFilter = {
    every?: UserTranslationVersionWhereInput
    some?: UserTranslationVersionWhereInput
    none?: UserTranslationVersionWhereInput
  }

  export type UserTranslationVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLibraryChapterStoryIdChapterNumberCompoundUniqueInput = {
    storyId: string
    chapterNumber: number
  }

  export type UserLibraryChapterCountOrderByAggregateInput = {
    id?: SortOrder
    chapterName?: SortOrder
    storyId?: SortOrder
    isHidden?: SortOrder
    chapterNumber?: SortOrder
    rawText?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLibraryChapterAvgOrderByAggregateInput = {
    chapterNumber?: SortOrder
  }

  export type UserLibraryChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    chapterName?: SortOrder
    storyId?: SortOrder
    isHidden?: SortOrder
    chapterNumber?: SortOrder
    rawText?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLibraryChapterMinOrderByAggregateInput = {
    id?: SortOrder
    chapterName?: SortOrder
    storyId?: SortOrder
    isHidden?: SortOrder
    chapterNumber?: SortOrder
    rawText?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLibraryChapterSumOrderByAggregateInput = {
    chapterNumber?: SortOrder
  }

  export type EnumChapterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChapterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChapterStatusFilter<$PrismaModel>
    _max?: NestedEnumChapterStatusFilter<$PrismaModel>
  }

  export type UserLibraryChapterScalarRelationFilter = {
    is?: UserLibraryChapterWhereInput
    isNot?: UserLibraryChapterWhereInput
  }

  export type UserTranslatedChapterCountOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    translatedTitle?: SortOrder
    translatedContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTranslatedChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    translatedTitle?: SortOrder
    translatedContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTranslatedChapterMinOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    translatedTitle?: SortOrder
    translatedContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTranslationVersionCountOrderByAggregateInput = {
    id?: SortOrder
    translatedText?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTranslationVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    translatedText?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTranslationVersionMinOrderByAggregateInput = {
    id?: SortOrder
    translatedText?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApiKeyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiKeyStatus | EnumApiKeyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiKeyStatus[] | ListEnumApiKeyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiKeyStatus[] | ListEnumApiKeyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiKeyStatusFilter<$PrismaModel> | $Enums.ApiKeyStatus
  }

  export type UserApiKeyToModelListRelationFilter = {
    every?: UserApiKeyToModelWhereInput
    some?: UserApiKeyToModelWhereInput
    none?: UserApiKeyToModelWhereInput
  }

  export type UserApiKeyToModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserApiKeyUserIdKeyCompoundUniqueInput = {
    userId: string
    key: string
  }

  export type UserApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserApiKeyAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type UserApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserApiKeySumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EnumApiKeyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiKeyStatus | EnumApiKeyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiKeyStatus[] | ListEnumApiKeyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiKeyStatus[] | ListEnumApiKeyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiKeyStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApiKeyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiKeyStatusFilter<$PrismaModel>
    _max?: NestedEnumApiKeyStatusFilter<$PrismaModel>
  }

  export type ModelListRelationFilter = {
    every?: ModelWhereInput
    some?: ModelWhereInput
    none?: ModelWhereInput
  }

  export type ModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type ProviderScalarRelationFilter = {
    is?: ProviderWhereInput
    isNot?: ProviderWhereInput
  }

  export type DefaultKeyToModelListRelationFilter = {
    every?: DefaultKeyToModelWhereInput
    some?: DefaultKeyToModelWhereInput
    none?: DefaultKeyToModelWhereInput
  }

  export type DefaultKeyToModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelProviderIdValueCompoundUniqueInput = {
    providerId: string
    value: string
  }

  export type ModelCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    value?: SortOrder
    rpm?: SortOrder
    tpm?: SortOrder
    rpd?: SortOrder
    label?: SortOrder
    description?: SortOrder
  }

  export type ModelAvgOrderByAggregateInput = {
    rpm?: SortOrder
    tpm?: SortOrder
    rpd?: SortOrder
  }

  export type ModelMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    value?: SortOrder
    rpm?: SortOrder
    tpm?: SortOrder
    rpd?: SortOrder
    label?: SortOrder
    description?: SortOrder
  }

  export type ModelMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    value?: SortOrder
    rpm?: SortOrder
    tpm?: SortOrder
    rpd?: SortOrder
    label?: SortOrder
    description?: SortOrder
  }

  export type ModelSumOrderByAggregateInput = {
    rpm?: SortOrder
    tpm?: SortOrder
    rpd?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DefaultKeyCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefaultKeyAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type DefaultKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefaultKeyMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefaultKeySumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type DictionaryCountOrderByAggregateInput = {
    id?: SortOrder
    hanTu?: SortOrder
    pinyin?: SortOrder
    nghiaViet?: SortOrder
  }

  export type DictionaryMaxOrderByAggregateInput = {
    id?: SortOrder
    hanTu?: SortOrder
    pinyin?: SortOrder
    nghiaViet?: SortOrder
  }

  export type DictionaryMinOrderByAggregateInput = {
    id?: SortOrder
    hanTu?: SortOrder
    pinyin?: SortOrder
    nghiaViet?: SortOrder
  }

  export type UserApiKeyScalarRelationFilter = {
    is?: UserApiKeyWhereInput
    isNot?: UserApiKeyWhereInput
  }

  export type ModelScalarRelationFilter = {
    is?: ModelWhereInput
    isNot?: ModelWhereInput
  }

  export type UserApiKeyToModelUserApiKeyIdModelIdCompoundUniqueInput = {
    userApiKeyId: string
    modelId: string
  }

  export type UserApiKeyToModelCountOrderByAggregateInput = {
    id?: SortOrder
    userApiKeyId?: SortOrder
    modelId?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserApiKeyToModelAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type UserApiKeyToModelMaxOrderByAggregateInput = {
    id?: SortOrder
    userApiKeyId?: SortOrder
    modelId?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserApiKeyToModelMinOrderByAggregateInput = {
    id?: SortOrder
    userApiKeyId?: SortOrder
    modelId?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserApiKeyToModelSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type DefaultKeyScalarRelationFilter = {
    is?: DefaultKeyWhereInput
    isNot?: DefaultKeyWhereInput
  }

  export type DefaultKeyToModelDefaultKeyIdModelIdCompoundUniqueInput = {
    defaultKeyId: string
    modelId: string
  }

  export type DefaultKeyToModelCountOrderByAggregateInput = {
    id?: SortOrder
    defaultKeyId?: SortOrder
    modelId?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefaultKeyToModelAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type DefaultKeyToModelMaxOrderByAggregateInput = {
    id?: SortOrder
    defaultKeyId?: SortOrder
    modelId?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefaultKeyToModelMinOrderByAggregateInput = {
    id?: SortOrder
    defaultKeyId?: SortOrder
    modelId?: SortOrder
    status?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefaultKeyToModelSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type UserLibraryStoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLibraryStoryCreateWithoutUserInput, UserLibraryStoryUncheckedCreateWithoutUserInput> | UserLibraryStoryCreateWithoutUserInput[] | UserLibraryStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLibraryStoryCreateOrConnectWithoutUserInput | UserLibraryStoryCreateOrConnectWithoutUserInput[]
    createMany?: UserLibraryStoryCreateManyUserInputEnvelope
    connect?: UserLibraryStoryWhereUniqueInput | UserLibraryStoryWhereUniqueInput[]
  }

  export type UserApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<UserApiKeyCreateWithoutUserInput, UserApiKeyUncheckedCreateWithoutUserInput> | UserApiKeyCreateWithoutUserInput[] | UserApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserApiKeyCreateOrConnectWithoutUserInput | UserApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: UserApiKeyCreateManyUserInputEnvelope
    connect?: UserApiKeyWhereUniqueInput | UserApiKeyWhereUniqueInput[]
  }

  export type UserLibraryStoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLibraryStoryCreateWithoutUserInput, UserLibraryStoryUncheckedCreateWithoutUserInput> | UserLibraryStoryCreateWithoutUserInput[] | UserLibraryStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLibraryStoryCreateOrConnectWithoutUserInput | UserLibraryStoryCreateOrConnectWithoutUserInput[]
    createMany?: UserLibraryStoryCreateManyUserInputEnvelope
    connect?: UserLibraryStoryWhereUniqueInput | UserLibraryStoryWhereUniqueInput[]
  }

  export type UserApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserApiKeyCreateWithoutUserInput, UserApiKeyUncheckedCreateWithoutUserInput> | UserApiKeyCreateWithoutUserInput[] | UserApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserApiKeyCreateOrConnectWithoutUserInput | UserApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: UserApiKeyCreateManyUserInputEnvelope
    connect?: UserApiKeyWhereUniqueInput | UserApiKeyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserLibraryStoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLibraryStoryCreateWithoutUserInput, UserLibraryStoryUncheckedCreateWithoutUserInput> | UserLibraryStoryCreateWithoutUserInput[] | UserLibraryStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLibraryStoryCreateOrConnectWithoutUserInput | UserLibraryStoryCreateOrConnectWithoutUserInput[]
    upsert?: UserLibraryStoryUpsertWithWhereUniqueWithoutUserInput | UserLibraryStoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLibraryStoryCreateManyUserInputEnvelope
    set?: UserLibraryStoryWhereUniqueInput | UserLibraryStoryWhereUniqueInput[]
    disconnect?: UserLibraryStoryWhereUniqueInput | UserLibraryStoryWhereUniqueInput[]
    delete?: UserLibraryStoryWhereUniqueInput | UserLibraryStoryWhereUniqueInput[]
    connect?: UserLibraryStoryWhereUniqueInput | UserLibraryStoryWhereUniqueInput[]
    update?: UserLibraryStoryUpdateWithWhereUniqueWithoutUserInput | UserLibraryStoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLibraryStoryUpdateManyWithWhereWithoutUserInput | UserLibraryStoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLibraryStoryScalarWhereInput | UserLibraryStoryScalarWhereInput[]
  }

  export type UserApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserApiKeyCreateWithoutUserInput, UserApiKeyUncheckedCreateWithoutUserInput> | UserApiKeyCreateWithoutUserInput[] | UserApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserApiKeyCreateOrConnectWithoutUserInput | UserApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: UserApiKeyUpsertWithWhereUniqueWithoutUserInput | UserApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserApiKeyCreateManyUserInputEnvelope
    set?: UserApiKeyWhereUniqueInput | UserApiKeyWhereUniqueInput[]
    disconnect?: UserApiKeyWhereUniqueInput | UserApiKeyWhereUniqueInput[]
    delete?: UserApiKeyWhereUniqueInput | UserApiKeyWhereUniqueInput[]
    connect?: UserApiKeyWhereUniqueInput | UserApiKeyWhereUniqueInput[]
    update?: UserApiKeyUpdateWithWhereUniqueWithoutUserInput | UserApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserApiKeyUpdateManyWithWhereWithoutUserInput | UserApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserApiKeyScalarWhereInput | UserApiKeyScalarWhereInput[]
  }

  export type UserLibraryStoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLibraryStoryCreateWithoutUserInput, UserLibraryStoryUncheckedCreateWithoutUserInput> | UserLibraryStoryCreateWithoutUserInput[] | UserLibraryStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLibraryStoryCreateOrConnectWithoutUserInput | UserLibraryStoryCreateOrConnectWithoutUserInput[]
    upsert?: UserLibraryStoryUpsertWithWhereUniqueWithoutUserInput | UserLibraryStoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLibraryStoryCreateManyUserInputEnvelope
    set?: UserLibraryStoryWhereUniqueInput | UserLibraryStoryWhereUniqueInput[]
    disconnect?: UserLibraryStoryWhereUniqueInput | UserLibraryStoryWhereUniqueInput[]
    delete?: UserLibraryStoryWhereUniqueInput | UserLibraryStoryWhereUniqueInput[]
    connect?: UserLibraryStoryWhereUniqueInput | UserLibraryStoryWhereUniqueInput[]
    update?: UserLibraryStoryUpdateWithWhereUniqueWithoutUserInput | UserLibraryStoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLibraryStoryUpdateManyWithWhereWithoutUserInput | UserLibraryStoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLibraryStoryScalarWhereInput | UserLibraryStoryScalarWhereInput[]
  }

  export type UserApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserApiKeyCreateWithoutUserInput, UserApiKeyUncheckedCreateWithoutUserInput> | UserApiKeyCreateWithoutUserInput[] | UserApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserApiKeyCreateOrConnectWithoutUserInput | UserApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: UserApiKeyUpsertWithWhereUniqueWithoutUserInput | UserApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserApiKeyCreateManyUserInputEnvelope
    set?: UserApiKeyWhereUniqueInput | UserApiKeyWhereUniqueInput[]
    disconnect?: UserApiKeyWhereUniqueInput | UserApiKeyWhereUniqueInput[]
    delete?: UserApiKeyWhereUniqueInput | UserApiKeyWhereUniqueInput[]
    connect?: UserApiKeyWhereUniqueInput | UserApiKeyWhereUniqueInput[]
    update?: UserApiKeyUpdateWithWhereUniqueWithoutUserInput | UserApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserApiKeyUpdateManyWithWhereWithoutUserInput | UserApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserApiKeyScalarWhereInput | UserApiKeyScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLibraryStoriesInput = {
    create?: XOR<UserCreateWithoutLibraryStoriesInput, UserUncheckedCreateWithoutLibraryStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLibraryStoriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserLibraryChapterCreateNestedManyWithoutStoryInput = {
    create?: XOR<UserLibraryChapterCreateWithoutStoryInput, UserLibraryChapterUncheckedCreateWithoutStoryInput> | UserLibraryChapterCreateWithoutStoryInput[] | UserLibraryChapterUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: UserLibraryChapterCreateOrConnectWithoutStoryInput | UserLibraryChapterCreateOrConnectWithoutStoryInput[]
    createMany?: UserLibraryChapterCreateManyStoryInputEnvelope
    connect?: UserLibraryChapterWhereUniqueInput | UserLibraryChapterWhereUniqueInput[]
  }

  export type UserLibraryChapterUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<UserLibraryChapterCreateWithoutStoryInput, UserLibraryChapterUncheckedCreateWithoutStoryInput> | UserLibraryChapterCreateWithoutStoryInput[] | UserLibraryChapterUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: UserLibraryChapterCreateOrConnectWithoutStoryInput | UserLibraryChapterCreateOrConnectWithoutStoryInput[]
    createMany?: UserLibraryChapterCreateManyStoryInputEnvelope
    connect?: UserLibraryChapterWhereUniqueInput | UserLibraryChapterWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutLibraryStoriesNestedInput = {
    create?: XOR<UserCreateWithoutLibraryStoriesInput, UserUncheckedCreateWithoutLibraryStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLibraryStoriesInput
    upsert?: UserUpsertWithoutLibraryStoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLibraryStoriesInput, UserUpdateWithoutLibraryStoriesInput>, UserUncheckedUpdateWithoutLibraryStoriesInput>
  }

  export type UserLibraryChapterUpdateManyWithoutStoryNestedInput = {
    create?: XOR<UserLibraryChapterCreateWithoutStoryInput, UserLibraryChapterUncheckedCreateWithoutStoryInput> | UserLibraryChapterCreateWithoutStoryInput[] | UserLibraryChapterUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: UserLibraryChapterCreateOrConnectWithoutStoryInput | UserLibraryChapterCreateOrConnectWithoutStoryInput[]
    upsert?: UserLibraryChapterUpsertWithWhereUniqueWithoutStoryInput | UserLibraryChapterUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: UserLibraryChapterCreateManyStoryInputEnvelope
    set?: UserLibraryChapterWhereUniqueInput | UserLibraryChapterWhereUniqueInput[]
    disconnect?: UserLibraryChapterWhereUniqueInput | UserLibraryChapterWhereUniqueInput[]
    delete?: UserLibraryChapterWhereUniqueInput | UserLibraryChapterWhereUniqueInput[]
    connect?: UserLibraryChapterWhereUniqueInput | UserLibraryChapterWhereUniqueInput[]
    update?: UserLibraryChapterUpdateWithWhereUniqueWithoutStoryInput | UserLibraryChapterUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: UserLibraryChapterUpdateManyWithWhereWithoutStoryInput | UserLibraryChapterUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: UserLibraryChapterScalarWhereInput | UserLibraryChapterScalarWhereInput[]
  }

  export type UserLibraryChapterUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<UserLibraryChapterCreateWithoutStoryInput, UserLibraryChapterUncheckedCreateWithoutStoryInput> | UserLibraryChapterCreateWithoutStoryInput[] | UserLibraryChapterUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: UserLibraryChapterCreateOrConnectWithoutStoryInput | UserLibraryChapterCreateOrConnectWithoutStoryInput[]
    upsert?: UserLibraryChapterUpsertWithWhereUniqueWithoutStoryInput | UserLibraryChapterUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: UserLibraryChapterCreateManyStoryInputEnvelope
    set?: UserLibraryChapterWhereUniqueInput | UserLibraryChapterWhereUniqueInput[]
    disconnect?: UserLibraryChapterWhereUniqueInput | UserLibraryChapterWhereUniqueInput[]
    delete?: UserLibraryChapterWhereUniqueInput | UserLibraryChapterWhereUniqueInput[]
    connect?: UserLibraryChapterWhereUniqueInput | UserLibraryChapterWhereUniqueInput[]
    update?: UserLibraryChapterUpdateWithWhereUniqueWithoutStoryInput | UserLibraryChapterUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: UserLibraryChapterUpdateManyWithWhereWithoutStoryInput | UserLibraryChapterUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: UserLibraryChapterScalarWhereInput | UserLibraryChapterScalarWhereInput[]
  }

  export type UserLibraryStoryCreateNestedOneWithoutChaptersInput = {
    create?: XOR<UserLibraryStoryCreateWithoutChaptersInput, UserLibraryStoryUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: UserLibraryStoryCreateOrConnectWithoutChaptersInput
    connect?: UserLibraryStoryWhereUniqueInput
  }

  export type UserTranslatedChapterCreateNestedOneWithoutChapterInput = {
    create?: XOR<UserTranslatedChapterCreateWithoutChapterInput, UserTranslatedChapterUncheckedCreateWithoutChapterInput>
    connectOrCreate?: UserTranslatedChapterCreateOrConnectWithoutChapterInput
    connect?: UserTranslatedChapterWhereUniqueInput
  }

  export type UserTranslationVersionCreateNestedManyWithoutChapterInput = {
    create?: XOR<UserTranslationVersionCreateWithoutChapterInput, UserTranslationVersionUncheckedCreateWithoutChapterInput> | UserTranslationVersionCreateWithoutChapterInput[] | UserTranslationVersionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: UserTranslationVersionCreateOrConnectWithoutChapterInput | UserTranslationVersionCreateOrConnectWithoutChapterInput[]
    createMany?: UserTranslationVersionCreateManyChapterInputEnvelope
    connect?: UserTranslationVersionWhereUniqueInput | UserTranslationVersionWhereUniqueInput[]
  }

  export type UserTranslatedChapterUncheckedCreateNestedOneWithoutChapterInput = {
    create?: XOR<UserTranslatedChapterCreateWithoutChapterInput, UserTranslatedChapterUncheckedCreateWithoutChapterInput>
    connectOrCreate?: UserTranslatedChapterCreateOrConnectWithoutChapterInput
    connect?: UserTranslatedChapterWhereUniqueInput
  }

  export type UserTranslationVersionUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<UserTranslationVersionCreateWithoutChapterInput, UserTranslationVersionUncheckedCreateWithoutChapterInput> | UserTranslationVersionCreateWithoutChapterInput[] | UserTranslationVersionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: UserTranslationVersionCreateOrConnectWithoutChapterInput | UserTranslationVersionCreateOrConnectWithoutChapterInput[]
    createMany?: UserTranslationVersionCreateManyChapterInputEnvelope
    connect?: UserTranslationVersionWhereUniqueInput | UserTranslationVersionWhereUniqueInput[]
  }

  export type EnumChapterStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChapterStatus
  }

  export type UserLibraryStoryUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<UserLibraryStoryCreateWithoutChaptersInput, UserLibraryStoryUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: UserLibraryStoryCreateOrConnectWithoutChaptersInput
    upsert?: UserLibraryStoryUpsertWithoutChaptersInput
    connect?: UserLibraryStoryWhereUniqueInput
    update?: XOR<XOR<UserLibraryStoryUpdateToOneWithWhereWithoutChaptersInput, UserLibraryStoryUpdateWithoutChaptersInput>, UserLibraryStoryUncheckedUpdateWithoutChaptersInput>
  }

  export type UserTranslatedChapterUpdateOneWithoutChapterNestedInput = {
    create?: XOR<UserTranslatedChapterCreateWithoutChapterInput, UserTranslatedChapterUncheckedCreateWithoutChapterInput>
    connectOrCreate?: UserTranslatedChapterCreateOrConnectWithoutChapterInput
    upsert?: UserTranslatedChapterUpsertWithoutChapterInput
    disconnect?: UserTranslatedChapterWhereInput | boolean
    delete?: UserTranslatedChapterWhereInput | boolean
    connect?: UserTranslatedChapterWhereUniqueInput
    update?: XOR<XOR<UserTranslatedChapterUpdateToOneWithWhereWithoutChapterInput, UserTranslatedChapterUpdateWithoutChapterInput>, UserTranslatedChapterUncheckedUpdateWithoutChapterInput>
  }

  export type UserTranslationVersionUpdateManyWithoutChapterNestedInput = {
    create?: XOR<UserTranslationVersionCreateWithoutChapterInput, UserTranslationVersionUncheckedCreateWithoutChapterInput> | UserTranslationVersionCreateWithoutChapterInput[] | UserTranslationVersionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: UserTranslationVersionCreateOrConnectWithoutChapterInput | UserTranslationVersionCreateOrConnectWithoutChapterInput[]
    upsert?: UserTranslationVersionUpsertWithWhereUniqueWithoutChapterInput | UserTranslationVersionUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: UserTranslationVersionCreateManyChapterInputEnvelope
    set?: UserTranslationVersionWhereUniqueInput | UserTranslationVersionWhereUniqueInput[]
    disconnect?: UserTranslationVersionWhereUniqueInput | UserTranslationVersionWhereUniqueInput[]
    delete?: UserTranslationVersionWhereUniqueInput | UserTranslationVersionWhereUniqueInput[]
    connect?: UserTranslationVersionWhereUniqueInput | UserTranslationVersionWhereUniqueInput[]
    update?: UserTranslationVersionUpdateWithWhereUniqueWithoutChapterInput | UserTranslationVersionUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: UserTranslationVersionUpdateManyWithWhereWithoutChapterInput | UserTranslationVersionUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: UserTranslationVersionScalarWhereInput | UserTranslationVersionScalarWhereInput[]
  }

  export type UserTranslatedChapterUncheckedUpdateOneWithoutChapterNestedInput = {
    create?: XOR<UserTranslatedChapterCreateWithoutChapterInput, UserTranslatedChapterUncheckedCreateWithoutChapterInput>
    connectOrCreate?: UserTranslatedChapterCreateOrConnectWithoutChapterInput
    upsert?: UserTranslatedChapterUpsertWithoutChapterInput
    disconnect?: UserTranslatedChapterWhereInput | boolean
    delete?: UserTranslatedChapterWhereInput | boolean
    connect?: UserTranslatedChapterWhereUniqueInput
    update?: XOR<XOR<UserTranslatedChapterUpdateToOneWithWhereWithoutChapterInput, UserTranslatedChapterUpdateWithoutChapterInput>, UserTranslatedChapterUncheckedUpdateWithoutChapterInput>
  }

  export type UserTranslationVersionUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<UserTranslationVersionCreateWithoutChapterInput, UserTranslationVersionUncheckedCreateWithoutChapterInput> | UserTranslationVersionCreateWithoutChapterInput[] | UserTranslationVersionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: UserTranslationVersionCreateOrConnectWithoutChapterInput | UserTranslationVersionCreateOrConnectWithoutChapterInput[]
    upsert?: UserTranslationVersionUpsertWithWhereUniqueWithoutChapterInput | UserTranslationVersionUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: UserTranslationVersionCreateManyChapterInputEnvelope
    set?: UserTranslationVersionWhereUniqueInput | UserTranslationVersionWhereUniqueInput[]
    disconnect?: UserTranslationVersionWhereUniqueInput | UserTranslationVersionWhereUniqueInput[]
    delete?: UserTranslationVersionWhereUniqueInput | UserTranslationVersionWhereUniqueInput[]
    connect?: UserTranslationVersionWhereUniqueInput | UserTranslationVersionWhereUniqueInput[]
    update?: UserTranslationVersionUpdateWithWhereUniqueWithoutChapterInput | UserTranslationVersionUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: UserTranslationVersionUpdateManyWithWhereWithoutChapterInput | UserTranslationVersionUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: UserTranslationVersionScalarWhereInput | UserTranslationVersionScalarWhereInput[]
  }

  export type UserLibraryChapterCreateNestedOneWithoutTranslationInput = {
    create?: XOR<UserLibraryChapterCreateWithoutTranslationInput, UserLibraryChapterUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: UserLibraryChapterCreateOrConnectWithoutTranslationInput
    connect?: UserLibraryChapterWhereUniqueInput
  }

  export type UserLibraryChapterUpdateOneRequiredWithoutTranslationNestedInput = {
    create?: XOR<UserLibraryChapterCreateWithoutTranslationInput, UserLibraryChapterUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: UserLibraryChapterCreateOrConnectWithoutTranslationInput
    upsert?: UserLibraryChapterUpsertWithoutTranslationInput
    connect?: UserLibraryChapterWhereUniqueInput
    update?: XOR<XOR<UserLibraryChapterUpdateToOneWithWhereWithoutTranslationInput, UserLibraryChapterUpdateWithoutTranslationInput>, UserLibraryChapterUncheckedUpdateWithoutTranslationInput>
  }

  export type UserLibraryChapterCreateNestedOneWithoutVersionsInput = {
    create?: XOR<UserLibraryChapterCreateWithoutVersionsInput, UserLibraryChapterUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: UserLibraryChapterCreateOrConnectWithoutVersionsInput
    connect?: UserLibraryChapterWhereUniqueInput
  }

  export type UserLibraryChapterUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<UserLibraryChapterCreateWithoutVersionsInput, UserLibraryChapterUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: UserLibraryChapterCreateOrConnectWithoutVersionsInput
    upsert?: UserLibraryChapterUpsertWithoutVersionsInput
    connect?: UserLibraryChapterWhereUniqueInput
    update?: XOR<XOR<UserLibraryChapterUpdateToOneWithWhereWithoutVersionsInput, UserLibraryChapterUpdateWithoutVersionsInput>, UserLibraryChapterUncheckedUpdateWithoutVersionsInput>
  }

  export type UserCreateNestedOneWithoutUserApiKeyInput = {
    create?: XOR<UserCreateWithoutUserApiKeyInput, UserUncheckedCreateWithoutUserApiKeyInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserApiKeyInput
    connect?: UserWhereUniqueInput
  }

  export type UserApiKeyToModelCreateNestedManyWithoutUserApiKeyInput = {
    create?: XOR<UserApiKeyToModelCreateWithoutUserApiKeyInput, UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput> | UserApiKeyToModelCreateWithoutUserApiKeyInput[] | UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput[]
    connectOrCreate?: UserApiKeyToModelCreateOrConnectWithoutUserApiKeyInput | UserApiKeyToModelCreateOrConnectWithoutUserApiKeyInput[]
    createMany?: UserApiKeyToModelCreateManyUserApiKeyInputEnvelope
    connect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
  }

  export type UserApiKeyToModelUncheckedCreateNestedManyWithoutUserApiKeyInput = {
    create?: XOR<UserApiKeyToModelCreateWithoutUserApiKeyInput, UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput> | UserApiKeyToModelCreateWithoutUserApiKeyInput[] | UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput[]
    connectOrCreate?: UserApiKeyToModelCreateOrConnectWithoutUserApiKeyInput | UserApiKeyToModelCreateOrConnectWithoutUserApiKeyInput[]
    createMany?: UserApiKeyToModelCreateManyUserApiKeyInputEnvelope
    connect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
  }

  export type EnumApiKeyStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApiKeyStatus
  }

  export type UserUpdateOneRequiredWithoutUserApiKeyNestedInput = {
    create?: XOR<UserCreateWithoutUserApiKeyInput, UserUncheckedCreateWithoutUserApiKeyInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserApiKeyInput
    upsert?: UserUpsertWithoutUserApiKeyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserApiKeyInput, UserUpdateWithoutUserApiKeyInput>, UserUncheckedUpdateWithoutUserApiKeyInput>
  }

  export type UserApiKeyToModelUpdateManyWithoutUserApiKeyNestedInput = {
    create?: XOR<UserApiKeyToModelCreateWithoutUserApiKeyInput, UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput> | UserApiKeyToModelCreateWithoutUserApiKeyInput[] | UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput[]
    connectOrCreate?: UserApiKeyToModelCreateOrConnectWithoutUserApiKeyInput | UserApiKeyToModelCreateOrConnectWithoutUserApiKeyInput[]
    upsert?: UserApiKeyToModelUpsertWithWhereUniqueWithoutUserApiKeyInput | UserApiKeyToModelUpsertWithWhereUniqueWithoutUserApiKeyInput[]
    createMany?: UserApiKeyToModelCreateManyUserApiKeyInputEnvelope
    set?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    disconnect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    delete?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    connect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    update?: UserApiKeyToModelUpdateWithWhereUniqueWithoutUserApiKeyInput | UserApiKeyToModelUpdateWithWhereUniqueWithoutUserApiKeyInput[]
    updateMany?: UserApiKeyToModelUpdateManyWithWhereWithoutUserApiKeyInput | UserApiKeyToModelUpdateManyWithWhereWithoutUserApiKeyInput[]
    deleteMany?: UserApiKeyToModelScalarWhereInput | UserApiKeyToModelScalarWhereInput[]
  }

  export type UserApiKeyToModelUncheckedUpdateManyWithoutUserApiKeyNestedInput = {
    create?: XOR<UserApiKeyToModelCreateWithoutUserApiKeyInput, UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput> | UserApiKeyToModelCreateWithoutUserApiKeyInput[] | UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput[]
    connectOrCreate?: UserApiKeyToModelCreateOrConnectWithoutUserApiKeyInput | UserApiKeyToModelCreateOrConnectWithoutUserApiKeyInput[]
    upsert?: UserApiKeyToModelUpsertWithWhereUniqueWithoutUserApiKeyInput | UserApiKeyToModelUpsertWithWhereUniqueWithoutUserApiKeyInput[]
    createMany?: UserApiKeyToModelCreateManyUserApiKeyInputEnvelope
    set?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    disconnect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    delete?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    connect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    update?: UserApiKeyToModelUpdateWithWhereUniqueWithoutUserApiKeyInput | UserApiKeyToModelUpdateWithWhereUniqueWithoutUserApiKeyInput[]
    updateMany?: UserApiKeyToModelUpdateManyWithWhereWithoutUserApiKeyInput | UserApiKeyToModelUpdateManyWithWhereWithoutUserApiKeyInput[]
    deleteMany?: UserApiKeyToModelScalarWhereInput | UserApiKeyToModelScalarWhereInput[]
  }

  export type ModelCreateNestedManyWithoutProviderInput = {
    create?: XOR<ModelCreateWithoutProviderInput, ModelUncheckedCreateWithoutProviderInput> | ModelCreateWithoutProviderInput[] | ModelUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutProviderInput | ModelCreateOrConnectWithoutProviderInput[]
    createMany?: ModelCreateManyProviderInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type ModelUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ModelCreateWithoutProviderInput, ModelUncheckedCreateWithoutProviderInput> | ModelCreateWithoutProviderInput[] | ModelUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutProviderInput | ModelCreateOrConnectWithoutProviderInput[]
    createMany?: ModelCreateManyProviderInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type ModelUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ModelCreateWithoutProviderInput, ModelUncheckedCreateWithoutProviderInput> | ModelCreateWithoutProviderInput[] | ModelUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutProviderInput | ModelCreateOrConnectWithoutProviderInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutProviderInput | ModelUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ModelCreateManyProviderInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutProviderInput | ModelUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutProviderInput | ModelUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type ModelUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ModelCreateWithoutProviderInput, ModelUncheckedCreateWithoutProviderInput> | ModelCreateWithoutProviderInput[] | ModelUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutProviderInput | ModelCreateOrConnectWithoutProviderInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutProviderInput | ModelUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ModelCreateManyProviderInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutProviderInput | ModelUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutProviderInput | ModelUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type ProviderCreateNestedOneWithoutModelsInput = {
    create?: XOR<ProviderCreateWithoutModelsInput, ProviderUncheckedCreateWithoutModelsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutModelsInput
    connect?: ProviderWhereUniqueInput
  }

  export type UserApiKeyToModelCreateNestedManyWithoutModelInput = {
    create?: XOR<UserApiKeyToModelCreateWithoutModelInput, UserApiKeyToModelUncheckedCreateWithoutModelInput> | UserApiKeyToModelCreateWithoutModelInput[] | UserApiKeyToModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: UserApiKeyToModelCreateOrConnectWithoutModelInput | UserApiKeyToModelCreateOrConnectWithoutModelInput[]
    createMany?: UserApiKeyToModelCreateManyModelInputEnvelope
    connect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
  }

  export type DefaultKeyToModelCreateNestedManyWithoutModelInput = {
    create?: XOR<DefaultKeyToModelCreateWithoutModelInput, DefaultKeyToModelUncheckedCreateWithoutModelInput> | DefaultKeyToModelCreateWithoutModelInput[] | DefaultKeyToModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: DefaultKeyToModelCreateOrConnectWithoutModelInput | DefaultKeyToModelCreateOrConnectWithoutModelInput[]
    createMany?: DefaultKeyToModelCreateManyModelInputEnvelope
    connect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
  }

  export type UserApiKeyToModelUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<UserApiKeyToModelCreateWithoutModelInput, UserApiKeyToModelUncheckedCreateWithoutModelInput> | UserApiKeyToModelCreateWithoutModelInput[] | UserApiKeyToModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: UserApiKeyToModelCreateOrConnectWithoutModelInput | UserApiKeyToModelCreateOrConnectWithoutModelInput[]
    createMany?: UserApiKeyToModelCreateManyModelInputEnvelope
    connect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
  }

  export type DefaultKeyToModelUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<DefaultKeyToModelCreateWithoutModelInput, DefaultKeyToModelUncheckedCreateWithoutModelInput> | DefaultKeyToModelCreateWithoutModelInput[] | DefaultKeyToModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: DefaultKeyToModelCreateOrConnectWithoutModelInput | DefaultKeyToModelCreateOrConnectWithoutModelInput[]
    createMany?: DefaultKeyToModelCreateManyModelInputEnvelope
    connect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type ProviderUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<ProviderCreateWithoutModelsInput, ProviderUncheckedCreateWithoutModelsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutModelsInput
    upsert?: ProviderUpsertWithoutModelsInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutModelsInput, ProviderUpdateWithoutModelsInput>, ProviderUncheckedUpdateWithoutModelsInput>
  }

  export type UserApiKeyToModelUpdateManyWithoutModelNestedInput = {
    create?: XOR<UserApiKeyToModelCreateWithoutModelInput, UserApiKeyToModelUncheckedCreateWithoutModelInput> | UserApiKeyToModelCreateWithoutModelInput[] | UserApiKeyToModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: UserApiKeyToModelCreateOrConnectWithoutModelInput | UserApiKeyToModelCreateOrConnectWithoutModelInput[]
    upsert?: UserApiKeyToModelUpsertWithWhereUniqueWithoutModelInput | UserApiKeyToModelUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: UserApiKeyToModelCreateManyModelInputEnvelope
    set?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    disconnect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    delete?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    connect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    update?: UserApiKeyToModelUpdateWithWhereUniqueWithoutModelInput | UserApiKeyToModelUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: UserApiKeyToModelUpdateManyWithWhereWithoutModelInput | UserApiKeyToModelUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: UserApiKeyToModelScalarWhereInput | UserApiKeyToModelScalarWhereInput[]
  }

  export type DefaultKeyToModelUpdateManyWithoutModelNestedInput = {
    create?: XOR<DefaultKeyToModelCreateWithoutModelInput, DefaultKeyToModelUncheckedCreateWithoutModelInput> | DefaultKeyToModelCreateWithoutModelInput[] | DefaultKeyToModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: DefaultKeyToModelCreateOrConnectWithoutModelInput | DefaultKeyToModelCreateOrConnectWithoutModelInput[]
    upsert?: DefaultKeyToModelUpsertWithWhereUniqueWithoutModelInput | DefaultKeyToModelUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: DefaultKeyToModelCreateManyModelInputEnvelope
    set?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    disconnect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    delete?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    connect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    update?: DefaultKeyToModelUpdateWithWhereUniqueWithoutModelInput | DefaultKeyToModelUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: DefaultKeyToModelUpdateManyWithWhereWithoutModelInput | DefaultKeyToModelUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: DefaultKeyToModelScalarWhereInput | DefaultKeyToModelScalarWhereInput[]
  }

  export type UserApiKeyToModelUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<UserApiKeyToModelCreateWithoutModelInput, UserApiKeyToModelUncheckedCreateWithoutModelInput> | UserApiKeyToModelCreateWithoutModelInput[] | UserApiKeyToModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: UserApiKeyToModelCreateOrConnectWithoutModelInput | UserApiKeyToModelCreateOrConnectWithoutModelInput[]
    upsert?: UserApiKeyToModelUpsertWithWhereUniqueWithoutModelInput | UserApiKeyToModelUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: UserApiKeyToModelCreateManyModelInputEnvelope
    set?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    disconnect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    delete?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    connect?: UserApiKeyToModelWhereUniqueInput | UserApiKeyToModelWhereUniqueInput[]
    update?: UserApiKeyToModelUpdateWithWhereUniqueWithoutModelInput | UserApiKeyToModelUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: UserApiKeyToModelUpdateManyWithWhereWithoutModelInput | UserApiKeyToModelUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: UserApiKeyToModelScalarWhereInput | UserApiKeyToModelScalarWhereInput[]
  }

  export type DefaultKeyToModelUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<DefaultKeyToModelCreateWithoutModelInput, DefaultKeyToModelUncheckedCreateWithoutModelInput> | DefaultKeyToModelCreateWithoutModelInput[] | DefaultKeyToModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: DefaultKeyToModelCreateOrConnectWithoutModelInput | DefaultKeyToModelCreateOrConnectWithoutModelInput[]
    upsert?: DefaultKeyToModelUpsertWithWhereUniqueWithoutModelInput | DefaultKeyToModelUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: DefaultKeyToModelCreateManyModelInputEnvelope
    set?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    disconnect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    delete?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    connect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    update?: DefaultKeyToModelUpdateWithWhereUniqueWithoutModelInput | DefaultKeyToModelUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: DefaultKeyToModelUpdateManyWithWhereWithoutModelInput | DefaultKeyToModelUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: DefaultKeyToModelScalarWhereInput | DefaultKeyToModelScalarWhereInput[]
  }

  export type DefaultKeyToModelCreateNestedManyWithoutDefaultKeyInput = {
    create?: XOR<DefaultKeyToModelCreateWithoutDefaultKeyInput, DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput> | DefaultKeyToModelCreateWithoutDefaultKeyInput[] | DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput[]
    connectOrCreate?: DefaultKeyToModelCreateOrConnectWithoutDefaultKeyInput | DefaultKeyToModelCreateOrConnectWithoutDefaultKeyInput[]
    createMany?: DefaultKeyToModelCreateManyDefaultKeyInputEnvelope
    connect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
  }

  export type DefaultKeyToModelUncheckedCreateNestedManyWithoutDefaultKeyInput = {
    create?: XOR<DefaultKeyToModelCreateWithoutDefaultKeyInput, DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput> | DefaultKeyToModelCreateWithoutDefaultKeyInput[] | DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput[]
    connectOrCreate?: DefaultKeyToModelCreateOrConnectWithoutDefaultKeyInput | DefaultKeyToModelCreateOrConnectWithoutDefaultKeyInput[]
    createMany?: DefaultKeyToModelCreateManyDefaultKeyInputEnvelope
    connect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
  }

  export type DefaultKeyToModelUpdateManyWithoutDefaultKeyNestedInput = {
    create?: XOR<DefaultKeyToModelCreateWithoutDefaultKeyInput, DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput> | DefaultKeyToModelCreateWithoutDefaultKeyInput[] | DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput[]
    connectOrCreate?: DefaultKeyToModelCreateOrConnectWithoutDefaultKeyInput | DefaultKeyToModelCreateOrConnectWithoutDefaultKeyInput[]
    upsert?: DefaultKeyToModelUpsertWithWhereUniqueWithoutDefaultKeyInput | DefaultKeyToModelUpsertWithWhereUniqueWithoutDefaultKeyInput[]
    createMany?: DefaultKeyToModelCreateManyDefaultKeyInputEnvelope
    set?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    disconnect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    delete?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    connect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    update?: DefaultKeyToModelUpdateWithWhereUniqueWithoutDefaultKeyInput | DefaultKeyToModelUpdateWithWhereUniqueWithoutDefaultKeyInput[]
    updateMany?: DefaultKeyToModelUpdateManyWithWhereWithoutDefaultKeyInput | DefaultKeyToModelUpdateManyWithWhereWithoutDefaultKeyInput[]
    deleteMany?: DefaultKeyToModelScalarWhereInput | DefaultKeyToModelScalarWhereInput[]
  }

  export type DefaultKeyToModelUncheckedUpdateManyWithoutDefaultKeyNestedInput = {
    create?: XOR<DefaultKeyToModelCreateWithoutDefaultKeyInput, DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput> | DefaultKeyToModelCreateWithoutDefaultKeyInput[] | DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput[]
    connectOrCreate?: DefaultKeyToModelCreateOrConnectWithoutDefaultKeyInput | DefaultKeyToModelCreateOrConnectWithoutDefaultKeyInput[]
    upsert?: DefaultKeyToModelUpsertWithWhereUniqueWithoutDefaultKeyInput | DefaultKeyToModelUpsertWithWhereUniqueWithoutDefaultKeyInput[]
    createMany?: DefaultKeyToModelCreateManyDefaultKeyInputEnvelope
    set?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    disconnect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    delete?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    connect?: DefaultKeyToModelWhereUniqueInput | DefaultKeyToModelWhereUniqueInput[]
    update?: DefaultKeyToModelUpdateWithWhereUniqueWithoutDefaultKeyInput | DefaultKeyToModelUpdateWithWhereUniqueWithoutDefaultKeyInput[]
    updateMany?: DefaultKeyToModelUpdateManyWithWhereWithoutDefaultKeyInput | DefaultKeyToModelUpdateManyWithWhereWithoutDefaultKeyInput[]
    deleteMany?: DefaultKeyToModelScalarWhereInput | DefaultKeyToModelScalarWhereInput[]
  }

  export type UserApiKeyCreateNestedOneWithoutModelsInput = {
    create?: XOR<UserApiKeyCreateWithoutModelsInput, UserApiKeyUncheckedCreateWithoutModelsInput>
    connectOrCreate?: UserApiKeyCreateOrConnectWithoutModelsInput
    connect?: UserApiKeyWhereUniqueInput
  }

  export type ModelCreateNestedOneWithoutUserApiKeysInput = {
    create?: XOR<ModelCreateWithoutUserApiKeysInput, ModelUncheckedCreateWithoutUserApiKeysInput>
    connectOrCreate?: ModelCreateOrConnectWithoutUserApiKeysInput
    connect?: ModelWhereUniqueInput
  }

  export type UserApiKeyUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<UserApiKeyCreateWithoutModelsInput, UserApiKeyUncheckedCreateWithoutModelsInput>
    connectOrCreate?: UserApiKeyCreateOrConnectWithoutModelsInput
    upsert?: UserApiKeyUpsertWithoutModelsInput
    connect?: UserApiKeyWhereUniqueInput
    update?: XOR<XOR<UserApiKeyUpdateToOneWithWhereWithoutModelsInput, UserApiKeyUpdateWithoutModelsInput>, UserApiKeyUncheckedUpdateWithoutModelsInput>
  }

  export type ModelUpdateOneRequiredWithoutUserApiKeysNestedInput = {
    create?: XOR<ModelCreateWithoutUserApiKeysInput, ModelUncheckedCreateWithoutUserApiKeysInput>
    connectOrCreate?: ModelCreateOrConnectWithoutUserApiKeysInput
    upsert?: ModelUpsertWithoutUserApiKeysInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutUserApiKeysInput, ModelUpdateWithoutUserApiKeysInput>, ModelUncheckedUpdateWithoutUserApiKeysInput>
  }

  export type DefaultKeyCreateNestedOneWithoutModelsInput = {
    create?: XOR<DefaultKeyCreateWithoutModelsInput, DefaultKeyUncheckedCreateWithoutModelsInput>
    connectOrCreate?: DefaultKeyCreateOrConnectWithoutModelsInput
    connect?: DefaultKeyWhereUniqueInput
  }

  export type ModelCreateNestedOneWithoutDefaultKeysInput = {
    create?: XOR<ModelCreateWithoutDefaultKeysInput, ModelUncheckedCreateWithoutDefaultKeysInput>
    connectOrCreate?: ModelCreateOrConnectWithoutDefaultKeysInput
    connect?: ModelWhereUniqueInput
  }

  export type DefaultKeyUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<DefaultKeyCreateWithoutModelsInput, DefaultKeyUncheckedCreateWithoutModelsInput>
    connectOrCreate?: DefaultKeyCreateOrConnectWithoutModelsInput
    upsert?: DefaultKeyUpsertWithoutModelsInput
    connect?: DefaultKeyWhereUniqueInput
    update?: XOR<XOR<DefaultKeyUpdateToOneWithWhereWithoutModelsInput, DefaultKeyUpdateWithoutModelsInput>, DefaultKeyUncheckedUpdateWithoutModelsInput>
  }

  export type ModelUpdateOneRequiredWithoutDefaultKeysNestedInput = {
    create?: XOR<ModelCreateWithoutDefaultKeysInput, ModelUncheckedCreateWithoutDefaultKeysInput>
    connectOrCreate?: ModelCreateOrConnectWithoutDefaultKeysInput
    upsert?: ModelUpsertWithoutDefaultKeysInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutDefaultKeysInput, ModelUpdateWithoutDefaultKeysInput>, ModelUncheckedUpdateWithoutDefaultKeysInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumChapterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusFilter<$PrismaModel> | $Enums.ChapterStatus
  }

  export type NestedEnumChapterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChapterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChapterStatusFilter<$PrismaModel>
    _max?: NestedEnumChapterStatusFilter<$PrismaModel>
  }

  export type NestedEnumApiKeyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiKeyStatus | EnumApiKeyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiKeyStatus[] | ListEnumApiKeyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiKeyStatus[] | ListEnumApiKeyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiKeyStatusFilter<$PrismaModel> | $Enums.ApiKeyStatus
  }

  export type NestedEnumApiKeyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiKeyStatus | EnumApiKeyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiKeyStatus[] | ListEnumApiKeyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiKeyStatus[] | ListEnumApiKeyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiKeyStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApiKeyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiKeyStatusFilter<$PrismaModel>
    _max?: NestedEnumApiKeyStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type UserLibraryStoryCreateWithoutUserInput = {
    id?: string
    name: string
    author: string
    storyAvatar?: string | null
    totalChapters?: number
    isHidden?: boolean
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: UserLibraryChapterCreateNestedManyWithoutStoryInput
  }

  export type UserLibraryStoryUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    author: string
    storyAvatar?: string | null
    totalChapters?: number
    isHidden?: boolean
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: UserLibraryChapterUncheckedCreateNestedManyWithoutStoryInput
  }

  export type UserLibraryStoryCreateOrConnectWithoutUserInput = {
    where: UserLibraryStoryWhereUniqueInput
    create: XOR<UserLibraryStoryCreateWithoutUserInput, UserLibraryStoryUncheckedCreateWithoutUserInput>
  }

  export type UserLibraryStoryCreateManyUserInputEnvelope = {
    data: UserLibraryStoryCreateManyUserInput | UserLibraryStoryCreateManyUserInput[]
  }

  export type UserApiKeyCreateWithoutUserInput = {
    id?: string
    key: string
    label?: string | null
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: UserApiKeyToModelCreateNestedManyWithoutUserApiKeyInput
  }

  export type UserApiKeyUncheckedCreateWithoutUserInput = {
    id?: string
    key: string
    label?: string | null
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: UserApiKeyToModelUncheckedCreateNestedManyWithoutUserApiKeyInput
  }

  export type UserApiKeyCreateOrConnectWithoutUserInput = {
    where: UserApiKeyWhereUniqueInput
    create: XOR<UserApiKeyCreateWithoutUserInput, UserApiKeyUncheckedCreateWithoutUserInput>
  }

  export type UserApiKeyCreateManyUserInputEnvelope = {
    data: UserApiKeyCreateManyUserInput | UserApiKeyCreateManyUserInput[]
  }

  export type UserLibraryStoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLibraryStoryWhereUniqueInput
    update: XOR<UserLibraryStoryUpdateWithoutUserInput, UserLibraryStoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserLibraryStoryCreateWithoutUserInput, UserLibraryStoryUncheckedCreateWithoutUserInput>
  }

  export type UserLibraryStoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLibraryStoryWhereUniqueInput
    data: XOR<UserLibraryStoryUpdateWithoutUserInput, UserLibraryStoryUncheckedUpdateWithoutUserInput>
  }

  export type UserLibraryStoryUpdateManyWithWhereWithoutUserInput = {
    where: UserLibraryStoryScalarWhereInput
    data: XOR<UserLibraryStoryUpdateManyMutationInput, UserLibraryStoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLibraryStoryScalarWhereInput = {
    AND?: UserLibraryStoryScalarWhereInput | UserLibraryStoryScalarWhereInput[]
    OR?: UserLibraryStoryScalarWhereInput[]
    NOT?: UserLibraryStoryScalarWhereInput | UserLibraryStoryScalarWhereInput[]
    id?: StringFilter<"UserLibraryStory"> | string
    name?: StringFilter<"UserLibraryStory"> | string
    author?: StringFilter<"UserLibraryStory"> | string
    storyAvatar?: StringNullableFilter<"UserLibraryStory"> | string | null
    userId?: StringFilter<"UserLibraryStory"> | string
    totalChapters?: IntFilter<"UserLibraryStory"> | number
    isHidden?: BoolFilter<"UserLibraryStory"> | boolean
    isComplete?: BoolFilter<"UserLibraryStory"> | boolean
    createdAt?: DateTimeFilter<"UserLibraryStory"> | Date | string
    updatedAt?: DateTimeFilter<"UserLibraryStory"> | Date | string
  }

  export type UserApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: UserApiKeyWhereUniqueInput
    update: XOR<UserApiKeyUpdateWithoutUserInput, UserApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<UserApiKeyCreateWithoutUserInput, UserApiKeyUncheckedCreateWithoutUserInput>
  }

  export type UserApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: UserApiKeyWhereUniqueInput
    data: XOR<UserApiKeyUpdateWithoutUserInput, UserApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type UserApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: UserApiKeyScalarWhereInput
    data: XOR<UserApiKeyUpdateManyMutationInput, UserApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type UserApiKeyScalarWhereInput = {
    AND?: UserApiKeyScalarWhereInput | UserApiKeyScalarWhereInput[]
    OR?: UserApiKeyScalarWhereInput[]
    NOT?: UserApiKeyScalarWhereInput | UserApiKeyScalarWhereInput[]
    id?: StringFilter<"UserApiKey"> | string
    key?: StringFilter<"UserApiKey"> | string
    userId?: StringFilter<"UserApiKey"> | string
    label?: StringNullableFilter<"UserApiKey"> | string | null
    status?: EnumApiKeyStatusFilter<"UserApiKey"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"UserApiKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"UserApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"UserApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"UserApiKey"> | Date | string
  }

  export type UserCreateWithoutLibraryStoriesInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    backgroundImage?: string | null
    birthdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    UserApiKey?: UserApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLibraryStoriesInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    backgroundImage?: string | null
    birthdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    UserApiKey?: UserApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLibraryStoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLibraryStoriesInput, UserUncheckedCreateWithoutLibraryStoriesInput>
  }

  export type UserLibraryChapterCreateWithoutStoryInput = {
    id?: string
    chapterName: string
    isHidden?: boolean
    chapterNumber: number
    rawText: string
    status?: $Enums.ChapterStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    translation?: UserTranslatedChapterCreateNestedOneWithoutChapterInput
    versions?: UserTranslationVersionCreateNestedManyWithoutChapterInput
  }

  export type UserLibraryChapterUncheckedCreateWithoutStoryInput = {
    id?: string
    chapterName: string
    isHidden?: boolean
    chapterNumber: number
    rawText: string
    status?: $Enums.ChapterStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    translation?: UserTranslatedChapterUncheckedCreateNestedOneWithoutChapterInput
    versions?: UserTranslationVersionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type UserLibraryChapterCreateOrConnectWithoutStoryInput = {
    where: UserLibraryChapterWhereUniqueInput
    create: XOR<UserLibraryChapterCreateWithoutStoryInput, UserLibraryChapterUncheckedCreateWithoutStoryInput>
  }

  export type UserLibraryChapterCreateManyStoryInputEnvelope = {
    data: UserLibraryChapterCreateManyStoryInput | UserLibraryChapterCreateManyStoryInput[]
  }

  export type UserUpsertWithoutLibraryStoriesInput = {
    update: XOR<UserUpdateWithoutLibraryStoriesInput, UserUncheckedUpdateWithoutLibraryStoriesInput>
    create: XOR<UserCreateWithoutLibraryStoriesInput, UserUncheckedCreateWithoutLibraryStoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLibraryStoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLibraryStoriesInput, UserUncheckedUpdateWithoutLibraryStoriesInput>
  }

  export type UserUpdateWithoutLibraryStoriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserApiKey?: UserApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLibraryStoriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserApiKey?: UserApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserLibraryChapterUpsertWithWhereUniqueWithoutStoryInput = {
    where: UserLibraryChapterWhereUniqueInput
    update: XOR<UserLibraryChapterUpdateWithoutStoryInput, UserLibraryChapterUncheckedUpdateWithoutStoryInput>
    create: XOR<UserLibraryChapterCreateWithoutStoryInput, UserLibraryChapterUncheckedCreateWithoutStoryInput>
  }

  export type UserLibraryChapterUpdateWithWhereUniqueWithoutStoryInput = {
    where: UserLibraryChapterWhereUniqueInput
    data: XOR<UserLibraryChapterUpdateWithoutStoryInput, UserLibraryChapterUncheckedUpdateWithoutStoryInput>
  }

  export type UserLibraryChapterUpdateManyWithWhereWithoutStoryInput = {
    where: UserLibraryChapterScalarWhereInput
    data: XOR<UserLibraryChapterUpdateManyMutationInput, UserLibraryChapterUncheckedUpdateManyWithoutStoryInput>
  }

  export type UserLibraryChapterScalarWhereInput = {
    AND?: UserLibraryChapterScalarWhereInput | UserLibraryChapterScalarWhereInput[]
    OR?: UserLibraryChapterScalarWhereInput[]
    NOT?: UserLibraryChapterScalarWhereInput | UserLibraryChapterScalarWhereInput[]
    id?: StringFilter<"UserLibraryChapter"> | string
    chapterName?: StringFilter<"UserLibraryChapter"> | string
    storyId?: StringFilter<"UserLibraryChapter"> | string
    isHidden?: BoolFilter<"UserLibraryChapter"> | boolean
    chapterNumber?: IntFilter<"UserLibraryChapter"> | number
    rawText?: StringFilter<"UserLibraryChapter"> | string
    status?: EnumChapterStatusFilter<"UserLibraryChapter"> | $Enums.ChapterStatus
    createdAt?: DateTimeFilter<"UserLibraryChapter"> | Date | string
    updatedAt?: DateTimeFilter<"UserLibraryChapter"> | Date | string
  }

  export type UserLibraryStoryCreateWithoutChaptersInput = {
    id?: string
    name: string
    author: string
    storyAvatar?: string | null
    totalChapters?: number
    isHidden?: boolean
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLibraryStoriesInput
  }

  export type UserLibraryStoryUncheckedCreateWithoutChaptersInput = {
    id?: string
    name: string
    author: string
    storyAvatar?: string | null
    userId: string
    totalChapters?: number
    isHidden?: boolean
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLibraryStoryCreateOrConnectWithoutChaptersInput = {
    where: UserLibraryStoryWhereUniqueInput
    create: XOR<UserLibraryStoryCreateWithoutChaptersInput, UserLibraryStoryUncheckedCreateWithoutChaptersInput>
  }

  export type UserTranslatedChapterCreateWithoutChapterInput = {
    id?: string
    translatedTitle: string
    translatedContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTranslatedChapterUncheckedCreateWithoutChapterInput = {
    id?: string
    translatedTitle: string
    translatedContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTranslatedChapterCreateOrConnectWithoutChapterInput = {
    where: UserTranslatedChapterWhereUniqueInput
    create: XOR<UserTranslatedChapterCreateWithoutChapterInput, UserTranslatedChapterUncheckedCreateWithoutChapterInput>
  }

  export type UserTranslationVersionCreateWithoutChapterInput = {
    id?: string
    translatedText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTranslationVersionUncheckedCreateWithoutChapterInput = {
    id?: string
    translatedText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTranslationVersionCreateOrConnectWithoutChapterInput = {
    where: UserTranslationVersionWhereUniqueInput
    create: XOR<UserTranslationVersionCreateWithoutChapterInput, UserTranslationVersionUncheckedCreateWithoutChapterInput>
  }

  export type UserTranslationVersionCreateManyChapterInputEnvelope = {
    data: UserTranslationVersionCreateManyChapterInput | UserTranslationVersionCreateManyChapterInput[]
  }

  export type UserLibraryStoryUpsertWithoutChaptersInput = {
    update: XOR<UserLibraryStoryUpdateWithoutChaptersInput, UserLibraryStoryUncheckedUpdateWithoutChaptersInput>
    create: XOR<UserLibraryStoryCreateWithoutChaptersInput, UserLibraryStoryUncheckedCreateWithoutChaptersInput>
    where?: UserLibraryStoryWhereInput
  }

  export type UserLibraryStoryUpdateToOneWithWhereWithoutChaptersInput = {
    where?: UserLibraryStoryWhereInput
    data: XOR<UserLibraryStoryUpdateWithoutChaptersInput, UserLibraryStoryUncheckedUpdateWithoutChaptersInput>
  }

  export type UserLibraryStoryUpdateWithoutChaptersInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    storyAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLibraryStoriesNestedInput
  }

  export type UserLibraryStoryUncheckedUpdateWithoutChaptersInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    storyAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    totalChapters?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslatedChapterUpsertWithoutChapterInput = {
    update: XOR<UserTranslatedChapterUpdateWithoutChapterInput, UserTranslatedChapterUncheckedUpdateWithoutChapterInput>
    create: XOR<UserTranslatedChapterCreateWithoutChapterInput, UserTranslatedChapterUncheckedCreateWithoutChapterInput>
    where?: UserTranslatedChapterWhereInput
  }

  export type UserTranslatedChapterUpdateToOneWithWhereWithoutChapterInput = {
    where?: UserTranslatedChapterWhereInput
    data: XOR<UserTranslatedChapterUpdateWithoutChapterInput, UserTranslatedChapterUncheckedUpdateWithoutChapterInput>
  }

  export type UserTranslatedChapterUpdateWithoutChapterInput = {
    translatedTitle?: StringFieldUpdateOperationsInput | string
    translatedContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslatedChapterUncheckedUpdateWithoutChapterInput = {
    translatedTitle?: StringFieldUpdateOperationsInput | string
    translatedContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslationVersionUpsertWithWhereUniqueWithoutChapterInput = {
    where: UserTranslationVersionWhereUniqueInput
    update: XOR<UserTranslationVersionUpdateWithoutChapterInput, UserTranslationVersionUncheckedUpdateWithoutChapterInput>
    create: XOR<UserTranslationVersionCreateWithoutChapterInput, UserTranslationVersionUncheckedCreateWithoutChapterInput>
  }

  export type UserTranslationVersionUpdateWithWhereUniqueWithoutChapterInput = {
    where: UserTranslationVersionWhereUniqueInput
    data: XOR<UserTranslationVersionUpdateWithoutChapterInput, UserTranslationVersionUncheckedUpdateWithoutChapterInput>
  }

  export type UserTranslationVersionUpdateManyWithWhereWithoutChapterInput = {
    where: UserTranslationVersionScalarWhereInput
    data: XOR<UserTranslationVersionUpdateManyMutationInput, UserTranslationVersionUncheckedUpdateManyWithoutChapterInput>
  }

  export type UserTranslationVersionScalarWhereInput = {
    AND?: UserTranslationVersionScalarWhereInput | UserTranslationVersionScalarWhereInput[]
    OR?: UserTranslationVersionScalarWhereInput[]
    NOT?: UserTranslationVersionScalarWhereInput | UserTranslationVersionScalarWhereInput[]
    id?: StringFilter<"UserTranslationVersion"> | string
    translatedText?: StringFilter<"UserTranslationVersion"> | string
    chapterId?: StringFilter<"UserTranslationVersion"> | string
    createdAt?: DateTimeFilter<"UserTranslationVersion"> | Date | string
    updatedAt?: DateTimeFilter<"UserTranslationVersion"> | Date | string
  }

  export type UserLibraryChapterCreateWithoutTranslationInput = {
    id?: string
    chapterName: string
    isHidden?: boolean
    chapterNumber: number
    rawText: string
    status?: $Enums.ChapterStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    story: UserLibraryStoryCreateNestedOneWithoutChaptersInput
    versions?: UserTranslationVersionCreateNestedManyWithoutChapterInput
  }

  export type UserLibraryChapterUncheckedCreateWithoutTranslationInput = {
    id?: string
    chapterName: string
    storyId: string
    isHidden?: boolean
    chapterNumber: number
    rawText: string
    status?: $Enums.ChapterStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: UserTranslationVersionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type UserLibraryChapterCreateOrConnectWithoutTranslationInput = {
    where: UserLibraryChapterWhereUniqueInput
    create: XOR<UserLibraryChapterCreateWithoutTranslationInput, UserLibraryChapterUncheckedCreateWithoutTranslationInput>
  }

  export type UserLibraryChapterUpsertWithoutTranslationInput = {
    update: XOR<UserLibraryChapterUpdateWithoutTranslationInput, UserLibraryChapterUncheckedUpdateWithoutTranslationInput>
    create: XOR<UserLibraryChapterCreateWithoutTranslationInput, UserLibraryChapterUncheckedCreateWithoutTranslationInput>
    where?: UserLibraryChapterWhereInput
  }

  export type UserLibraryChapterUpdateToOneWithWhereWithoutTranslationInput = {
    where?: UserLibraryChapterWhereInput
    data: XOR<UserLibraryChapterUpdateWithoutTranslationInput, UserLibraryChapterUncheckedUpdateWithoutTranslationInput>
  }

  export type UserLibraryChapterUpdateWithoutTranslationInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: UserLibraryStoryUpdateOneRequiredWithoutChaptersNestedInput
    versions?: UserTranslationVersionUpdateManyWithoutChapterNestedInput
  }

  export type UserLibraryChapterUncheckedUpdateWithoutTranslationInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: UserTranslationVersionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UserLibraryChapterCreateWithoutVersionsInput = {
    id?: string
    chapterName: string
    isHidden?: boolean
    chapterNumber: number
    rawText: string
    status?: $Enums.ChapterStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    story: UserLibraryStoryCreateNestedOneWithoutChaptersInput
    translation?: UserTranslatedChapterCreateNestedOneWithoutChapterInput
  }

  export type UserLibraryChapterUncheckedCreateWithoutVersionsInput = {
    id?: string
    chapterName: string
    storyId: string
    isHidden?: boolean
    chapterNumber: number
    rawText: string
    status?: $Enums.ChapterStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    translation?: UserTranslatedChapterUncheckedCreateNestedOneWithoutChapterInput
  }

  export type UserLibraryChapterCreateOrConnectWithoutVersionsInput = {
    where: UserLibraryChapterWhereUniqueInput
    create: XOR<UserLibraryChapterCreateWithoutVersionsInput, UserLibraryChapterUncheckedCreateWithoutVersionsInput>
  }

  export type UserLibraryChapterUpsertWithoutVersionsInput = {
    update: XOR<UserLibraryChapterUpdateWithoutVersionsInput, UserLibraryChapterUncheckedUpdateWithoutVersionsInput>
    create: XOR<UserLibraryChapterCreateWithoutVersionsInput, UserLibraryChapterUncheckedCreateWithoutVersionsInput>
    where?: UserLibraryChapterWhereInput
  }

  export type UserLibraryChapterUpdateToOneWithWhereWithoutVersionsInput = {
    where?: UserLibraryChapterWhereInput
    data: XOR<UserLibraryChapterUpdateWithoutVersionsInput, UserLibraryChapterUncheckedUpdateWithoutVersionsInput>
  }

  export type UserLibraryChapterUpdateWithoutVersionsInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: UserLibraryStoryUpdateOneRequiredWithoutChaptersNestedInput
    translation?: UserTranslatedChapterUpdateOneWithoutChapterNestedInput
  }

  export type UserLibraryChapterUncheckedUpdateWithoutVersionsInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: UserTranslatedChapterUncheckedUpdateOneWithoutChapterNestedInput
  }

  export type UserCreateWithoutUserApiKeyInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    backgroundImage?: string | null
    birthdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStories?: UserLibraryStoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserApiKeyInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    backgroundImage?: string | null
    birthdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStories?: UserLibraryStoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserApiKeyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserApiKeyInput, UserUncheckedCreateWithoutUserApiKeyInput>
  }

  export type UserApiKeyToModelCreateWithoutUserApiKeyInput = {
    id?: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutUserApiKeysInput
  }

  export type UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput = {
    id?: string
    modelId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserApiKeyToModelCreateOrConnectWithoutUserApiKeyInput = {
    where: UserApiKeyToModelWhereUniqueInput
    create: XOR<UserApiKeyToModelCreateWithoutUserApiKeyInput, UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput>
  }

  export type UserApiKeyToModelCreateManyUserApiKeyInputEnvelope = {
    data: UserApiKeyToModelCreateManyUserApiKeyInput | UserApiKeyToModelCreateManyUserApiKeyInput[]
  }

  export type UserUpsertWithoutUserApiKeyInput = {
    update: XOR<UserUpdateWithoutUserApiKeyInput, UserUncheckedUpdateWithoutUserApiKeyInput>
    create: XOR<UserCreateWithoutUserApiKeyInput, UserUncheckedCreateWithoutUserApiKeyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserApiKeyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserApiKeyInput, UserUncheckedUpdateWithoutUserApiKeyInput>
  }

  export type UserUpdateWithoutUserApiKeyInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStories?: UserLibraryStoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserApiKeyInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStories?: UserLibraryStoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserApiKeyToModelUpsertWithWhereUniqueWithoutUserApiKeyInput = {
    where: UserApiKeyToModelWhereUniqueInput
    update: XOR<UserApiKeyToModelUpdateWithoutUserApiKeyInput, UserApiKeyToModelUncheckedUpdateWithoutUserApiKeyInput>
    create: XOR<UserApiKeyToModelCreateWithoutUserApiKeyInput, UserApiKeyToModelUncheckedCreateWithoutUserApiKeyInput>
  }

  export type UserApiKeyToModelUpdateWithWhereUniqueWithoutUserApiKeyInput = {
    where: UserApiKeyToModelWhereUniqueInput
    data: XOR<UserApiKeyToModelUpdateWithoutUserApiKeyInput, UserApiKeyToModelUncheckedUpdateWithoutUserApiKeyInput>
  }

  export type UserApiKeyToModelUpdateManyWithWhereWithoutUserApiKeyInput = {
    where: UserApiKeyToModelScalarWhereInput
    data: XOR<UserApiKeyToModelUpdateManyMutationInput, UserApiKeyToModelUncheckedUpdateManyWithoutUserApiKeyInput>
  }

  export type UserApiKeyToModelScalarWhereInput = {
    AND?: UserApiKeyToModelScalarWhereInput | UserApiKeyToModelScalarWhereInput[]
    OR?: UserApiKeyToModelScalarWhereInput[]
    NOT?: UserApiKeyToModelScalarWhereInput | UserApiKeyToModelScalarWhereInput[]
    id?: StringFilter<"UserApiKeyToModel"> | string
    userApiKeyId?: StringFilter<"UserApiKeyToModel"> | string
    modelId?: StringFilter<"UserApiKeyToModel"> | string
    status?: EnumApiKeyStatusFilter<"UserApiKeyToModel"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"UserApiKeyToModel"> | number
    lastUsedAt?: DateTimeNullableFilter<"UserApiKeyToModel"> | Date | string | null
    createdAt?: DateTimeFilter<"UserApiKeyToModel"> | Date | string
    updatedAt?: DateTimeFilter<"UserApiKeyToModel"> | Date | string
  }

  export type ModelCreateWithoutProviderInput = {
    id?: string
    value: string
    rpm?: number | null
    tpm?: number | null
    rpd?: number | null
    label: string
    description?: string | null
    userApiKeys?: UserApiKeyToModelCreateNestedManyWithoutModelInput
    defaultKeys?: DefaultKeyToModelCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutProviderInput = {
    id?: string
    value: string
    rpm?: number | null
    tpm?: number | null
    rpd?: number | null
    label: string
    description?: string | null
    userApiKeys?: UserApiKeyToModelUncheckedCreateNestedManyWithoutModelInput
    defaultKeys?: DefaultKeyToModelUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutProviderInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutProviderInput, ModelUncheckedCreateWithoutProviderInput>
  }

  export type ModelCreateManyProviderInputEnvelope = {
    data: ModelCreateManyProviderInput | ModelCreateManyProviderInput[]
  }

  export type ModelUpsertWithWhereUniqueWithoutProviderInput = {
    where: ModelWhereUniqueInput
    update: XOR<ModelUpdateWithoutProviderInput, ModelUncheckedUpdateWithoutProviderInput>
    create: XOR<ModelCreateWithoutProviderInput, ModelUncheckedCreateWithoutProviderInput>
  }

  export type ModelUpdateWithWhereUniqueWithoutProviderInput = {
    where: ModelWhereUniqueInput
    data: XOR<ModelUpdateWithoutProviderInput, ModelUncheckedUpdateWithoutProviderInput>
  }

  export type ModelUpdateManyWithWhereWithoutProviderInput = {
    where: ModelScalarWhereInput
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyWithoutProviderInput>
  }

  export type ModelScalarWhereInput = {
    AND?: ModelScalarWhereInput | ModelScalarWhereInput[]
    OR?: ModelScalarWhereInput[]
    NOT?: ModelScalarWhereInput | ModelScalarWhereInput[]
    id?: StringFilter<"Model"> | string
    providerId?: StringFilter<"Model"> | string
    value?: StringFilter<"Model"> | string
    rpm?: IntNullableFilter<"Model"> | number | null
    tpm?: IntNullableFilter<"Model"> | number | null
    rpd?: IntNullableFilter<"Model"> | number | null
    label?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
  }

  export type ProviderCreateWithoutModelsInput = {
    id?: string
    name: string
  }

  export type ProviderUncheckedCreateWithoutModelsInput = {
    id?: string
    name: string
  }

  export type ProviderCreateOrConnectWithoutModelsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutModelsInput, ProviderUncheckedCreateWithoutModelsInput>
  }

  export type UserApiKeyToModelCreateWithoutModelInput = {
    id?: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userApiKey: UserApiKeyCreateNestedOneWithoutModelsInput
  }

  export type UserApiKeyToModelUncheckedCreateWithoutModelInput = {
    id?: string
    userApiKeyId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserApiKeyToModelCreateOrConnectWithoutModelInput = {
    where: UserApiKeyToModelWhereUniqueInput
    create: XOR<UserApiKeyToModelCreateWithoutModelInput, UserApiKeyToModelUncheckedCreateWithoutModelInput>
  }

  export type UserApiKeyToModelCreateManyModelInputEnvelope = {
    data: UserApiKeyToModelCreateManyModelInput | UserApiKeyToModelCreateManyModelInput[]
  }

  export type DefaultKeyToModelCreateWithoutModelInput = {
    id?: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultKey: DefaultKeyCreateNestedOneWithoutModelsInput
  }

  export type DefaultKeyToModelUncheckedCreateWithoutModelInput = {
    id?: string
    defaultKeyId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultKeyToModelCreateOrConnectWithoutModelInput = {
    where: DefaultKeyToModelWhereUniqueInput
    create: XOR<DefaultKeyToModelCreateWithoutModelInput, DefaultKeyToModelUncheckedCreateWithoutModelInput>
  }

  export type DefaultKeyToModelCreateManyModelInputEnvelope = {
    data: DefaultKeyToModelCreateManyModelInput | DefaultKeyToModelCreateManyModelInput[]
  }

  export type ProviderUpsertWithoutModelsInput = {
    update: XOR<ProviderUpdateWithoutModelsInput, ProviderUncheckedUpdateWithoutModelsInput>
    create: XOR<ProviderCreateWithoutModelsInput, ProviderUncheckedCreateWithoutModelsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutModelsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutModelsInput, ProviderUncheckedUpdateWithoutModelsInput>
  }

  export type ProviderUpdateWithoutModelsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderUncheckedUpdateWithoutModelsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserApiKeyToModelUpsertWithWhereUniqueWithoutModelInput = {
    where: UserApiKeyToModelWhereUniqueInput
    update: XOR<UserApiKeyToModelUpdateWithoutModelInput, UserApiKeyToModelUncheckedUpdateWithoutModelInput>
    create: XOR<UserApiKeyToModelCreateWithoutModelInput, UserApiKeyToModelUncheckedCreateWithoutModelInput>
  }

  export type UserApiKeyToModelUpdateWithWhereUniqueWithoutModelInput = {
    where: UserApiKeyToModelWhereUniqueInput
    data: XOR<UserApiKeyToModelUpdateWithoutModelInput, UserApiKeyToModelUncheckedUpdateWithoutModelInput>
  }

  export type UserApiKeyToModelUpdateManyWithWhereWithoutModelInput = {
    where: UserApiKeyToModelScalarWhereInput
    data: XOR<UserApiKeyToModelUpdateManyMutationInput, UserApiKeyToModelUncheckedUpdateManyWithoutModelInput>
  }

  export type DefaultKeyToModelUpsertWithWhereUniqueWithoutModelInput = {
    where: DefaultKeyToModelWhereUniqueInput
    update: XOR<DefaultKeyToModelUpdateWithoutModelInput, DefaultKeyToModelUncheckedUpdateWithoutModelInput>
    create: XOR<DefaultKeyToModelCreateWithoutModelInput, DefaultKeyToModelUncheckedCreateWithoutModelInput>
  }

  export type DefaultKeyToModelUpdateWithWhereUniqueWithoutModelInput = {
    where: DefaultKeyToModelWhereUniqueInput
    data: XOR<DefaultKeyToModelUpdateWithoutModelInput, DefaultKeyToModelUncheckedUpdateWithoutModelInput>
  }

  export type DefaultKeyToModelUpdateManyWithWhereWithoutModelInput = {
    where: DefaultKeyToModelScalarWhereInput
    data: XOR<DefaultKeyToModelUpdateManyMutationInput, DefaultKeyToModelUncheckedUpdateManyWithoutModelInput>
  }

  export type DefaultKeyToModelScalarWhereInput = {
    AND?: DefaultKeyToModelScalarWhereInput | DefaultKeyToModelScalarWhereInput[]
    OR?: DefaultKeyToModelScalarWhereInput[]
    NOT?: DefaultKeyToModelScalarWhereInput | DefaultKeyToModelScalarWhereInput[]
    id?: StringFilter<"DefaultKeyToModel"> | string
    defaultKeyId?: StringFilter<"DefaultKeyToModel"> | string
    modelId?: StringFilter<"DefaultKeyToModel"> | string
    status?: EnumApiKeyStatusFilter<"DefaultKeyToModel"> | $Enums.ApiKeyStatus
    usageCount?: IntFilter<"DefaultKeyToModel"> | number
    lastUsedAt?: DateTimeNullableFilter<"DefaultKeyToModel"> | Date | string | null
    createdAt?: DateTimeFilter<"DefaultKeyToModel"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultKeyToModel"> | Date | string
  }

  export type DefaultKeyToModelCreateWithoutDefaultKeyInput = {
    id?: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutDefaultKeysInput
  }

  export type DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput = {
    id?: string
    modelId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultKeyToModelCreateOrConnectWithoutDefaultKeyInput = {
    where: DefaultKeyToModelWhereUniqueInput
    create: XOR<DefaultKeyToModelCreateWithoutDefaultKeyInput, DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput>
  }

  export type DefaultKeyToModelCreateManyDefaultKeyInputEnvelope = {
    data: DefaultKeyToModelCreateManyDefaultKeyInput | DefaultKeyToModelCreateManyDefaultKeyInput[]
  }

  export type DefaultKeyToModelUpsertWithWhereUniqueWithoutDefaultKeyInput = {
    where: DefaultKeyToModelWhereUniqueInput
    update: XOR<DefaultKeyToModelUpdateWithoutDefaultKeyInput, DefaultKeyToModelUncheckedUpdateWithoutDefaultKeyInput>
    create: XOR<DefaultKeyToModelCreateWithoutDefaultKeyInput, DefaultKeyToModelUncheckedCreateWithoutDefaultKeyInput>
  }

  export type DefaultKeyToModelUpdateWithWhereUniqueWithoutDefaultKeyInput = {
    where: DefaultKeyToModelWhereUniqueInput
    data: XOR<DefaultKeyToModelUpdateWithoutDefaultKeyInput, DefaultKeyToModelUncheckedUpdateWithoutDefaultKeyInput>
  }

  export type DefaultKeyToModelUpdateManyWithWhereWithoutDefaultKeyInput = {
    where: DefaultKeyToModelScalarWhereInput
    data: XOR<DefaultKeyToModelUpdateManyMutationInput, DefaultKeyToModelUncheckedUpdateManyWithoutDefaultKeyInput>
  }

  export type UserApiKeyCreateWithoutModelsInput = {
    id?: string
    key: string
    label?: string | null
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserApiKeyInput
  }

  export type UserApiKeyUncheckedCreateWithoutModelsInput = {
    id?: string
    key: string
    userId: string
    label?: string | null
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserApiKeyCreateOrConnectWithoutModelsInput = {
    where: UserApiKeyWhereUniqueInput
    create: XOR<UserApiKeyCreateWithoutModelsInput, UserApiKeyUncheckedCreateWithoutModelsInput>
  }

  export type ModelCreateWithoutUserApiKeysInput = {
    id?: string
    value: string
    rpm?: number | null
    tpm?: number | null
    rpd?: number | null
    label: string
    description?: string | null
    provider: ProviderCreateNestedOneWithoutModelsInput
    defaultKeys?: DefaultKeyToModelCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutUserApiKeysInput = {
    id?: string
    providerId: string
    value: string
    rpm?: number | null
    tpm?: number | null
    rpd?: number | null
    label: string
    description?: string | null
    defaultKeys?: DefaultKeyToModelUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutUserApiKeysInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutUserApiKeysInput, ModelUncheckedCreateWithoutUserApiKeysInput>
  }

  export type UserApiKeyUpsertWithoutModelsInput = {
    update: XOR<UserApiKeyUpdateWithoutModelsInput, UserApiKeyUncheckedUpdateWithoutModelsInput>
    create: XOR<UserApiKeyCreateWithoutModelsInput, UserApiKeyUncheckedCreateWithoutModelsInput>
    where?: UserApiKeyWhereInput
  }

  export type UserApiKeyUpdateToOneWithWhereWithoutModelsInput = {
    where?: UserApiKeyWhereInput
    data: XOR<UserApiKeyUpdateWithoutModelsInput, UserApiKeyUncheckedUpdateWithoutModelsInput>
  }

  export type UserApiKeyUpdateWithoutModelsInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserApiKeyNestedInput
  }

  export type UserApiKeyUncheckedUpdateWithoutModelsInput = {
    key?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelUpsertWithoutUserApiKeysInput = {
    update: XOR<ModelUpdateWithoutUserApiKeysInput, ModelUncheckedUpdateWithoutUserApiKeysInput>
    create: XOR<ModelCreateWithoutUserApiKeysInput, ModelUncheckedCreateWithoutUserApiKeysInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutUserApiKeysInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutUserApiKeysInput, ModelUncheckedUpdateWithoutUserApiKeysInput>
  }

  export type ModelUpdateWithoutUserApiKeysInput = {
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: ProviderUpdateOneRequiredWithoutModelsNestedInput
    defaultKeys?: DefaultKeyToModelUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutUserApiKeysInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultKeys?: DefaultKeyToModelUncheckedUpdateManyWithoutModelNestedInput
  }

  export type DefaultKeyCreateWithoutModelsInput = {
    id?: string
    key: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultKeyUncheckedCreateWithoutModelsInput = {
    id?: string
    key: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultKeyCreateOrConnectWithoutModelsInput = {
    where: DefaultKeyWhereUniqueInput
    create: XOR<DefaultKeyCreateWithoutModelsInput, DefaultKeyUncheckedCreateWithoutModelsInput>
  }

  export type ModelCreateWithoutDefaultKeysInput = {
    id?: string
    value: string
    rpm?: number | null
    tpm?: number | null
    rpd?: number | null
    label: string
    description?: string | null
    provider: ProviderCreateNestedOneWithoutModelsInput
    userApiKeys?: UserApiKeyToModelCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutDefaultKeysInput = {
    id?: string
    providerId: string
    value: string
    rpm?: number | null
    tpm?: number | null
    rpd?: number | null
    label: string
    description?: string | null
    userApiKeys?: UserApiKeyToModelUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutDefaultKeysInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutDefaultKeysInput, ModelUncheckedCreateWithoutDefaultKeysInput>
  }

  export type DefaultKeyUpsertWithoutModelsInput = {
    update: XOR<DefaultKeyUpdateWithoutModelsInput, DefaultKeyUncheckedUpdateWithoutModelsInput>
    create: XOR<DefaultKeyCreateWithoutModelsInput, DefaultKeyUncheckedCreateWithoutModelsInput>
    where?: DefaultKeyWhereInput
  }

  export type DefaultKeyUpdateToOneWithWhereWithoutModelsInput = {
    where?: DefaultKeyWhereInput
    data: XOR<DefaultKeyUpdateWithoutModelsInput, DefaultKeyUncheckedUpdateWithoutModelsInput>
  }

  export type DefaultKeyUpdateWithoutModelsInput = {
    key?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultKeyUncheckedUpdateWithoutModelsInput = {
    key?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelUpsertWithoutDefaultKeysInput = {
    update: XOR<ModelUpdateWithoutDefaultKeysInput, ModelUncheckedUpdateWithoutDefaultKeysInput>
    create: XOR<ModelCreateWithoutDefaultKeysInput, ModelUncheckedCreateWithoutDefaultKeysInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutDefaultKeysInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutDefaultKeysInput, ModelUncheckedUpdateWithoutDefaultKeysInput>
  }

  export type ModelUpdateWithoutDefaultKeysInput = {
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: ProviderUpdateOneRequiredWithoutModelsNestedInput
    userApiKeys?: UserApiKeyToModelUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutDefaultKeysInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userApiKeys?: UserApiKeyToModelUncheckedUpdateManyWithoutModelNestedInput
  }

  export type UserLibraryStoryCreateManyUserInput = {
    id?: string
    name: string
    author: string
    storyAvatar?: string | null
    totalChapters?: number
    isHidden?: boolean
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserApiKeyCreateManyUserInput = {
    id?: string
    key: string
    label?: string | null
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLibraryStoryUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    storyAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: UserLibraryChapterUpdateManyWithoutStoryNestedInput
  }

  export type UserLibraryStoryUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    storyAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: UserLibraryChapterUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UserLibraryStoryUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    storyAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserApiKeyUpdateWithoutUserInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: UserApiKeyToModelUpdateManyWithoutUserApiKeyNestedInput
  }

  export type UserApiKeyUncheckedUpdateWithoutUserInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: UserApiKeyToModelUncheckedUpdateManyWithoutUserApiKeyNestedInput
  }

  export type UserApiKeyUncheckedUpdateManyWithoutUserInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryChapterCreateManyStoryInput = {
    id?: string
    chapterName: string
    isHidden?: boolean
    chapterNumber: number
    rawText: string
    status?: $Enums.ChapterStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLibraryChapterUpdateWithoutStoryInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: UserTranslatedChapterUpdateOneWithoutChapterNestedInput
    versions?: UserTranslationVersionUpdateManyWithoutChapterNestedInput
  }

  export type UserLibraryChapterUncheckedUpdateWithoutStoryInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: UserTranslatedChapterUncheckedUpdateOneWithoutChapterNestedInput
    versions?: UserTranslationVersionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UserLibraryChapterUncheckedUpdateManyWithoutStoryInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    chapterNumber?: IntFieldUpdateOperationsInput | number
    rawText?: StringFieldUpdateOperationsInput | string
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslationVersionCreateManyChapterInput = {
    id?: string
    translatedText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTranslationVersionUpdateWithoutChapterInput = {
    translatedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslationVersionUncheckedUpdateWithoutChapterInput = {
    translatedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTranslationVersionUncheckedUpdateManyWithoutChapterInput = {
    translatedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserApiKeyToModelCreateManyUserApiKeyInput = {
    id?: string
    modelId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserApiKeyToModelUpdateWithoutUserApiKeyInput = {
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutUserApiKeysNestedInput
  }

  export type UserApiKeyToModelUncheckedUpdateWithoutUserApiKeyInput = {
    modelId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserApiKeyToModelUncheckedUpdateManyWithoutUserApiKeyInput = {
    modelId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCreateManyProviderInput = {
    id?: string
    value: string
    rpm?: number | null
    tpm?: number | null
    rpd?: number | null
    label: string
    description?: string | null
  }

  export type ModelUpdateWithoutProviderInput = {
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userApiKeys?: UserApiKeyToModelUpdateManyWithoutModelNestedInput
    defaultKeys?: DefaultKeyToModelUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutProviderInput = {
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userApiKeys?: UserApiKeyToModelUncheckedUpdateManyWithoutModelNestedInput
    defaultKeys?: DefaultKeyToModelUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateManyWithoutProviderInput = {
    value?: StringFieldUpdateOperationsInput | string
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    tpm?: NullableIntFieldUpdateOperationsInput | number | null
    rpd?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserApiKeyToModelCreateManyModelInput = {
    id?: string
    userApiKeyId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultKeyToModelCreateManyModelInput = {
    id?: string
    defaultKeyId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserApiKeyToModelUpdateWithoutModelInput = {
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userApiKey?: UserApiKeyUpdateOneRequiredWithoutModelsNestedInput
  }

  export type UserApiKeyToModelUncheckedUpdateWithoutModelInput = {
    userApiKeyId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserApiKeyToModelUncheckedUpdateManyWithoutModelInput = {
    userApiKeyId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultKeyToModelUpdateWithoutModelInput = {
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultKey?: DefaultKeyUpdateOneRequiredWithoutModelsNestedInput
  }

  export type DefaultKeyToModelUncheckedUpdateWithoutModelInput = {
    defaultKeyId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultKeyToModelUncheckedUpdateManyWithoutModelInput = {
    defaultKeyId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultKeyToModelCreateManyDefaultKeyInput = {
    id?: string
    modelId: string
    status?: $Enums.ApiKeyStatus
    usageCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultKeyToModelUpdateWithoutDefaultKeyInput = {
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutDefaultKeysNestedInput
  }

  export type DefaultKeyToModelUncheckedUpdateWithoutDefaultKeyInput = {
    modelId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultKeyToModelUncheckedUpdateManyWithoutDefaultKeyInput = {
    modelId?: StringFieldUpdateOperationsInput | string
    status?: EnumApiKeyStatusFieldUpdateOperationsInput | $Enums.ApiKeyStatus
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

/**
 * Ki·ªÉm tra xem text c√≥ ch·ª©a k√Ω t·ª± ti·∫øng Vi·ªát hay kh√¥ng
 */
function containsVietnameseChars(text) {
  // Regex ƒë·ªÉ ki·ªÉm tra k√Ω t·ª± ti·∫øng Vi·ªát (c√≥ d·∫•u)
  const vietnameseRegex = /[√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]/i;
  return vietnameseRegex.test(text);
}

/**
 * Ki·ªÉm tra xem text c√≥ ch·ª©a k√Ω t·ª± ti·∫øng Trung hay kh√¥ng
 */
function containsChineseChars(text) {
  // Regex ƒë·ªÉ ki·ªÉm tra k√Ω t·ª± ti·∫øng Trung (Unicode range)
  const chineseRegex = /[\u4e00-\u9fff]/;
  return chineseRegex.test(text);
}

/**
 * Ki·ªÉm tra xem text c√≥ ch·ª©a k√Ω t·ª± ti·∫øng Nh·∫≠t hay kh√¥ng
 */
function containsJapaneseChars(text) {
  // Regex ƒë·ªÉ ki·ªÉm tra k√Ω t·ª± ti·∫øng Nh·∫≠t (Hiragana, Katakana, Kanji)
  const japaneseRegex = /[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9fff]/;
  return japaneseRegex.test(text);
}

/**
 * Ki·ªÉm tra xem text c√≥ ch·ª©a k√Ω t·ª± ti·∫øng H√†n hay kh√¥ng
 */
function containsKoreanChars(text) {
  // Regex ƒë·ªÉ ki·ªÉm tra k√Ω t·ª± ti·∫øng H√†n (Hangul)
  const koreanRegex = /[\uac00-\ud7af]/;
  return koreanRegex.test(text);
}

/**
 * Ki·ªÉm tra xem text c√≥ ph·∫£i l√† ti·∫øng n∆∞·ªõc ngo√†i hay kh√¥ng
 * Lo·∫°i b·ªè c√°c t·ª´ ti·∫øng Vi·ªát c√≥ d·∫•u
 */
function isForeignLanguage(text) {
  // N·∫øu c√≥ k√Ω t·ª± ti·∫øng Vi·ªát c√≥ d·∫•u, th√¨ kh√¥ng ph·∫£i ti·∫øng n∆∞·ªõc ngo√†i
  if (containsVietnameseChars(text)) {
    return false;
  }
  
  // Ki·ªÉm tra c√°c k√Ω t·ª± ti·∫øng n∆∞·ªõc ngo√†i
  return containsChineseChars(text) || 
         containsJapaneseChars(text) || 
         containsKoreanChars(text) ||
         // Ch·ªâ ch·∫•p nh·∫≠n k√Ω t·ª± Latin n·∫øu kh√¥ng c√≥ d·∫•u ti·∫øng Vi·ªát
         (/[a-zA-Z]/.test(text) && !containsVietnameseChars(text));
}

/**
 * Tr√≠ch v√† l∆∞u glossary t·ª´ vƒÉn b·∫£n ƒë·ªãnh d·∫°ng:
 * "Âº†‰ºü = Tr∆∞∆°ng Vƒ© [Nh√¢n v·∫≠t] [Trung]"
 * Ch·ªâ l∆∞u nh·ªØng t·ª´ c√≥ g·ªëc ti·∫øng n∆∞·ªõc ngo√†i
 */
async function extractAndSaveGlossary(storyId, glossaryText) {
  if (!glossaryText || !storyId) {
    console.log("‚ö†Ô∏è Kh√¥ng c√≥ glossary text ho·∫∑c storyId ƒë·ªÉ l∆∞u");
    return;
  }

  const lines = glossaryText.trim().split("\n");
  let savedCount = 0;
  let updatedCount = 0;
  let skippedCount = 0;

  for (const line of lines) {
    console.log(`[GLOSSARY] üîé ƒêang x·ª≠ l√Ω d√≤ng: "${line}"`);
    // Regex ƒë·ªÉ match format ƒë·∫ßy ƒë·ªß: "Âº†‰ºü = Tr∆∞∆°ng Vƒ© [Nh√¢n v·∫≠t] [Trung]"
    let match = line.match(/^(.+?)\s*=\s*(.+?)\s*\[(.+?)\]\s*\[(.+?)\]$/);
    let original, translated, type, lang;
    if (match) {
      [, original, translated, type, lang] = match;
      const originalTrim = original.trim();
      const translatedTrim = translated.trim();
      console.log(`[GLOSSARY] üß© Parsed: original="${originalTrim}", translated="${translatedTrim}", type="${type}", lang="${lang}"`);
      
      // Ki·ªÉm tra xem original c√≥ ph·∫£i l√† ti·∫øng n∆∞·ªõc ngo√†i kh√¥ng
      if (!isForeignLanguage(originalTrim)) {
        console.log(`‚ö†Ô∏è B·ªè qua t·ª´ ti·∫øng Vi·ªát: "${originalTrim}"`);
        skippedCount++;
        continue;
      }

      // Ki·ªÉm tra xem c√≥ ph·∫£i l√† t·ª´ tr√πng l·∫∑p kh√¥ng (original = translated)
      if (originalTrim === translatedTrim) {
        console.log(`‚ö†Ô∏è B·ªè qua t·ª´ tr√πng l·∫∑p: "${originalTrim}"`);
        skippedCount++;
        continue;
      }

      // Ki·ªÉm tra xem c√≥ ph·∫£i l√† t√™n ch∆∞∆°ng d√†i kh√¥ng (ch·ª©a t·ª´ kh√≥a ch∆∞∆°ng)
      if (originalTrim.includes('Á´†') || originalTrim.includes('Á¨¨') || originalTrim.toLowerCase().includes('chapter') || 
          originalTrim.length > 30) {
        console.log(`‚ö†Ô∏è B·ªè qua t√™n ch∆∞∆°ng d√†i: "${originalTrim}"`);
        skippedCount++;
        continue;
      }

      // Ki·ªÉm tra xem c√≥ ph·∫£i l√† c√¢u ho·∫∑c c·ª•m t·ª´ qu√° d√†i kh√¥ng
      // Cho ph√©p c√≥ kho·∫£ng tr·∫Øng (v√≠ d·ª• t√™n ti·∫øng Nh·∫≠t/Anh 2 t·ª´), nh∆∞ng gi·ªõi h·∫°n ƒë·ªô d√†i/t·ª´
      const wordCount = originalTrim.trim().split(/\s+/).length;
      if (originalTrim.length > 30 || wordCount > 3 || originalTrim.includes('Ôºö')) {
        console.log(`‚ö†Ô∏è B·ªè qua c·ª•m qu√° d√†i: "${originalTrim}" (len=${originalTrim.length}, words=${wordCount})`);
        skippedCount++;
        continue;
      }

      // Ki·ªÉm tra xem c√≥ ph·∫£i l√† t·ª´ chung kh√¥ng (kh√¥ng ph·∫£i danh t·ª´ ri√™ng)
      const commonWords = ['ma', 'v∆∞∆°ng', 'h·ªçc', 'vi·ªán', 'gi√°m', 'ƒë·ªëc', 'c√¥ng', 'ty', 'tr∆∞·ªùng', 'ƒë·∫°i', 'h·ªçc'];
      const isCommonWord = commonWords.some(word => 
        originalTrim.toLowerCase().includes(word) || translatedTrim.toLowerCase().includes(word)
      );
      if (isCommonWord && !isForeignLanguage(originalTrim)) {
        console.log(`‚ö†Ô∏è B·ªè qua t·ª´ chung: "${originalTrim}"`);
        skippedCount++;
        continue;
      }
      
      try {
        // Ki·ªÉm tra xem ƒë√£ t·ªìn t·∫°i ch∆∞a
        const exists = await prisma.glossaryItem.findFirst({
          where: { 
            storyId, 
            original: originalTrim 
          }
        });

        if (!exists) {
          // T·∫°o m·ªõi
          await prisma.glossaryItem.create({
            data: { 
              storyId, 
              original: originalTrim, 
              translated: translatedTrim, 
              type: type.trim(), 
              lang: lang.trim() 
            }
          });
          savedCount++;
          console.log(`‚úÖ ƒê√£ l∆∞u: "${originalTrim}" = "${translatedTrim}"`);
        } else {
          // C·∫≠p nh·∫≠t frequency n·∫øu ƒë√£ t·ªìn t·∫°i
          await prisma.glossaryItem.update({
            where: { id: exists.id },
            data: { 
              frequency: exists.frequency + 1,
              updatedAt: new Date()
            }
          });
          updatedCount++;
          console.log(`üîÑ ƒê√£ c·∫≠p nh·∫≠t: "${originalTrim}"`);
        }
      } catch (error) {
        console.error("‚ùå L·ªói khi l∆∞u glossary item:", error);
      }
    } else {
      // Fallback: ch·ªâ c√≥ "g·ªëc = d·ªãch" kh√¥ng k√®m [type][lang]
      const matchSimple = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
      if (!matchSimple) {
        continue;
      }
      [, original, translated] = matchSimple;
      type = 'Danh t·ª´ ri√™ng';
      // T·ª± ƒë·ªông ƒëo√°n ng√¥n ng·ªØ g·ªëc
      if (containsChineseChars(original)) lang = 'Trung';
      else if (containsJapaneseChars(original)) lang = 'Nh·∫≠t';
      else if (containsKoreanChars(original)) lang = 'H√†n';
      else lang = 'Anh';
      const originalTrim = original.trim();
      const translatedTrim = translated.trim();
      console.log(`[GLOSSARY] üß© Parsed(simple): original="${originalTrim}", translated="${translatedTrim}", type="${type}", lang="${lang}"`);
      // Ti·∫øp t·ª•c xu·ªëng quy tr√¨nh validate/l∆∞u ·ªü d∆∞·ªõi b·∫±ng c√°ch set bi·∫øn c·ª•c b·ªô
      original = originalTrim;
      translated = translatedTrim;
      // R∆°i xu·ªëng ti·∫øp quy tr√¨nh chung, n√™n replicate ƒëo·∫°n d∆∞·ªõi
    }
  }

  console.log(`üìö K·∫øt qu·∫£ l∆∞u glossary: ${savedCount} m·ªõi, ${updatedCount} c·∫≠p nh·∫≠t, ${skippedCount} b·ªè qua`);
}

/**
 * L·∫•y t·∫•t c·∫£ glossary items c·ªßa m·ªôt truy·ªán
 */
async function getGlossaryByStoryId(storyId) {
  try {
    const items = await prisma.glossaryItem.findMany({
      where: { storyId },
      orderBy: [
        { frequency: 'desc' },
        { createdAt: 'desc' }
      ]
    });
    return items;
  } catch (error) {
    console.error("‚ùå L·ªói khi l·∫•y glossary:", error);
    return [];
  }
}

/**
 * Chuy·ªÉn ƒë·ªïi glossary items th√†nh text format ƒë·ªÉ g·ª≠i cho AI
 */
function formatGlossaryForAI(glossaryItems) {
  if (!glossaryItems || glossaryItems.length === 0) {
    return "";
  }

  const formattedItems = glossaryItems.map(item => 
    `${item.original} = ${item.translated} [${item.type}] [${item.lang}]`
  ).join("\n");

  return formattedItems;
}

/**
 * X√≥a m·ªôt glossary item
 */
async function deleteGlossaryItem(itemId) {
  try {
    await prisma.glossaryItem.delete({
      where: { id: itemId }
    });
    return true;
  } catch (error) {
    console.error("‚ùå L·ªói khi x√≥a glossary item:", error);
    return false;
  }
}

/**
 * C·∫≠p nh·∫≠t m·ªôt glossary item
 */
async function updateGlossaryItem(itemId, data) {
  try {
    const updated = await prisma.glossaryItem.update({
      where: { id: itemId },
      data: {
        ...data,
        updatedAt: new Date()
      }
    });
    return updated;
  } catch (error) {
    console.error("‚ùå L·ªói khi c·∫≠p nh·∫≠t glossary item:", error);
    return null;
  }
}

/**
 * T√¨m ki·∫øm glossary items theo t·ª´ kh√≥a
 */
async function searchGlossaryItems(storyId, keyword) {
  try {
    const items = await prisma.glossaryItem.findMany({
      where: {
        storyId,
        OR: [
          { original: { contains: keyword, mode: 'insensitive' } },
          { translated: { contains: keyword, mode: 'insensitive' } },
          { type: { contains: keyword, mode: 'insensitive' } }
        ]
      },
      orderBy: [
        { frequency: 'desc' },
        { createdAt: 'desc' }
      ]
    });
    return items;
  } catch (error) {
    console.error("‚ùå L·ªói khi t√¨m ki·∫øm glossary:", error);
    return [];
  }
}

module.exports = {
  extractAndSaveGlossary,
  getGlossaryByStoryId,
  formatGlossaryForAI,
  deleteGlossaryItem,
  updateGlossaryItem,
  searchGlossaryItems,
  isForeignLanguage,
  containsChineseChars,
  containsJapaneseChars,
  containsKoreanChars
}; 
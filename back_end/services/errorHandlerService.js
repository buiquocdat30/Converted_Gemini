/**
 * Error Handler Service cho Gemini API
 * Ph√¢n bi·ªát v√† x·ª≠ l√Ω c√°c lo·∫°i l·ªói kh√°c nhau t·ª´ Google Generative AI
 */

class ErrorHandlerService {
  constructor() {
    // ƒê·ªãnh nghƒ©a c√°c lo·∫°i l·ªói
    this.ERROR_TYPES = {
      // L·ªói quota/rate limit
      QUOTA_EXCEEDED: 'QUOTA_EXCEEDED',
      RATE_LIMIT: 'RATE_LIMIT',
      DAILY_LIMIT: 'DAILY_LIMIT',
      
      // L·ªói authentication
      INVALID_API_KEY: 'INVALID_API_KEY',
      API_KEY_DISABLED: 'API_KEY_DISABLED',
      API_KEY_EXPIRED: 'API_KEY_EXPIRED',
      
      // L·ªói model
      MODEL_NOT_FOUND: 'MODEL_NOT_FOUND',
      MODEL_DEPRECATED: 'MODEL_DEPRECATED',
      MODEL_UNSUPPORTED: 'MODEL_UNSUPPORTED',
      
      // L·ªói content
      CONTENT_TOO_LONG: 'CONTENT_TOO_LONG',
      CONTENT_VIOLATION: 'CONTENT_VIOLATION',
      CONTENT_FILTERED: 'CONTENT_FILTERED',
      
      // L·ªói network
      NETWORK_ERROR: 'NETWORK_ERROR',
      TIMEOUT: 'TIMEOUT',
      SERVER_ERROR: 'SERVER_ERROR',
      
      // L·ªói kh√°c
      UNKNOWN_ERROR: 'UNKNOWN_ERROR',
      VALIDATION_ERROR: 'VALIDATION_ERROR'
    };

    // Mapping c√°c error codes t·ª´ Google API
    this.GOOGLE_ERROR_CODES = {
      // Quota errors
      '429': this.ERROR_TYPES.RATE_LIMIT,
      'RESOURCE_EXHAUSTED': this.ERROR_TYPES.QUOTA_EXCEEDED,
      
      // Authentication errors
      '401': this.ERROR_TYPES.INVALID_API_KEY,
      '403': this.ERROR_TYPES.API_KEY_DISABLED,
      
      // Model errors
      '404': this.ERROR_TYPES.MODEL_NOT_FOUND,
      '400': this.ERROR_TYPES.VALIDATION_ERROR,
      
      // Server errors
      '500': this.ERROR_TYPES.SERVER_ERROR,
      '502': this.ERROR_TYPES.NETWORK_ERROR,
      '503': this.ERROR_TYPES.SERVER_ERROR,
      '504': this.ERROR_TYPES.TIMEOUT
    };
  }

  /**
   * Ph√¢n t√≠ch l·ªói t·ª´ Gemini API response
   * @param {Error} error - L·ªói t·ª´ GoogleGenerativeAI
   * @returns {Object} Th√¥ng tin l·ªói ƒë√£ ph√¢n lo·∫°i
   */
  analyzeError(error) {
    console.log("üîç Ph√¢n t√≠ch l·ªói:", {
      message: error.message,
      name: error.name,
      stack: error.stack?.substring(0, 200)
    });

    const errorInfo = {
      type: this.ERROR_TYPES.UNKNOWN_ERROR,
      code: null,
      message: error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh',
      details: {},
      retryable: false,
      userMessage: 'ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh',
      solution: 'Vui l√≤ng th·ª≠ l·∫°i sau'
    };

    try {
      // Ph√¢n t√≠ch message ƒë·ªÉ t√¨m error code
      const statusMatch = error.message.match(/\[(\d+)\s+([^\]]+)\]/);
      if (statusMatch) {
        const statusCode = statusMatch[1];
        const statusText = statusMatch[2];
        errorInfo.code = statusCode;
        errorInfo.message = statusText;

        // X√°c ƒë·ªãnh lo·∫°i l·ªói d·ª±a tr√™n status code
        if (this.GOOGLE_ERROR_CODES[statusCode]) {
          errorInfo.type = this.GOOGLE_ERROR_CODES[statusCode];
        }
      }

      // Ph√¢n t√≠ch chi ti·∫øt l·ªói t·ª´ message
      this.analyzeErrorMessage(error.message, errorInfo);

      // Ph√¢n t√≠ch JSON error details n·∫øu c√≥
      this.analyzeErrorDetails(error.message, errorInfo);

      // Set retryable v√† user message
      this.setErrorProperties(errorInfo);

    } catch (parseError) {
      console.error("‚ùå L·ªói khi ph√¢n t√≠ch error:", parseError);
    }

    console.log("üìã K·∫øt qu·∫£ ph√¢n t√≠ch l·ªói:", errorInfo);
    return errorInfo;
  }

  /**
   * Ph√¢n t√≠ch message ƒë·ªÉ x√°c ƒë·ªãnh lo·∫°i l·ªói c·ª• th·ªÉ
   */
  analyzeErrorMessage(message, errorInfo) {
    const lowerMessage = message.toLowerCase();

    // Content errors - ∆∞u ti√™n ph√¢n lo·∫°i c·ª• th·ªÉ tr∆∞·ªõc
    if (lowerMessage.includes('content')) {
      if (lowerMessage.includes('too long') || lowerMessage.includes('exceeds limit') || lowerMessage.includes('maximum allowed limit')) {
        errorInfo.type = this.ERROR_TYPES.CONTENT_TOO_LONG;
      } else if (lowerMessage.includes('violation') || lowerMessage.includes('policy')) {
        errorInfo.type = this.ERROR_TYPES.CONTENT_VIOLATION;
      } else if (lowerMessage.includes('filtered') || lowerMessage.includes('blocked')) {
        errorInfo.type = this.ERROR_TYPES.CONTENT_FILTERED;
      }
    }

    // Quota v√† Rate Limit errors
    if (lowerMessage.includes('quota') || lowerMessage.includes('exceeded')) {
      errorInfo.type = this.ERROR_TYPES.QUOTA_EXCEEDED;
      
      if (lowerMessage.includes('daily')) {
        errorInfo.type = this.ERROR_TYPES.DAILY_LIMIT;
      } else if (lowerMessage.includes('per minute') || lowerMessage.includes('rate')) {
        errorInfo.type = this.ERROR_TYPES.RATE_LIMIT;
      }
    }

    // API Key errors
    if (lowerMessage.includes('api key') || lowerMessage.includes('authentication')) {
      if (lowerMessage.includes('invalid') || lowerMessage.includes('not found')) {
        errorInfo.type = this.ERROR_TYPES.INVALID_API_KEY;
      } else if (lowerMessage.includes('disabled') || lowerMessage.includes('suspended')) {
        errorInfo.type = this.ERROR_TYPES.API_KEY_DISABLED;
      } else if (lowerMessage.includes('expired')) {
        errorInfo.type = this.ERROR_TYPES.API_KEY_EXPIRED;
      }
    }

    // Model errors
    if (lowerMessage.includes('model')) {
      if (lowerMessage.includes('not found') || lowerMessage.includes('does not exist')) {
        errorInfo.type = this.ERROR_TYPES.MODEL_NOT_FOUND;
      } else if (lowerMessage.includes('deprecated') || lowerMessage.includes('no longer supported')) {
        errorInfo.type = this.ERROR_TYPES.MODEL_DEPRECATED;
      } else if (lowerMessage.includes('unsupported')) {
        errorInfo.type = this.ERROR_TYPES.MODEL_UNSUPPORTED;
      }
    }

    // Network errors
    if (lowerMessage.includes('network') || lowerMessage.includes('connection')) {
      errorInfo.type = this.ERROR_TYPES.NETWORK_ERROR;
    }

    // Timeout errors
    if (lowerMessage.includes('timeout') || lowerMessage.includes('timed out')) {
      errorInfo.type = this.ERROR_TYPES.TIMEOUT;
    }

    // Server errors
    if (lowerMessage.includes('server') || lowerMessage.includes('internal')) {
      errorInfo.type = this.ERROR_TYPES.SERVER_ERROR;
    }
  }

  /**
   * Ph√¢n t√≠ch chi ti·∫øt l·ªói t·ª´ JSON response
   */
  analyzeErrorDetails(message, errorInfo) {
    try {
      // T√¨m JSON trong message
      const jsonMatch = message.match(/\[({.*})\]|({.*})/);
      if (jsonMatch) {
        const jsonStr = jsonMatch[1] || jsonMatch[2];
        const errorDetails = JSON.parse(jsonStr);
        
        errorInfo.details = errorDetails;

        // Ph√¢n t√≠ch violations n·∫øu c√≥
        if (errorDetails.violations) {
          errorInfo.details.violations = errorDetails.violations.map(violation => ({
            metric: violation.quotaMetric,
            quotaId: violation.quotaId,
            dimensions: violation.quotaDimensions
          }));
        }

        // Ph√¢n t√≠ch retry info n·∫øu c√≥
        if (errorDetails.retryDelay) {
          errorInfo.details.retryDelay = errorDetails.retryDelay;
        }

        // Ph√¢n t√≠ch help links n·∫øu c√≥
        if (errorDetails.links) {
          errorInfo.details.helpLinks = errorDetails.links;
        }
      }
    } catch (parseError) {
      console.warn("‚ö†Ô∏è Kh√¥ng th·ªÉ parse JSON error details:", parseError);
    }
  }

  /**
   * Set c√°c thu·ªôc t√≠nh retryable v√† user message
   */
  setErrorProperties(errorInfo) {
    switch (errorInfo.type) {
      case this.ERROR_TYPES.QUOTA_EXCEEDED:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'ƒê√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n s·ª≠ d·ª•ng API. Vui l√≤ng n√¢ng c·∫•p g√≥i ho·∫∑c ch·ªù ƒë·∫øn ng√†y mai.';
        errorInfo.solution = 'Ki·ªÉm tra quota v√† billing t·∫°i Google AI Studio';
        break;

      case this.ERROR_TYPES.RATE_LIMIT:
        errorInfo.retryable = true;
        errorInfo.userMessage = 'ƒê√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n request/ph√∫t. Vui l√≤ng ch·ªù 30 gi√¢y v√† th·ª≠ l·∫°i.';
        errorInfo.solution = 'Ch·ªù 30 gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i';
        break;

      case this.ERROR_TYPES.DAILY_LIMIT:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'ƒê√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n s·ª≠ d·ª•ng h√†ng ng√†y. Vui l√≤ng ch·ªù ƒë·∫øn ng√†y mai.';
        errorInfo.solution = 'Ch·ªù reset quota v√†o ng√†y mai';
        break;

      case this.ERROR_TYPES.INVALID_API_KEY:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'API key kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ b·ªã x√≥a.';
        errorInfo.solution = 'Ki·ªÉm tra v√† c·∫≠p nh·∫≠t API key';
        break;

      case this.ERROR_TYPES.API_KEY_DISABLED:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'API key ƒë√£ b·ªã v√¥ hi·ªáu h√≥a.';
        errorInfo.solution = 'K√≠ch ho·∫°t l·∫°i API key t·∫°i Google AI Studio';
        break;

      case this.ERROR_TYPES.API_KEY_EXPIRED:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'API key ƒë√£ h·∫øt h·∫°n.';
        errorInfo.solution = 'T·∫°o API key m·ªõi t·∫°i Google AI Studio';
        break;

      case this.ERROR_TYPES.MODEL_NOT_FOUND:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'Model kh√¥ng t·ªìn t·∫°i ho·∫∑c kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£.';
        errorInfo.solution = 'Ki·ªÉm tra t√™n model v√† c·∫≠p nh·∫≠t n·∫øu c·∫ßn';
        break;

      case this.ERROR_TYPES.MODEL_DEPRECATED:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'Model ƒë√£ b·ªã lo·∫°i b·ªè v√† kh√¥ng c√≤n ƒë∆∞·ª£c h·ªó tr·ª£.';
        errorInfo.solution = 'Chuy·ªÉn sang model m·ªõi h∆°n (gemini-2.0-flash)';
        break;

      case this.ERROR_TYPES.MODEL_UNSUPPORTED:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'Model kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ trong khu v·ª±c n√†y.';
        errorInfo.solution = 'S·ª≠ d·ª•ng model kh√°c ho·∫∑c thay ƒë·ªïi khu v·ª±c';
        break;

      case this.ERROR_TYPES.CONTENT_TOO_LONG:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'N·ªôi dung qu√° d√†i, v∆∞·ª£t qu√° gi·ªõi h·∫°n c·ªßa model.';
        errorInfo.solution = 'Chia nh·ªè n·ªôi dung th√†nh nhi·ªÅu ph·∫ßn';
        break;

      case this.ERROR_TYPES.CONTENT_VIOLATION:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'N·ªôi dung vi ph·∫°m ch√≠nh s√°ch c·ªßa Google AI.';
        errorInfo.solution = 'Ki·ªÉm tra v√† ch·ªânh s·ª≠a n·ªôi dung';
        break;

      case this.ERROR_TYPES.CONTENT_FILTERED:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'N·ªôi dung b·ªã l·ªçc b·ªüi h·ªá th·ªëng an to√†n.';
        errorInfo.solution = 'Ch·ªânh s·ª≠a n·ªôi dung ƒë·ªÉ ph√π h·ª£p v·ªõi ch√≠nh s√°ch';
        break;

      case this.ERROR_TYPES.NETWORK_ERROR:
        errorInfo.retryable = true;
        errorInfo.userMessage = 'L·ªói k·∫øt n·ªëi m·∫°ng. Vui l√≤ng ki·ªÉm tra internet.';
        errorInfo.solution = 'Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† th·ª≠ l·∫°i';
        break;

      case this.ERROR_TYPES.TIMEOUT:
        errorInfo.retryable = true;
        errorInfo.userMessage = 'Request b·ªã timeout. Vui l√≤ng th·ª≠ l·∫°i.';
        errorInfo.solution = 'Th·ª≠ l·∫°i sau v√†i gi√¢y';
        break;

      case this.ERROR_TYPES.SERVER_ERROR:
        errorInfo.retryable = true;
        errorInfo.userMessage = 'L·ªói server. Vui l√≤ng th·ª≠ l·∫°i sau.';
        errorInfo.solution = 'Th·ª≠ l·∫°i sau v√†i ph√∫t';
        break;

      case this.ERROR_TYPES.VALIDATION_ERROR:
        errorInfo.retryable = false;
        errorInfo.userMessage = 'D·ªØ li·ªáu ƒë·∫ßu v√†o kh√¥ng h·ª£p l·ªá.';
        errorInfo.solution = 'Ki·ªÉm tra v√† s·ª≠a d·ªØ li·ªáu ƒë·∫ßu v√†o';
        break;

      default:
        errorInfo.retryable = true;
        errorInfo.userMessage = 'ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh. Vui l√≤ng th·ª≠ l·∫°i.';
        errorInfo.solution = 'Th·ª≠ l·∫°i sau v√†i ph√∫t';
    }
  }

  /**
   * T·∫°o th√¥ng b√°o l·ªói chi ti·∫øt cho developer
   */
  createDeveloperMessage(errorInfo) {
    return {
      type: errorInfo.type,
      code: errorInfo.code,
      message: errorInfo.message,
      details: errorInfo.details,
      retryable: errorInfo.retryable,
      timestamp: new Date().toISOString(),
      userMessage: errorInfo.userMessage,
      solution: errorInfo.solution
    };
  }

  /**
   * T·∫°o th√¥ng b√°o l·ªói ƒë∆°n gi·∫£n cho user
   */
  createUserMessage(errorInfo) {
    return {
      message: errorInfo.userMessage,
      solution: errorInfo.solution,
      retryable: errorInfo.retryable
    };
  }

  /**
   * Ki·ªÉm tra xem c√≥ n√™n retry kh√¥ng
   */
  shouldRetry(errorInfo, retryCount = 0) {
    if (!errorInfo.retryable) return false;
    
    // Gi·ªõi h·∫°n s·ªë l·∫ßn retry
    const maxRetries = 3;
    if (retryCount >= maxRetries) return false;

    // Delay tƒÉng d·∫ßn theo s·ªë l·∫ßn retry
    const delays = [5000, 10000, 15000]; // 5s, 10s, 15s
    return {
      shouldRetry: true,
      delay: delays[retryCount] || delays[delays.length - 1]
    };
  }

  /**
   * Log l·ªói v·ªõi format chu·∫©n
   */
  logError(error, context = {}) {
    const errorInfo = this.analyzeError(error);
    
    console.error("üö® L·ªñI D·ªäCH:", {
      type: errorInfo.type,
      code: errorInfo.code,
      message: errorInfo.message,
      retryable: errorInfo.retryable,
      context: context,
      timestamp: new Date().toISOString(),
      details: errorInfo.details
    });

    return errorInfo;
  }
}

module.exports = ErrorHandlerService; 